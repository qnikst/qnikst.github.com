<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - All posts</title>
    <link href="https://qnikst.github.io/rss.xml" rel="self" />
    <link href="https://qnikst.github.io" />
    <id>https://qnikst.github.io/rss.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2019-12-28T00:00:00Z</updated>
    <entry>
    <title>Resticting servant query parameters</title>
    <link href="https://qnikst.github.io/posts/2019-09-28-restricting-servant.html" />
    <id>https://qnikst.github.io/posts/2019-09-28-restricting-servant.html</id>
    <published>2019-12-28T00:00:00Z</published>
    <updated>2019-12-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In this post, I’d like to share one solution to the problem I had at work. It is split into three parts, <a href="#problem">the definition of the problem</a>, <a href="#boring">boring part</a> (how we can achieve the goal), and then something <a href="#fancy">fancy</a> that we can have if we go a big forward with the solution.</p>
<h1 id="the-problem-definition"><a name="problem">The problem definition</a></h1>
<p>TLDR we want to make our servant service to reply <code>404</code> whenever we see query part in some endpoints subtree. If you are not interested in why do I need that you can proceed to the <a href="#boring">solution</a> directly.</p>
<p>I’m working on building a few web services. One of them provides service to run contents. On such contests, lots of people come at once to solve some tasks. Thus we have a severe load in bounded time (It’s not entirely true as those contests are running all the time, but most of them are quite small). However, we have some significant events with up to 20k unique people passing in 3 hours, generating a load a bit higher than 500rps. It is not high value, but the main problem here is that any issue with availability or responsiveness hit our reputation a lot. Additionally, in the past, we had experienced DDOS attacks during such events. Currently, our services can handle at least three times higher load even in the worth case, but still, we are interested in reducing the surface of the possible attacks. Yet we can handle many requests the network in the cluster is not very wide, so it’s possible to introduce a denial of service if you’ll use all the network by for example loading large data.</p>
<p>The usual solution for such sort of issues is offloading static and large content to a CDN service. Such services are distributed enough can easily manage a high load. There are two kinds of CDN services we can use: external CDN service transparent CDN service.</p>
<p>External CDN service (pic.1) is just a 3rd party service that provides API for uploading and removing files. Such service takes all responsibilities for distributing data and providing the required quality of service. All you do in your user-facing service is giving links to the third-party one. The cost is that you need to upload and control files on that service explicitly.</p>
<p><img src="/images/posts/servant/external.png"/></p>
<p>Transparent CDN service (pic2.) is a service that acts as a distributed proxy for your service. In addition to proxying requests, it stores and propagates files on its nodes based on the response headers. This way, you can control all the data on CDN. Besides, such services often provide firewall and anti-DDOS services.</p>
<p><img src="/images/posts/servant/transparent.png"/></p>
<p>We took the transparent CDN service because our patterns of working with the contest are quite intricate: until frozen files are not expected to be cached and may mutate, but once frozen file can never mutate and should be persisted. Additionally, we get DDOS protection and a firewall for free.</p>
<p>But, just plugging transparent CDN service in front of yours will not work. CDN is very simple, it does not and can’t analyse actual traffic, so if a malicious user asks for <code>https://our.service/content/big_image</code>, and then <code>https://our.service/content/big_image?foobar</code> both requests will pass through CDN and fall on our service. This way attacker can generate infinite amount of URLs and be able to attack the service no matter if there is CDN or not.</p>
<p>But what to do? One option is to forbid access to content if there is a query part of the URL. It looks like a sane option as “valid” clients never access content while adding query parameters. For other parts of the service, it’s done by NGINX rules. But for some parts of the service, it is responsible for generating contents and setting proper headers, and we want it to be accountable to replying 404 on such queries.</p>
<h1 id="solution."><a name="boring">Solution</a>.</h1>
<p>We use <a href="https://hackage.haskell.org/package/servant">servant</a> as a framework to write a server. It allows writing a declarative description of the service structure on the type level. More details on that may be found in the servant <a href="http://docs.servant.dev/en/stable/tutorial/index.html">tutorial</a>, or a very basic <a href="https://qnikst.github.io/posts/2018-10-09-starting-webapp.html">howto</a>.</p>
<p>We want to restrict query parameters on some part of the endpoints tree. It may look like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">MyService</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="fu">=</span> <span class="st">&quot;content&quot;</span> <span class="fu">:&gt;</span> <span class="dt">RestrictQueryParams</span> <span class="fu">:&gt;</span> <span class="dt">ContentEndpoint</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="fu">&lt;|&gt;</span> other<span class="fu">..</span>end<span class="fu">..</span>points</a></code></pre></div>
<p>This way, <code>ContentEndpoint</code> doesn’t know that it was restricted and can implement its logic without knowing how is it called. It is a crucial point that provides a necessary abstraction level.</p>
<p>We are going to implement <code>RestrictQueryParam</code> now. To achieve it, we need to introduce a new servant combinator the one like (Capture, QueryParam or other from the <a href="https://hackage.haskell.org/package/servant-0.16.2/docs/Servant-API.html">Servant.API</a> hierarchy). It’s not particularly well documented, but there are enough examples in the servant itself.</p>
<p>The first thing we need is to introduce the type for</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- | Forbid passing any query parameter.</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- If the parameter is given, then we throw 404</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">data</span> <span class="dt">RestrictQueryParams</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="kw">deriving</span> <span class="dt">Typeable</span></a></code></pre></div>
<p>Note it doesn’t have type constructor there this construction may live on the type level only.</p>
<p>Nest step is implementing <a href="https://hackage.haskell.org/package/servant-server-0.16.2/docs/Servant-Server.html#t:HasServer"><code>HasServer</code></a> instance. This instance describes how we parse the request and how we work with the response.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"> (<span class="dt">HasServer</span> api context) <span class="co">{-1-}</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"> <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (<span class="dt">RestrictQueryParams</span> <span class="fu">:&gt;</span> api) context <span class="kw">where</span> <span class="co">{-2-}</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"> <span class="kw">type</span> <span class="dt">ServerT</span> (<span class="dt">RestrictQueryParams</span> <span class="fu">:&gt;</span> api) m <span class="fu">=</span> <span class="dt">ServerT</span> api m <span class="co">{-3-}</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"> hoistServerWithContext <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"> route <span class="fu">=</span> undefined</a></code></pre></div>
<p>The instance is very straighforward it tells that internal server (<code>{-1-}</code>) wrapped in the <code>RestrictQueryParams</code> (<code>{-2-}</code>) is also a server. Type <code>ServerT</code> tells that resulting server type. In our case it’s the same as for the internal server: RestrictQueryParams doesn’t change it. <code>hoistServerWithContext</code> tells how to change underlying monad if needed, you skip it and see how it’s implemented in the other combinators:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">  hoistServerWithContext _ pc nt s</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    <span class="fu">=</span> hoistServerWithContext (<span class="dt">Proxy</span><span class="ot">::</span> <span class="dt">Proxy</span> api) pc nt s</a></code></pre></div>
<p>And the last but not the least method is the route, that describes routing itself.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">  route <span class="dt">Proxy</span> context subserver <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">     route (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api) context <span class="fu">$</span> add subserver</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">      add <span class="dt">Delayed</span>{<span class="fu">..</span>} <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">        <span class="dt">Delayed</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">          { paramsD <span class="fu">=</span> withRequest check <span class="fu">*&gt;</span> paramsD</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">          , <span class="fu">..</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">          }</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">      check ::</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">DelayedIO</span> ()</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">      check req</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">        <span class="fu">|</span> not <span class="fu">$</span> B.null <span class="fu">$</span> rawQueryString req <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">          delayedFailFatal err404</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">        <span class="fu">|</span> otherwise <span class="fu">=</span> pure ()</a></code></pre></div>
<p>Here we add parameters check to the internal server checks (<code>add subserver</code>). It checks the <code>Wai.Request</code> (<code>withRequest check</code>) to the checks added by internal server (<code>*&gt; paramsD</code>), keeping other checks untouched. In the <code>check</code> function we check <code>rawQueryString</code> and reply with 404 if it’s not emoty. Description of the request checks is given in the <a href="https://hackage.haskell.org/package/servant-server-0.16.2/docs/Servant-Server-Internal-Delayed.html#t:Delayed">docs</a>.</p>
<p>Instances for client and swagger are trivial; they pass all the work to the internal API.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">HasSwagger</span> api) <span class="ot">=&gt;</span> <span class="dt">HasSwagger</span> (<span class="dt">RestrictQueryParams</span> <span class="fu">:&gt;</span> <span class="dt">API</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  toSwagger _ <span class="fu">=</span> toSwagger (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">HasClient</span> m api <span class="ot">=&gt;</span> <span class="dt">HasClient</span> m (<span class="dt">RestrictQueryParams</span> <span class="fu">:&gt;</span> api) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="kw">type</span> <span class="dt">Client</span> m (<span class="dt">RestrictQueryParams</span> <span class="fu">:&gt;</span> api) <span class="fu">=</span> <span class="dt">Client</span> m api</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  clientWithRoute pm <span class="dt">Proxy</span> req <span class="fu">=</span> clientWithRoute pm (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api) req</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  hoistClientMonad pm _ f cl <span class="fu">=</span> hoistClientMonad pm (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api) f cl</a></code></pre></div>
<p>This way, it has landed in our codebase because it just solves the problem. Adding this check solves our problem and can be reused in other projects.</p>
<h1 id="more-checks"><a name="fancy">More checks</a></h1>
<p>But there is a problem. Sub server doesn’t know about that it runs in the restricted context, but the server itself should know if this restriction can be safely applied. It can’t be used if the server uses query parameters. So we want to prove that we doesn’t have this problem. It can be achieved using <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html#t:TypeError">custom type erros</a> more on docs on the <a href="https://gitlab.haskell.org/ghc/ghc/wikis/proposal/custom-type-errors">ghc wiki</a>.</p>
<p>To use it, we need to introduce additional type family. You may think of type family as a function on types, that can perform pattern matching on types and return some result. This function should either return a error or the same type. We need to traverse servant endpoint structure and return a type error.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">CheckNoParams</span> e <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="dt">CheckNoParams</span> (f <span class="fu">:&gt;</span> g) <span class="fu">=</span> f <span class="fu">:&gt;</span> (<span class="dt">CheckNoParams</span> g)</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="dt">CheckNoParams</span> (f <span class="fu">:&lt;|&gt;</span> g) <span class="fu">=</span> <span class="dt">CheckNoParams</span> f <span class="fu">:&lt;|&gt;</span> <span class="dt">CheckNoParams</span> g</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="dt">CheckNoParams</span> (<span class="dt">QueryParam</span> sym x <span class="fu">:&gt;</span> y) <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    <span class="dt">TypeError</span> (&#39;<span class="dt">Text</span> <span class="st">&quot;can&#39;t use QueryParam under RestrictQueryParams&quot;</span>)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="dt">CheckNoParams</span> a <span class="fu">=</span> a</a></code></pre></div>
<p>This way we recursively go through all endpoints (lines 1 and 2), return a error if see a query param (line 3), and type as it was if it’s not QueryParam (line 5)</p>
<p>If you’ll use <code>RestrictQueryParam</code> on the endpoint that uses query you get following error message:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">src<span class="fu">/</span>Server.hs<span class="fu">:</span><span class="dv">124</span><span class="fu">:</span><span class="dv">9</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    • can&#39;t use <span class="dt">QueryParam</span> under <span class="dt">RestrictQueryParams</span></a></code></pre></div>
<p>I think after the post it will land in the codebase as well.</p>
<p>But it’s possible to go even further and allow the headers that are used in the internal site. Unfortunately this problem is much more complex and I’m not sure if the checks will not be too expensive, but if anyone has a solution I’ll be happy to check it.</p>]]></summary>
</entry>
<entry>
    <title>Writing a simple web-application</title>
    <link href="https://qnikst.github.io/posts/2018-10-09-starting-webapp.html" />
    <id>https://qnikst.github.io/posts/2018-10-09-starting-webapp.html</id>
    <published>2018-10-09T00:00:00Z</published>
    <updated>2018-10-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the <a href="https://qnikst.github.io/posts/2018-10-29-metrics-haskell.html">last post</a>, I’ve talked about adding metrics to a Haskell application. Unfortunately that post didn’t have a full code example and contained only minor pieces of the code. So it could be hard to write your own application based on that post. So I decided to prepare a full example that can be looked at and reused in later posts and projects. You can find the source code on <a href="https://github.com/qnikst/sample-site">GitHub</a>. The app is a very simple skeleton so if you have experience with writing those feel free to skip this post.</p>
<p>I’ll take <a href="https://www.techempower.com/benchmarks/">the techempower benchmark</a> as a site specification. The API is simple enough to represent exciting features and doesn’t take much time to write. I’m not going to compete against other implementations of that benchmark (at least I think so at the time of writing this post). Today I’m going to make a skeleton of the site and one endpoint only.</p>
<p>I’ll take servant as a web framework, to my taste it is the best framework you can use unless you have exceptional needs. The main feature of the servant framework is that it allows to generate and test much code for free, without much extra cost.</p>
<p>Servant framework has a very nice tutorial and documentation that can be found at <a href="https://haskell-servant.readthedocs.io/en/stable/">read-the-doc site</a> .</p>
<p>When writing an application using servant you first need to define its API:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Api</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">JsonApi</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">type</span> <span class="dt">JsonApi</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="fu">=</span> <span class="dt">Description</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="st">&quot;Raw JSON output API \</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="st">    \ For each request, an object mapping the key message \</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="st">    \ to \&quot;Hello, World!\&quot; must be instantiated.&quot;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="fu">:&gt;</span> <span class="st">&quot;json&quot;</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Message</span></a></code></pre></div>
<p>I prefer to keep a type synonym for each endpoint (or endpoint structure) as that would allow using that type in the other parts of the program for code generation.</p>
<p>This type explains how a handler does its work and <code>:&gt;</code> splits the type into URL pieces. This type tells that application can handle Get requests to the URL <code>/json</code> if accept type is <code>application/json</code> and when doing that it returns a <code>Message.</code></p>
<p>The additional <code>Description</code> part comes from the <a href="http://hackage.haskell.org/package/servant-swagger">servant-swagger</a> package. A few more extra lines provide additional information about our API:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">apiVersion ::</span> <span class="dt">T.Text</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">apiVersion <span class="fu">=</span> <span class="st">&quot;0.0.1&quot;</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">swagger ::</span> <span class="dt">Swagger</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">swagger <span class="fu">=</span> toSwagger (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">Api</span>)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="fu">&amp;</span> info<span class="fu">.</span>title <span class="fu">.~</span> <span class="st">&quot;Experimental API&quot;</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="fu">&amp;</span> info<span class="fu">.</span>description <span class="fu">?~</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    <span class="st">&quot;This is a benchmark site, and used for general \</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="st">    \ experiments and blog examples.&quot;</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="fu">&amp;</span> info<span class="fu">.</span>version <span class="fu">.~</span> apiVersion</a></code></pre></div>
<p>Now we can run the server. Our sever consists of the swagger UI and our application.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">SwaggerSchemaUI</span> <span class="st">&quot;swagger-ui&quot;</span> <span class="st">&quot;swagger.json&quot;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="fu">:&lt;|&gt;</span> <span class="dt">Api</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">run ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">run <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  Warp.run configPort</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="fu">$</span> prometheus def {</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        prometheusInstrumentPrometheus <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        }</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    <span class="fu">$</span> serve (<span class="dt">Proxy</span> <span class="fu">@</span><span class="dt">API</span>)</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    <span class="fu">$</span> swaggerSchemaUIServer swagger </a>
<a class="sourceLine" id="cb3-13" data-line-number="13">        <span class="fu">:&lt;|&gt;</span> server</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="ot">    configPort ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">    configPort <span class="fu">=</span> <span class="dv">8080</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17"></a>
<a class="sourceLine" id="cb3-18" data-line-number="18"><span class="ot">server ::</span> <span class="dt">Handler</span> <span class="dt">Message</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">server <span class="fu">=</span> pure <span class="fu">$</span> <span class="dt">Message</span> <span class="st">&quot;Hello World!&quot;</span></a></code></pre></div>
<p>Remember <code>prometheus def</code> lines from the previous post. And the application runner is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Prometheus</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Prometheus.Metric.GHC</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Sample.Server</span> (run)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  _ <span class="ot">&lt;-</span> register ghcMetrics</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  run</a></code></pre></div>
<p>Now we can have an application that returns us <code>{message:&quot;Hello, World!&quot;}</code> on <code>json</code> URL and swagger UI on <code>swagger-ui/</code>. With that interface you can explore site API:</p>
<div>
<img src="../images/posts/web-app-1/0.swagger-ui-1.png" width="80%" style="inline"/>
</div>
<p>Send requests and observe results</p>
<div>
<img src="../images/posts/web-app-1/1.swagger-ui-2.png" width="80%" style="inline"/>
</div>
<p>And all that comes for free.</p>
<p>There are a few more things I’d like to discuss before moving to metrics:</p>
<ol type="1">
<li><p><a href="https://github.com/qnikst/sample-site/blob/2d6bb3b39ce6a6e5afe9de055cda73d6babcce0c/sample-site/src/Data/Aeson/Extended.hs#L11-L21">Naming conventions</a> - it’s worth to define common conventions for converting Haskell data types into their JSON representation and use them across the project.</p></li>
<li><p><a href="https://github.com/qnikst/sample-site/blob/master/sample-site/test/spec/Sample/ApiSpec.hs#L23-L35">Encoding tests</a> with servant and swagger you can automatically test serialisation of values for all the types used in the API. Also tests check that specification is up to date.</p></li>
</ol>
<p>Now we have a simple site with helper interface and specification. There are many missing pieces, for example: a. configuration parsing; b. logging; c. more autogenerated tests; d. nice defaults for RTS options.</p>
<p>All of them will be covered in the following posts.</p>
<p>In order to build everything I prefer to use <code>nix</code> package manager. Both <code>stack</code> and <code>cabal-install</code> are nice tools to do that but with nix you can add more features to the build system. For example building of docker containers, building packages written in other languages and setting up a development environment. Build scripts for the package can be found at <a href="https://github.com/qnikst/sample-site/blob/2d6bb3b39ce6a6e5afe9de055cda73d6babcce0c/nix/overlays.nix#L15-L19">overlays.nix</a>. Build scripts for its docker container are in <a href="https://github.com/qnikst/sample-site/blob/2d6bb3b39ce6a6e5afe9de055cda73d6babcce0c/nix/docker.nix#L8-L28">docker.nix</a>.</p>
<p>At this point we are ready to setup our environment with Grafana and Prometheus. Configs are the same as the ones described earlier or they can be found at <a href="https://github.com/qnikst/sample-site/tree/2d6bb3b39ce6a6e5afe9de055cda73d6babcce0c/deploy/docker">GitHub</a>.</p>
<p>Graphana reports are looking like:</p>
<ol type="1">
<li>Main screen: <br /> main screen lists all instances with Haskell application to filter on. If specific instance is chosen then all the following plots show information for that instance only.
<div style="margin: 10px 0;">
<img src="../images/posts/web-app-1/3.grafana-1.png" width="100%" style="inline"/>
</div></li>
<li>CPU panel:<br /> shows rate of CPU seconds spent by the program. Basically it says whaf fraction of a secod the program worked during 1s of clock time. You can realize how active your application was. <code>Mutator CPU time</code> shows how much CPU time you’ve spent doing actual work. If total CPU time is much higher than Mutator CPU time, then you are likely to have problems with GC.
<div style="margin: 10px 0; ">
<img src="../images/posts/web-app-1/4.grafana-1.png" width="100%" style="inline"/>
</div></li>
<li>Memory panel:<br /> shows the rate of allocations and copying data during GC. This panel is for general information because it’s not easier to use other controller to get information about memory usage of the given instance.
<div style="margin: 10px 0;">
<img src="../images/posts/web-app-1/5.grafana-1.png" width="100%" style="inline"/>
</div></li>
<li>GC information:<br /> data that shows GC information that is provided by the runtime system. It provides total number of GCs and major GCs and their rate. Proportion of time spent in GC to the total running time, if this metric grows higher than 0.1 then it means that you are spending one tenth of your time in GCs and that is not good. Proportion of the time that capabilities spent synchronising to the time they did actual work, if this value grows high then you have problems.
<div style="margin: 10px 0;">
<img src="../images/posts/web-app-1/6.grafana-1.png" width="100%" style="inline"/>
</div>
In addition the structure of the heap is explained and we plot how many values of different types (from GC perspective) we have.
<div style="margin: 10px 0;">
<img src="../images/posts/web-app-1/7.grafana-1.png" width="100%" style="inline"/>
</div></li>
</ol>
<p>Config itself can be taken from <a href="https://raw.githubusercontent.com/qnikst/sample-site/master/deploy/docker/rts.json">GitHub</a>.</p>
<p>Unfortunately GC information tells us information about the last GC only so everything that had happened between scribe intervals will be missing from our data. In the next post I’m going to run some benchmarks of the application (and potentially introduce other endpoints) and discuss if missing information is actually a problem and what can be done about that.</p>]]></summary>
</entry>
<entry>
    <title>Metric a Haskell application</title>
    <link href="https://qnikst.github.io/posts/2018-09-29-metrics-haskell.html" />
    <id>https://qnikst.github.io/posts/2018-09-29-metrics-haskell.html</id>
    <published>2018-09-29T00:00:00Z</published>
    <updated>2018-09-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In one of my <a href="https://qnikst.github.io/posts/2018-08-23-ht-no-more.html">recept posts</a>, I’ve mentioned gathering metrics of my Haskell application. Some people asked me about my setup so I will try to describe how I configure and structure my applications.</p>
<p>I will try to split the description in a series of posts, in this one I’ll describe the general setup. After reading this post you’ll be able to set up the metrics system of your Haskell application (or suggest me how to do that better). At this point you’ll be able to get some information about your application and set up alerts based on that. In the following posts we will try to go deeper into each metric, check if those metrics are helpful, look if any pieces are missing and how that could be improved.</p>
<h2 id="haskell-and-metrics.">Haskell and metrics.</h2>
<p>Let’s spend a bit of time defining the problem we want to solve and describing its solution area. The purpose of a metrics system is to tell if your application is alive and behaves as expected. It should not give you more than statistical information about your application. We can split information into two categories:</p>
<ol type="1">
<li>general information: memory use, runtime system statistics.</li>
<li>application specific information.</li>
</ol>
<p>The border line between those two is quite fuzzy: for example, you may have a general web-server statistics, like number of processed requests or time to reply which are application specific but applicable to any web-server. So I’d add them to the first group. But the main trap here is not to try to solve an incorrect problem; metrics may not work as an exact source of information. Nor could they be a mechanism for tracing or log server, you need other tools for thse purposes.</p>
<p>In the Haskell ecosystem, there are a few packages providing metrics support. The one that is the best known and has a long history is <a href="https://hackage.haskell.org/package/ekg-core">EKG</a> - this package offers few metrics types and a large variety of systems that you can integrate with. While EKG is generally a good generic solution, I found that some companies are trying to move from that package. (I was not able to gather concrete reports what was a problem with it, so I will try to avoid answering that question).</p>
<p>Otherwise we can take a specific solution that works great with a single system. In Tweag we’re used to use <a href="https://prometheus.io/">Prometheus</a>. With Prometheus you can dump your metrics to the well-maintained package that other people usually familiar with. Hackage offers an excellent library for working with Prometheus: <a href="https://hackage.haskell.org/package/prometheus-client">prometheus-client</a>. Even if you like EKG more or have projects that are using it you can use the adapter for EKG <a href="https://hackage.haskell.org/package/ekg-prometheus-adapter">ekg-prometheus-adapter</a>. I have not used that package myself but I hope that it just works, or at least it could be easily fixed.</p>
<h2 id="setup.">Setup.</h2>
<p>For an application setup I’m going to use Docker compose. With this approach we will be able to cover all the details and this approach may be adapted to a more complex system like Kubernetes.</p>
<p>Let’s start writing docker compose files. I omitted all irrelevant links and configuration.</p>
<pre class="docker"><code>version: &quot;3&quot;
services:

  haskell-app:
    image: &lt;your-image&gt;
    ports:
    - &#39;8080:8080&#39;

  node_exporter:
    image: prom/node-exporter
    expose:
      - 9100
  
  prometheus:
    image: prom/prometheus:latest
    volumes:
    - ./config/prometheus:/etc/prometheus
    - prometheus_data:/prometheus
    command:
    - &#39;--config.file=/etc/prometheus/prometheus.yml&#39;
    ports:
    - &#39;9090:9090&#39;
    links:
    - haskell-app
  grafana:
    image: grafana/grafana
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=XxXchangemeXxX
    depends_on:
      - prometheus
    ports:
      - &quot;3000:3000&quot;
    links:
      - prometheus
    volumes:
      - grafana_data:/var/lib/grafana
    user: &quot;104&quot;    

volumes:
  prometheus_data: {}
  grafana_data: {}</code></pre>
<p>Prometheus config:</p>
<pre class="docker"><code>global:
    scrape_interval: 5s
    external_labels:
      monitor: &#39;my-monitor&#39;
scrape_configs:
  - job_name: &#39;myapp&#39;
    static_configs:
      - targets: 
        - haskell-app:8080</code></pre>
<p>It’s possible to configure Grafana declaratively as well but as I don’t have a final solution that I can use out of the box on any system I tend to setup Grafana manually. Just log into your instance and go through the onboarding process.</p>
<p>Now we are ready to set up our Haskell application.</p>
<p>Setup of a Haskell application may be pretty simple. To dump GHC statistics you may use <a href="https://hackage.haskell.org/package/prometheus-metrics-ghc">prometheus-metrics-ghc</a>. To make the full use of this package you need to enable gathering of runtime statistics with:</p>
<pre class="cabal"><code>  build-depends: prometheus-metrics-ghc
  ghc-options: &quot;-with-rtsopts=-T&quot;</code></pre>
<p>Then add to your main:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">import</span>  <span class="dt">Prometheus</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">import</span>  <span class="dt">Prometheus.Metric.GHC</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">main  ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">   register ghcMetrics</a></code></pre></div>
<p>At this point you gather RTS stats but you don’t export you metrics yet. To export your data you may want to use <a href="https://hackage.haskell.org/package/wai-middleware-prometheus">wai-middleware-prometheus</a>. This package allows you to provide metrics inside any <code>wai</code>/<code>warp</code> application.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Network.Wai.Middleware.Prometheus</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Prometheus</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Prometheus.Metric.GHC</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">main <span class="fu">=</span> <span class="kw">do</span> </a>
<a class="sourceLine" id="cb5-6" data-line-number="6">   register ghcMetrics</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">   Warp.run <span class="dv">9090</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">        <span class="fu">$</span>   prometheus def</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">              { prometheusInstrumentPrometheus  <span class="fu">=</span><span class="dt">False</span> }</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">         <span class="fu">$</span> yourApplication</a></code></pre></div>
<p>Or use <a href="https://hackage.haskell.org/package/wai-middleware-prometheus-1.0.0/docs/Network-Wai-Middleware-Prometheus.html#v:metricsApp">metricsApp</a> function if you don’t have any web application. And Prometheus will scrape that data from your application. At this point you’ll have some basic information about your endpoints and GC stats. And you can add your application-specific data using Prometheus interface.</p>
<p>We will cover interesting stats in the next posts but for now you may be interested in the following data:</p>
<ul>
<li><code>ghc_allocated_bytes_total</code> - to build a <code>rate</code> plot based on that metric</li>
<li><code>ghc_num_gcs</code> - to build a rate plot of GCs</li>
<li><code>ghc_mutator_wall_seconds_total/(ghc_mutator_wall_seconds_total+ghc_gc_wall_seconds_total)</code> - to understand the proportion of time spent in GC</li>
<li>information about memory usage split by the type of memory</li>
<li>and a number of metrics from <code>ghc_gcdetails</code> category. This data may not be very useful as it shows data since last GC, so you may report the same GC multiple times if no GC happened during the report period, or miss some reports if more that one GC happens.</li>
</ul>
<p>I hope that this information will be useful and will try to dig into concrete metrics examples in the following posts.</p>]]></summary>
</entry>
<entry>
    <title>Marrying Haskell and Hyper-Threading (Post Scriptum)</title>
    <link href="https://qnikst.github.io/posts/2018-08-27-ht-no-more2.html" />
    <id>https://qnikst.github.io/posts/2018-08-27-ht-no-more2.html</id>
    <published>2018-08-22T00:00:00Z</published>
    <updated>2018-08-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>After writing of the previous blog <a href="/posts/2018-08-23-ht-no-more.html">post</a>, I got some interesting feedback from the working chat and <a href="https://www.reddit.com/r/haskell/comments/99rihw/qnikst_blog_marrying_haskell_and_hyperthreading/">r/haskell</a>. Some of the input I want to hightlight explicitly. Feedback order is arbitrary.</p>
<p>First thing is a discussion of the explicit pinning capabilities to the cores. It’s possible using <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-concurrent.html#rts-flag--qa">+RTS -qa</a> flag, as it was mentioned by the <a href="https://www.reddit.com/user/nh2_">nh2</a> on Reddit. As I mentioned in the previous blog post, my approach will not work with this option correctly (for some reason I have used <code>-xm</code> instead of <code>-qa</code> in that post, I’m sorry) and I’ll need to redefine more functions. But in general pinning capabilities to cores may work on all possible CPU layouts. I have not looked deep inside that issue as in most of our cases <code>-qa</code> flag gave me worse performance, so your program should have some special properties to make benefit from the hard pinning. I think it’s possible to use <code>/proc/cpuinfo</code> to make the most efforts when pinning capabilities.</p>
<p>The entire thread is very entertaining and if you are interested in the topic then I recommend to check out ther comments as well.</p>
<p>Secondly, there was a question if my reasoning was incorrect and it’s enough to leave one thread off and still have better performance. We used this approach in some projects, however for one particular case the results with <code>N-1</code> threads were very depressing:</p>
<pre><code>        Cumulative quantiles per tag (N7)
        99%       98%     95%    90%    85%      80%   75%    50%
Overall 4600ms   4380ms   3980ms 3540ms 3400ms 3280ms 3210ms 1105ms
get     4600ms   4390ms   3980ms 3550ms 3410ms 3290ms 3210ms 1145ms
put     4600ms   4380ms   3980ms 3540ms 3400ms 3280ms 3210ms 1100ms</code></pre>
<pre><code>        Cumulative quantiles per tag (N4)
        99%       98%     95%      90%    85%     80%   75%    50%
Overall  139ms    105ms     37ms   17ms   12ms    8ms    6ms    2ms
get      139ms    104ms     37ms   18ms   12ms    9ms    7ms    2ms
put      139ms    105ms     37ms   17ms   12ms    8ms    6ms    2ms</code></pre>
<p>There is 1 to 3 orders of magnitude differences in response times, without going deeper I have decided to stick with <code>-N4</code> for now.</p>
<p>The third, @<a href="https://github.com/TerrorJack">TerrorJack</a> adviced me to improve <a href="https://github.com/ghc/ghc/blob/1c2c2d3dfd4c36884b22163872feb87122b4528d/rts/RtsMain.c#L70-L95">teardown</a> procedure in the <code>wrapper.c</code>, as it should check if<code>RTS</code> was stopped and report its status. So I have rechecked the sources and introduced few updates that allow to report status of running haskell command (the same way as RTS does), and which do not require using FFI extension in the Haskell code.</p>]]></summary>
</entry>
<entry>
    <title>Marrying Haskell and Hyper-Threading</title>
    <link href="https://qnikst.github.io/posts/2018-08-23-ht-no-more.html" />
    <id>https://qnikst.github.io/posts/2018-08-23-ht-no-more.html</id>
    <published>2018-08-22T00:00:00Z</published>
    <updated>2018-08-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In this blog post I’d like to tell one story that had happened with one Haskell application. Then I’ll explain how can we start threaded RTS in a way so it is aware of the CPU layout of your system. If you want to skip the story you may proceed to the solution directly.</p>
<p>Some updates to this post can be found in the <a href="./2018-08-27-ht-no-more2.html">next one</a>.</p>
<p>Recently I’ve written a small Haskell application that performs some cryptography routines, query management, and communication with Redis. We wanted to test the capabilities of the application and measure RPS that application can support. We used Yandex Tank for this purpose. <a href="https://yandextank.readthedocs.io/en/latest/index.html">Yandex tank</a> can generate a load for a site and build some <a href="https://overload.yandex.net/1">fantastic reports</a> (it could require GitHub authorization).</p>
<p>Results were quite interesting. At first everything went well: the application was able to process about <code>1k</code> requests per second and that was enough for the expected load. However, when Yandex Tank gave a pressure of about <code>2k</code> RPS the situation became worse. The application stopped being responsive. It was able to process only <code>200</code> requests per second. That was troublesome. On the Yandex tank plots there was a period of reasonable performance and then a period of unresponsiveness.</p>
<img src="../images/posts/ht-no-more/1.plot.jpg" alt="Spikes on the tank terminal report" />
<div>
<img src="../images/posts/ht-no-more/2.tank.report.png" width="399" style="inline"/><img src=" ../images/posts/ht-no-more/3.tank.report.png" width="399" style="inline"/>
</div>
<p>As it happens the first suspect in such cases is the Garbage Collector. You can always hear lots of scary stories about how GC could ruin your life. Keeping that in mind GC was tuned beforehand and I had prepared some metrics. However this time the situation was quite OK: garbage collector pauses were all below 10ms and 99% of the total program time was spent on actual work and not on garbage collection. Memory usage was too big - around 700Mb and I didn’t expect that.</p>
<figure>
<img src="../images/posts/ht-no-more/4.gc-info.jpg" alt="GC Information" /><figcaption>GC Information</figcaption>
</figure>
<p>On the left plot you can see reports of the last GC, they are not very precise as they may miss some GCs or report the same GC twice. However they still tell us the order of magnutude. On the right plot we see the ratio of the time spent in mutator to the total running time.</p>
<p>Other parts of the system were not under a stress and were capable of handling higher loads. So the issue was in my program. Although I didn’t spend much time optimising the program, it should behave better.</p>
<p>Another surprising fact was that the issue didn’t appear on my system which is comparable to the one where stress tests were running, and the one that could handle higher load. Accidentally I realised the difference, and the following dialogue took place:</p>
<blockquote>
<p>Me: What is the CPU on the system?</p>
<p>Admin: I7 4 cores, eight thread!</p>
<p>Me: Ah! Add <code>GHCRTS=-N4</code> to the container’s Environment.</p>
</blockquote>
<p>After that single adjustment the situation changed drastically: the program was now able to process 4.5k RPS (comparable to the maximum load that a single instance of Yandex.Tank can generate), now mutator time got &gt;99%, GC pauses were still ~10ms but very rare and memory usage was about 25Mb.</p>
<img src="../images/posts/ht-no-more/4.gc-info.jpg" alt="GC Information" />
<div>
<img src="../images/posts/ht-no-more/5.tank.report.png" width="399" style="inline"/><img src=" ../images/posts/ht-no-more/6.tank.report.png" width="399" style="inline"/>
</div>
<p>Connect time was still terrible in that case but it was fixed by reconfiguring and improving network which is out of scope here.</p>
<p>So this is just another story about suboptimal defaults for the runtime system. It happens that if you pass <code>+RTS -N</code> option - you tell runtime system to start the same number of capabilities as the number of cores you have. However, <code>RTS</code> makes no difference between real and virtual cores. It appears that <code>RTS</code> could not make enough benefit from virtual cores and performance is not good enough in that case.</p>
<p>While it is pretty impressive that we can optimise a program without any changes in source code, it’s interesting what can we do in general case. It’s problematic that we can not set good options which work on any CPU and have a decent performance. To find an answer I’ve started the project <a href="https://github.com/qnikst/haskell-fun/tree/master/ht-no-more">ht-no-more</a>. It lives in my playground for now but I can extract it to a separate repo. I hope that at some point it will be mature enough to be used as a library or even land to into the RTS source code.</p>
<h2 id="solution">Solution <a name="solution"></a></h2>
<p>The idea is to gather information about the architecture during a program startup and then set up an RTS with a proper configuration. We want:</p>
<ol type="1">
<li>collect information about a CPU (how many real and how many virtual cores do we have);</li>
<li>do not allow RTS to run work on virtual cores;</li>
<li>make it so <code>+RTS -N</code> option still behaves well.</li>
</ol>
<p><em>N.B. From this place and now on we assume that we run on <code>Linux</code> only and that we have <code>procfs</code> mounted and that we can write non-portable code. Now our life is comfortable, and we can proceed with the task.</em></p>
<p>The first question is how can we tie our process to a <code>CPU</code>. There are <a href="https://linux.die.net/man/2/sched_setaffinity">sched_getaffinity()</a> and <a href="https://linux.die.net/man/2/sched_setaffinity">sched_setaffinity()</a> calls. Those methods perform hard wiring of a process and all it’s descendent processes to given CPUs. So we can use them to mask CPUs that we are not interested in.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="dt">int</span> sched_setaffinity(pid_t pid, <span class="dt">size_t</span> cpusetsize,</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">                      cpu_set_t *mask);</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="dt">int</span> sched_getaffinity(pid_t pid, <span class="dt">size_t</span> cpusetsize,</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">                      cpu_set_t *mask);</a></code></pre></div>
<p>First let’s write a simple <code>c</code> program that explains the API.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="pp">#define _GNU_SOURCE          </span><span class="co">// allow to use non-portable functions</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="pp">#include </span><span class="im">&lt;sched.h&gt;</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> * argv[]) {</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  cpu_set_t set;            <span class="co">// define CPU set</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  CPU_ZERO(&amp;set);           <span class="co">// mark all CPUs as unused</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  CPU_SET(<span class="dv">0</span>, &amp;set);         <span class="co">// allow to use first CPU</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  sched_setaffinity(<span class="dv">0</span>, <span class="kw">sizeof</span>(cpu_set_t), &amp;set); <span class="co">// wire process to CPU</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  <span class="dt">int</span> result = system(<span class="st">&quot;bash&quot;</span>); <span class="co">// start bash.</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  <span class="cf">return</span> result;</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">}</a></code></pre></div>
<p>In this first program we allow an application to run only on the first CPU. We need this program later for testing purposes. I’ve used it to check if my program behaves well in the constrained case.</p>
<p>The next question is how to check if a processor is real or virtual. The only way I’ve found it is to parse <code>/proc/cpuinfo</code> file. We are interested in <code>core id</code> entry for each processor: it tells what the index of the real core that CPU is set on is. For example on my machine I have:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">grep</span> <span class="st">&#39;core id&#39;</span> /proc/cpuinfo </a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ex">core</span> id        : 0</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ex">core</span> id        : 1</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ex">core</span> id        : 2</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ex">core</span> id        : 3</a></code></pre></div>
<p>As I have Hyper-Threading disabled - all cores are real ones. On digital ocean host, I have:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">grep</span> <span class="st">&#39;core id&#39;</span> /proc/cpuinfo </a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">core</span> id        : 0</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ex">core</span> id        : 0</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ex">core</span> id        : 0</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ex">core</span> id        : 0</a></code></pre></div>
<p>all CPU are on the same core (at least for the container).</p>
<p>Now we can combine the answers to the questions and write the code. We need to remember that there is an additional case that we want to cover: if the CPU was already disabled for our program – then we don’t want to “unmask” it. As a result, I ended up with the following code:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dt">int</span> setcpus() {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">   cpu_set_t set;</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">   <span class="dt">int</span> ret = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">   ret = sched_getaffinity(<span class="dv">0</span>, <span class="kw">sizeof</span>(cpu_set_t), &amp;set);</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">   <span class="cf">if</span> (ret == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">     fprintf(stderr, <span class="st">&quot;Error: failed to get cpu affinity&quot;</span>);</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">     <span class="cf">return</span> <span class="dv">0</span>; <span class="co">// We instruct code that we have failed and it should fallback to the normal procedure.</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">   }</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">   <span class="dt">int</span> current_cpu = <span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">   <span class="dt">int</span> current_core = <span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">   <span class="dt">FILE</span> *cpuinfo = fopen(<span class="st">&quot;/proc/cpuinfo&quot;</span>, <span class="st">&quot;rb&quot;</span>);</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">   <span class="dt">char</span> *arg = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">   <span class="dt">size_t</span> size = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"></a>
<a class="sourceLine" id="cb5-16" data-line-number="16"></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">   <span class="cf">while</span>(getdelim(&amp;arg, &amp;size, <span class="ch">&#39;\n&#39;</span>, cpuinfo) != <span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">   {</a>
<a class="sourceLine" id="cb5-19" data-line-number="19">      <span class="cf">if</span> (strstr(arg, <span class="st">&quot;core id&quot;</span>) != NULL) {</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">	current_core++;</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">	<span class="dt">char</span> * found = strchr(arg, <span class="ch">&#39;:&#39;</span>);</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">	<span class="cf">if</span> (found) {</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">	   <span class="dt">int</span> cpu = atoi(found+<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">	   <span class="cf">if</span> (current_cpu != cpu) {</a>
<a class="sourceLine" id="cb5-25" data-line-number="25">              current_cpu++;</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">	      <span class="cf">if</span> (CPU_ISSET(current_core, &amp;set)) {</a>
<a class="sourceLine" id="cb5-27" data-line-number="27">	         CPU_SET(current_core, &amp;set);  <span class="co">// XXX: this is noop.</span></a>
<a class="sourceLine" id="cb5-28" data-line-number="28">	         fprintf(stderr, <span class="st">&quot;%i real core - enabling</span><span class="sc">\n</span><span class="st">&quot;</span>, current_core);</a>
<a class="sourceLine" id="cb5-29" data-line-number="29">	      } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb5-30" data-line-number="30">	         fprintf(stderr, <span class="st">&quot;%i was disabled - skipping</span><span class="sc">\n</span><span class="st">&quot;</span>, current_core);</a>
<a class="sourceLine" id="cb5-31" data-line-number="31">	      }</a>
<a class="sourceLine" id="cb5-32" data-line-number="32">           } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb5-33" data-line-number="33">              fprintf(stderr, <span class="st">&quot;%i is virual - skipping</span><span class="sc">\n</span><span class="st">&quot;</span>, current_core);</a>
<a class="sourceLine" id="cb5-34" data-line-number="34">	      CPU_CLR(current_core, &amp;set);</a>
<a class="sourceLine" id="cb5-35" data-line-number="35">           }</a>
<a class="sourceLine" id="cb5-36" data-line-number="36">        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb5-37" data-line-number="37">	   <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb5-38" data-line-number="38">	}</a>
<a class="sourceLine" id="cb5-39" data-line-number="39">      }</a>
<a class="sourceLine" id="cb5-40" data-line-number="40">   }</a>
<a class="sourceLine" id="cb5-41" data-line-number="41">   ret = sched_setaffinity(<span class="dv">0</span>, <span class="kw">sizeof</span>(cpu_set_t), &amp;set);</a>
<a class="sourceLine" id="cb5-42" data-line-number="42">   <span class="cf">if</span> (ret == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb5-43" data-line-number="43">     fprintf(stderr, <span class="st">&quot;Error: failed to set affinities - falling back to default procedure</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb5-44" data-line-number="44">     procno = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-45" data-line-number="45">   } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb5-46" data-line-number="46">     procno = current_cpu;</a>
<a class="sourceLine" id="cb5-47" data-line-number="47">   }</a>
<a class="sourceLine" id="cb5-48" data-line-number="48">   free(arg);</a>
<a class="sourceLine" id="cb5-49" data-line-number="49">   fclose(cpuinfo);</a>
<a class="sourceLine" id="cb5-50" data-line-number="50">   <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-51" data-line-number="51">}</a></code></pre></div>
<p>Now we are ready to build a cabal project. I’m skipping all irrelevant things that are generated by <code>cabal init</code></p>
<pre class="cabal"><code>executable ht-no-more
  main-is:             wrapper.c
  other-modules:       Entry 
  build-depends:       base &gt;=4.10 &amp;&amp; &lt;4.11
  default-language:    Haskell2010
  ghc-options:         -no-hs-main</code></pre>
<p>To highlight the important things: first of all, our main module is a <code>C</code> file. It does not work with old <code>cabal</code>’s that allowed only Haskell modules to be the main one. Then we add <code>-no-hs-main</code> – an option that tells GHC not to create its own “main” and use the “main” function that we define. We define <code>Entry.hs</code> Haskell module that provides an entry function because we no longer have one. In that module we create a single function that tells how many capabilities RTS have created.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Entry</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Control.Concurrent</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">foreign export ccall<span class="ot"> entry ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="ot">entry ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">entry <span class="fu">=</span> print <span class="fu">=&lt;&lt;</span> getNumCapabilities</a></code></pre></div>
<p>The only non-trivial thing we need is to export a foreign function. Compiler generates a <code>C</code> complatible object called <code>entry</code> that we can call from <code>C</code>.</p>
<p>We follow <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#using-your-own-main">GHC User’s Guide</a> to define our main function <em>(sidenote, if you haven’t read GHC User’s Guide, please do, it’s the most authoritative and precise source of information about GHC features and extensions)</em>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="pp">#include </span><span class="im">&quot;HsFFI.h&quot;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="pp">#ifdef __GLASGOW_HASKELL__</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="pp">#include </span><span class="im">&quot;Entry_stub.h&quot;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="pp">#include </span><span class="im">&quot;Rts.h&quot;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> * argv[]) {</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  setcpus();</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  <span class="pp">#if __GLASGOW_HASKELL__ &gt;= 703</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  {</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">     RtsConfig conf = defaultRtsConfig;</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">     conf.rts_opts_enabled = RtsOptsAll;</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">     hs_init_ghc(&amp;argc, &amp;argv, conf);</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">  }</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">  <span class="pp">#else</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">     hs_init(&amp;argc, &amp;argv);</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  <span class="pp">#endif</span></a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  hs_init(&amp;argc, &amp;argv);</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">  entry();</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">  hs_exit();</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">}</a></code></pre></div>
<p>However, we have not done everything. If you try to compile this program and run it with <code>RTS +N</code> you’ll see expected logs but the program reports that you are using the number of capabilities equal to the number of virtual cores. It happens because with <code>RTS +N</code> GHC asks the number of configured processors and creates that number of capabilities. Instead of this we want the count of capabilities to be equal to the number of real cores. Furthermore, we don’t want to patch GHC just yet because our code is too hacky.</p>
<p><code>GHC RTS</code> is linked statically with each Haskell project. It means that we can use a linker to make RTS use our method instead of the one provided with <code>GHC</code>, we are interested in redefining <code>uint32_t getNumberOfProcessors(void)</code>. For that reason we use linker’s <a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_3.html">wrap feature</a>. If you tell linker <code>-Wl,-wrap, function</code> then for each call to the <code>function</code> it calls <code>__wrap_function</code> instead and generates <code>__real_function</code> that you can call to call the original function.</p>
<p>So we write</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="dt">static</span> <span class="dt">uint32_t</span> procno = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="dt">uint32_t</span> __real_getNumberOfProcessors(<span class="dt">void</span>);</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="dt">uint32_t</span> __wrap_getNumberOfProcessors(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">   <span class="cf">if</span> (procno==<span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      <span class="cf">return</span> __real_getNumberOfProcessors();</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">   } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">     <span class="cf">return</span> procno;</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">   }</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">}</a></code></pre></div>
<p>to get the desired result. We change cabal to provide required options to the build:</p>
<pre class="cabal"><code>  ghc-options:         -no-hs-main
                       -threaded
                       -optl-Wl,-wrap,getNumberOfProcessors</code></pre>
<p>You can find the full code on <a href="https://github.com/qnikst/haskell-fun/tree/master/ht-no-more">GitHub</a>. There is still much work for this project before you can use it for your application.</p>
<p>There is some further work which could be done:</p>
<ol type="1">
<li>The code could be cleaned and prettified;</li>
<li>The code could be made portable and be able to run on all OSes GHC can run on;</li>
<li>The current approach may be not sub-optimal, maybe it’s enough to redefine <code>getNumberOfProcessors</code> alone without calling <code>sched_setaffinity</code>.</li>
<li>I didn’t test the interference with other functions; for example, if you run a program with <code>-xm</code> flag (that pins capability to CPU) it may fail.</li>
<li>It’s possible to extend this solution and set better GC options based on CPU info</li>
<li>I’m curious if it is possible to write this program as a library and reuse in other projects.</li>
</ol>
<p>All feedback is welcome.</p>]]></summary>
</entry>
<entry>
    <title>Making personal environment and long live dotfiles</title>
    <link href="https://qnikst.github.io/posts/2018-08-22-long-live-dotfiles.html" />
    <id>https://qnikst.github.io/posts/2018-08-22-long-live-dotfiles.html</id>
    <published>2018-08-22T00:00:00Z</published>
    <updated>2018-08-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Some time ago I installed <a href="https://nixos.org/">NixOS</a>, and one thing that I had a problem with was understanding how to set up user environment. You can can configure NixOS declaratively with a description in a single file <code>/etc/nixos/configuration.nix</code>, but all applications set up there get installed system-wide. Instead, you usually want to have your user environment to be configured per your user. Also you may want to move your environment from one host to another (possibly to another distribution or even to another OS). Updating configuration.nix looks like a too heavy-weight solution for such a task.</p>
<p>Other solutions that I’ve seen were building of one’s own environment or using <a href="https://github.com/tldr-pages/tldr/blob/master/pages/common/nix-env.md">nix-env</a> for installing applications per user. I was not able to adopt the former solution, and the latter does not provide declarative config, and one may collect lots of garbage of applications she runs once. Besides, it would be nice to control dotfiles in the same style.</p>
<p>One day my colleague <a href="https://github.com/nmattia">Nicolas Mattia</a> suggested me to look at the tool he uses, called <a href="https://github.com/nmattia/homies">homies</a>, the one he had excellently described in his <a href="http://nmattia.com/posts/2018-03-21-nix-reproducible-setup-linux-macos.html">blog</a>. I think everyone should read and check that :). Unfortunately, this approach, at least up to my understanding should exist for each user, because it’s not customisable. So I’ve started my project <a href="https://github.com/qnikst/homster">homster</a> that is solving the same problem. Currently it’s primarily based on the <code>homies</code> though in the future it’s going to diverge.</p>
<p>The general structure of the project is as follows. There is a <code>default.nix</code> file that describes all the packages and the modified ones that I use. In each modified package I pass my config, or it’s configured to read system config from the nix package directory so I can configure common options in the homster project and update them on the host by usual means.</p>
<p>So it seems that I have found the solution to all my needs and I can have a declarative configuration for the user environment. I still can use <code>nix-env -i</code> for temporarily needed packages, but <code>nix-env -f homster/default.nix -i --remove-all</code> command updates and cleans my environment. Most of the dotfiles can be kept in the project. Also, I can set up my environment anywhere where I can install <code>nix</code> package manager.</p>
<p>While implementing this the most interesting problem was <code>git</code>. Git searches for its configuration in 3 places according to the man page:</p>
<ol type="1">
<li>system-wide: <code>(prefix)/gitconfig</code></li>
<li>user-wide: <code>$(HOME)/.gitconfig</code> or <code>$XDG_CONFIG_DIR/git/gitconfig</code></li>
<li>project-wide: <code>~/.git/config</code></li>
</ol>
<p>Besides, it takes <code>--config</code> option that overrides config search entirely. We can’t use <code>--config</code> because that overrides project specific options, we can’t update user-wide file with nix, so the only option left is the system-wide config. So we need to understand what is <code>(prefix)</code>. Man pages tell that it’s a value of the <code>PREFIX</code> environment option. Let’s check nixpkgs:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">    <span class="st">&quot;prefix=</span><span class="dt">\$</span><span class="st">{out}&quot;</span></a></code></pre></div>
<p>https://github.com/NixOS/nixpkgs/blob/54ba2c9afca07b0f14763b3697d00b637b2461e0/pkgs/applications/version-management/git-and-tools/git/default.nix#L86</p>
<p>It seems that nix installs that, but let us check it:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ex">strace</span> git config <span class="op">2&gt;&amp;1</span> <span class="kw">|</span> <span class="fu">grep</span> gitconfig</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ex">access</span>(<span class="st">&quot;/etc//gitconfig&quot;</span>, R_OK)         = <span class="ex">-1</span> ENOENT (No such file or directory)</a></code></pre></div>
<p>Seems not to be what we were expecting. The story continues, we need to understand where does git looks for a config. You can find it on GitHub (modulo the version that I’ve used, but it’s irrelevant for the code I’m interested in) <a href="https://github.com/git/git/blob/7e8bfb0412581daf8f3c89909f1d37844e8610dd/config.c#L1634-L1640" class="uri">https://github.com/git/git/blob/7e8bfb0412581daf8f3c89909f1d37844e8610dd/config.c#L1634-L1640</a></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="dt">const</span> <span class="dt">char</span> *git_etc_gitconfig(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">	<span class="dt">static</span> <span class="dt">const</span> <span class="dt">char</span> *system_wide;</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">	<span class="cf">if</span> (!system_wide)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">		system_wide = system_path(ETC_GITCONFIG);</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">	<span class="cf">return</span> system_wide;</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">}</a></code></pre></div>
<p>Okay, what is <code>ETC_GITCONFIG</code> <a href="https://github.com/git/git/blob/1f1cddd558b54bb0ce19c8ace353fd07b758510d/configure.ac#L387-L391" class="uri">https://github.com/git/git/blob/1f1cddd558b54bb0ce19c8ace353fd07b758510d/configure.ac#L387-L391</a></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ex">GIT_PARSE_WITH_SET_MAKE_VAR</span>(gitconfig, ETC_GITCONFIG,</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">			<span class="ex">Use</span> VALUE instead of /etc/gitconfig as the</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">			<span class="ex">global</span> git configuration file.</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">			<span class="ex">If</span> VALUE is not fully qualified it will be interpreted</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">			<span class="fu">as</span> a path relative to the computed prefix at runtime.)</a></code></pre></div>
<p>Finally, after searching what <code>GIT_PARSE_WITH_SET_MAKE_VAR</code> means, we can find that we need to pass <code>--with-gitconfig=name</code> as a parameter to the configure.</p>
<p>So now we need to patch nix package for <code>git</code> to do that. As usual, we want to make it declaratively and easy to change without redoing the work that NixOS maintainers already did like applying patches and packaging.</p>
<p>Everything described above can be done pretty quickly in <code>nix</code>, in my <code>homster/git/default.nix</code> I can override default package for git as:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ex">git.overrideAttrs</span> (old: {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">   <span class="ex">configureFlags</span> = [ <span class="st">&quot;--with-gitconfig=</span><span class="va">$out</span><span class="st">/etc/gitconfig ];</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="st">})</span></a></code></pre></div>
<p><code>nix</code> interprets the <code>$out</code> variable and substitutes exact hash there. Then we can copy our file to the right place and get a new system-wide configuration that is controlled by us.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ex">strace</span> git config <span class="op">2&gt;&amp;1</span> <span class="kw">|</span> <span class="fu">grep</span> gitconfig</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ex">access</span>(<span class="st">&quot;/nix/store/66hi8rssnvhlxbwjg3qkc4bcs76fp8np-git-2.16.4/etc/gitconfig&quot;</span>, R_OK) = <span class="ex">0</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ex">openat</span>(AT_FDCWD, <span class="st">&quot;/nix/store/66hi8rssnvhlxbwjg3qkc4bcs76fp8np-git-2.16.4/etc/gitconfig&quot;</span>, O_RDONLY) = <span class="ex">3</span></a></code></pre></div>
<p>exactly what is needed.</p>]]></summary>
</entry>
<entry>
    <title>simple chat server.</title>
    <link href="https://qnikst.github.io/posts/2018-05-05-irc-simple.html" />
    <id>https://qnikst.github.io/posts/2018-05-05-irc-simple.html</id>
    <published>2018-05-02T00:00:00Z</published>
    <updated>2018-05-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Few months ago one person asked me in twitter how is it possible to write anything in Haskell, and how can it help to write some low level application working with network.</p>
<p>As a result I’ve ended up with a simple non-complete <code>irc-simple</code> project. This project can’t be used as a real irc server in the real network. But it can be extended to support features. The main intent was to show how server could be written how to deal with communication, parsing, concurrency.</p>
<p>Unfortunately the project is documented in Russian, as it was written for the Russian non-haskell community. But if anyone would be interested in extending, translation or mistakes correction. That would be awesome.</p>
<p>Project itself can be found on:</p>
<p><a href="https://github.com/qnikst/irc-simple.git" class="uri">https://github.com/qnikst/irc-simple.git</a></p>]]></summary>
</entry>
<entry>
    <title>Cabal foreign libraries</title>
    <link href="https://qnikst.github.io/posts/2018-05-02-cabal-foreign-library.html" />
    <id>https://qnikst.github.io/posts/2018-05-02-cabal-foreign-library.html</id>
    <published>2018-05-02T00:00:00Z</published>
    <updated>2018-05-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In this age of the <code>stack</code> domination, not everyone remembers the role of <code>Cabal</code> and cabal-install`. And still cabal and cabal-install do progress and introduce new features, that may benefit entire ecosystem. And it’s quite unfortunate that some of the changes remain unnoticed.</p>
<p>The big list of changes in Cabal-2.0 can be found <a href="http://coldwa.st/e/blog/2017-09-09-Cabal-2-0.html">here</a>. In this post I’d like to look into one single change: <strong>Foreign libraries support</strong>.</p>
<p>TLDR: you can find all documentation in the cabal <a href="https://www.haskell.org/cabal/users-guide/developing-packages.html#foreign-libraries">user-guide</a>, which is a very good resource to read anyway.</p>
<p>Let’s look into the problem solved by this feature. Sometimes we need to use Haskell in projects written in other language. This can be done either by making an Haskell executable and using some RPC to communicate between different components or by making a shared object. For a long time cabal did not support shared objects definition. Common solution for that problem was to create an <code>executable</code> section in cabal file, add <code>ghc-options</code> <code>-shared</code> and then play games with <code>-fPIC</code> support. That solution was doable but painfull and required knowledge of low level details.</p>
<p>And finally in cabal-2.0 a support for that usecase was introduced. Now we have a new stanza, <code>foreign-library</code> which means that <code>Cabal</code> will build a standalone library to be used with foreign languages.</p>
<p>Inside <code>foreign-library</code> block we can define <code>type</code> of the library:</p>
<ul>
<li><code>native-static</code> for static library (<code>.a</code>);</li>
<li><code>native-shared</code> for the dynamic library (<code>.so</code>).</li>
</ul>
<p>Currently only <code>native-shared</code> are supported.</p>
<p>If you are using windows you should remember to add <code>options: standlone</code> stanza. With this option <code>libHSrts</code> will not be required. You should not set this option otherwise.</p>
<p>A simple example:</p>
<p><code>foreign.cabal</code>:</p>
<pre class="cabal"><code>foreign-library     mylib
  type:             native-shared
  lib-version-info: 6:3:2
  build-depends:    base &gt;=4.9 &amp;&amp; &lt;4.10
  hs-source-dirs:   src
  other-modules     Lib
  default-language: Haskell2010</code></pre>
<p>If you have foreign exported modules, then you should also provide:</p>
<pre class="cabal"><code>library
  build-depends: base &gt;= 4.9 &amp;&amp; &lt;4.10
  hs-source-dirs: src
  other-modules:  Lib
  install-includes: Lib_stub.h
  default-language: Haskell2010
</code></pre>
<p>We need <code>Lib_stub.h</code> so header file will be installed in the system. See <a href="https://github.com/haskell/cabal/issues/5299">#5299</a>. This workaround helps with the problem but still you will not be able to call <code>cabal sdist</code> because it will try to copy autogenerated file that does not exist in filesystem.</p>
<p><code>src/Lib.hs</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Lib</span> (fac) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">foreign export ccall<span class="ot"> fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">fac n <span class="fu">=</span> product [<span class="dv">1</span><span class="fu">..</span>n]</a></code></pre></div>
<p>After <code>cabal install</code> you’ll get:</p>
<pre><code>~/.cabal/
~//cabal/libmylib.so -&gt; libmylib.so.4.2.3
~/.cabal/libmylib.so.4 -&gt; libmylib.so.4.2.3
~/.cabal/libmylib.so.4.2.3
~/.cabal/lib/x86_64-linux-ghc-8.0.2/foreign-0.1.0.0-22cwmsmBVpIHoSDwDYFUR6/include/Lib_stub.h</code></pre>
<p>Enjoy!</p>
<p>Update: problem with <code>sdist</code> can be worked around by using a buildinfo trick</p>
<ol type="1">
<li><p>create <code>foreign.buildinfo</code> file with the following contents:</p>
<pre><code>   install-includes: Lib_stub.h</code></pre></li>
<li><p>add section to cabal:</p>
<pre><code>extra-tmp-files: foreign.buildinfo</code></pre></li>
<li><p>remove <code>install-includes</code> stanza - now sdist works.</p></li>
</ol>
<p>Enjoy again!</p>]]></summary>
</entry>
<entry>
    <title>Things to know about exception handling.</title>
    <link href="https://qnikst.github.io/posts/2015-06-03-interesting-exceptions.html" />
    <id>https://qnikst.github.io/posts/2015-06-03-interesting-exceptions.html</id>
    <published>2015-06-03T00:00:00Z</published>
    <updated>2015-06-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Let’s take a look at the simple pattern, in this pattern we want to write an endless program for some purpose:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">runit f <span class="fu">=</span> f <span class="ot">`onException`</span> (putStrLn <span class="st">&quot;exception!&quot;</span> <span class="fu">&gt;&gt;</span> runit f)</a></code></pre></div>
<p>Do you see a huge problem here? And this problem is not with code accuracy, inability to gracefully exit or something like that. There is another problem in this pattern. If you don’t then continue reading.</p>
<p>Assume <code>f</code> is some simple function that loops (for example <code>let f = forever yield</code>). Try to answer the following questions</p>
<ol type="1">
<li><p>what will happen if you run <code>runit f</code> in a separate thread (<code>forkIO $ runit f</code>)?</p></li>
<li><p>what will happen if you send an exception to the forked thread?</p></li>
<li><p>what will happen if you send another exception to that thread?</p></li>
</ol>
<p>Now you can try to check your guesses in ghci. If everything is ok then there is nothing new to read for you. However if you are lazy (and didn’t try to answer or run the code), you can continue.</p>
<p>Let’s try to test:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">&gt;</span> <span class="fu">:</span>m <span class="dt">Control.Exception</span> <span class="dt">Control.Concurrent</span> <span class="dt">GHC.Conc</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="fu">&gt;</span> <span class="kw">let</span> runit f <span class="fu">=</span> f <span class="ot">`onException`</span> (putStrLn <span class="st">&quot;exception!&quot;</span> <span class="fu">&gt;&gt;</span> runit f)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="fu">&gt;</span> x <span class="ot">&lt;-</span> forkIO <span class="fu">$</span> runit <span class="fu">$</span> forever yield</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="fu">&gt;</span> x</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="dt">ThreadId</span> <span class="dv">154</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="fu">&gt;</span> threadStatus x</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="dt">ThreadRunning</span></a></code></pre></div>
<p>Ok everything as expected, thread is running and consuming 100% of one CPU. Now go to the step 2.:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">&gt;</span> throwTo x (userError <span class="st">&quot;foo&quot;</span>)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">exc<span class="fu">&gt;</span> eption<span class="fu">!</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="fu">&gt;</span> threadStatus x</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="dt">ThreadRunning</span></a></code></pre></div>
<p>Exception is caught, everything is OK. Now go to the 3.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;</span> throwTo x (userError <span class="st">&quot;foo&quot;</span>)</a></code></pre></div>
<p>Hah.. It just hangs!!! We can interrupt it and check thread status</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;</span> threadStatus x</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="dt">ThreadRunning</span></a></code></pre></div>
<p>This is definitely not what could be expected. Lets try to understand what had happened.</p>
<p>As you know exception sending is synchronous in a sense, that <code>throwTo</code> call will not exit unless exception will be delivered to the thread (or the thread dies).</p>
<p>Quote from <a href="https://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Concurrent.html">haddock</a>:</p>
<blockquote>
<p>Exception delivery synchronizes between the source and target thread: <code>throwTo</code> does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</p>
</blockquote>
<p>It’s definitely not an issue of non-reaching safepoint, that is also possible. Another quote:</p>
<blockquote>
<p>In GHC, an exception can only be raised when a thread reaches a safe point, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a <code>throwTo</code>.</p>
</blockquote>
<p>It could be a case if <code>f</code> would be something like <code>f = return $ last [1..]</code> compiled with optimizations turned on. But as we have seen the first exception was delivered successfully. And also we are not in a <em>FFI</em> call. The only left possibility is that the thread is in a masked state. Let’s check it:</p>
<pre><code>&gt; x &lt;- forkIO $ runit (getMaskingState &gt;&gt;= print  &gt;&gt; forever yield)
Unmasked
Prelude Control.Exception Control.Concurrent GHC.Conc Control.Monad&gt; throwTo x (userError &quot;bar&quot;)
exceptiPrelude Control.Exception Control.Concurrent GHC.Conc Control.Monad&gt; on!
MaskedInterruptible</code></pre>
<p>Yes, everything happened as we were expecting the thread is now in a masked state, and so exception can’t be delivered. But why? Maybe we need to take a look at <code>Control.Exception</code> module documentation? You may try, but at least in base-4.8.0 (and in the previous versions) these details were not documented.</p>
<p>But we can try to find out solution somewhere else, for example in RTS documentation:</p>
<blockquote>
<p>A thread can request that asynchronous exceptions not be delivered (“masked”) for the duration of an I/O computation. The primitives</p>
<p>maskAsyncExceptions# :: IO a -&gt; IO a</p>
<p>and</p>
<p>maskUninterruptible# :: IO a -&gt; IO a</p>
<p>are used for this purpose. During a masked section, asynchronous exceptions may be unmasked again temporarily:</p>
<p>unmaskAsyncExceptions# :: IO a -&gt; IO a</p>
<p>Furthermore, asynchronous exceptions are masked automatically during the execution of an exception handler. All three of these primitives leave a continuation on the stack which reverts to the previous state (masked interruptible, masked non-interruptible, or unmasked) on exit.</p>
</blockquote>
<p>Looks like a reason of our problem. Unfortunatelly it’s not in the documentation that usual user would read, but a nice thing to know.</p>
<p>And original code should look like the following:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">runit f <span class="fu">=</span> mask <span class="fu">$</span> \release <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  ev <span class="ot">&lt;-</span> try <span class="fu">$</span> release f</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">case</span> ev <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="dt">Left</span> _ <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;exception&quot;</span> <span class="fu">&gt;&gt;</span> release (runit f)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    <span class="dt">Right</span> x <span class="ot">-&gt;</span> return x</a></code></pre></div>
<p>You’ll need to pass exception type you are interested in or use <code>catches</code>.</p>
<p>I hope you enjoyed reading this, despite a terrible English that I have.</p>]]></summary>
</entry>
<entry>
    <title>Logging all exceptions in ghci</title>
    <link href="https://qnikst.github.io/posts/2015-04-30-grabbing-exceptions.html" />
    <id>https://qnikst.github.io/posts/2015-04-30-grabbing-exceptions.html</id>
    <published>2015-04-30T00:00:00Z</published>
    <updated>2015-04-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>On one resource there was a question how to log all exception in GHCI. There was a use case where user could start a background processes and some exceptions could be lost.</p>
<p>In a normal program you can use <code>-prof</code> compilation option and run program with <code>+RTS -xc</code> in order to get exceptions messages and stack-traces logged. However I assume that most of the ghc users doesn’t have <code>ghc</code> compiled with profiling flags. So we need to find another option.</p>
<p>And there is a solution. Every forked thread installs a exceptions handler:</p>
<p>From <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Conc-Sync.html#forkIO">GHC.Cons.Sym</a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">forkIO ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">forkIO action <span class="fu">=</span> <span class="dt">IO</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">   <span class="kw">case</span> (fork<span class="fu">#</span> action_plus s) <span class="kw">of</span> (<span class="fu">#</span> s1, tid <span class="fu">#</span>) <span class="ot">-&gt;</span> (<span class="fu">#</span> s1, <span class="dt">ThreadId</span> tid <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">      action_plus <span class="fu">=</span> catchException action childHandler</a></code></pre></div>
<p>From <a href="">GHC.IO</a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">{-</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">catchException used to handle the passing around of the state to the</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co">action and the handler.  This turned out to be a bad idea - it meant</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="co">that we had to wrap both arguments in thunks so they could be entered</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co">as normal (remember IO returns an unboxed pair...).</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="co">Now catch# has type</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="co">catch# :: IO a -&gt; (b -&gt; IO a) -&gt; IO a</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="co">(well almost; the compiler doesn&#39;t know about the IO newtype so we</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="co">have to work around that in the definition of catchException below).</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="co">-}</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="ot">catchException ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a></code></pre></div>
<p>In order to set hander we can use:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">setUncaughtExceptionHandler ::</span> (<span class="dt">SomeException</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>In order to add something to ghci we can load a script by passing it with <code>-ghci-script</code> option</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">:</span>m <span class="dt">GHC.Conc.Sync</span> <span class="dt">Control.Exception</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="fu">:</span>{</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">let</span><span class="ot"> uncaughtExceptionHandler ::</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    uncaughtExceptionHandler e <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">        putStrLn <span class="fu">$</span> <span class="st">&quot;Unhandled exception: &quot;</span> <span class="fu">++</span> show e</a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="fu">:</span>}</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">setUncaughtExceptionHandler uncaughtExceptionHandler</a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="fu">:</span>m <span class="fu">-</span><span class="dt">GHC.Conc.Sync</span> <span class="dt">Control.Exception</span></a></code></pre></div>
<p>And load it with <code>ghci -ghci-script script.hs</code>.</p>
<pre><code>qnikst@localhost ~ $ ghci -ghci-script script.hs 
GHCi, version 7.8.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude&gt; :m +Control.Exception Control.Concurrent
Prelude Control.Exception Control.Concurrent&gt; forkIO $ threadDelay 10000 &gt;&gt; error &quot;yo!&quot;
ThreadId 28
Prelude Control.Exception Control.Concurrent&gt; Unhandled exception: yo!</code></pre>]]></summary>
</entry>

</feed>
