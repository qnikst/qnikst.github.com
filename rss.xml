<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - All posts</title>
    <link href="http://qnikst.github.com/rss.xml" rel="self" />
    <link href="http://qnikst.github.com" />
    <id>http://qnikst.github.com/rss.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2013-04-11T00:00:00Z</updated>
    <entry>
    <title>Using queues in conduits</title>
    <link href="http://qnikst.github.com/posts/2013-04-11-using-tqueues-in-conduit.html" />
    <id>http://qnikst.github.com/posts/2013-04-11-using-tqueues-in-conduit.html</id>
    <published>2013-04-11T00:00:00Z</published>
    <updated>2013-04-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Sometime when you use conduit you need to split processes for example when you have CPU bound and IO bound tasks thus you will have better workload. Also you may need to get events from different sources concurrently, and for such purposes you may want to use <a href="http://hackage.haskell.org/package/stm-conduit">stm-conduit</a> library.</p>
<p>This library provides conduits over STM primitives:</p>
<ul>
<li><a href="http://hackage.haskell.org/packages/archive/stm-chans/1.3.1/doc/html/Control-Concurrent-STM-TMChan.html#t:TMChan">TMChans</a> - closable (finite) STM channels</li>
<li><a href="http://hackage.haskell.org/packages/archive/stm-chans/1.3.1/doc/html/Control-Concurrent-STM-TBMChan.html#t:TBMChan">TBMChans</a> - closable (finite) bounded STM channels</li>
<li><a href="http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/Control-Concurrent-STM-TQueue.html#t:TQueue">TQueue</a> - infinite STM Queues</li>
<li><a href="http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/Control-Concurrent-STM-TBQueue.html#t:TBQueue">TBQueue</a> - infinite bounded STM Queues</li>
</ul>
<p>and closable queues comming soon.</p>
<p>Here closable means that you can close a primitives outside it, so source will report that it is closed on the opposite infinite primitive will wait for an input forever, so you should use another conduit to handle end of a stream or send an asynchronous exception.</p>
<p>Bounded means that there is a limit of pending messages inside primitive and if that limit is reached any thread that wants to write to the primitive will be blocked on input. This is basically what you need to guarantee limited (or even constant) memory usage.</p>
<p>New primitive TQueue was added in stm-2.3 and provides shared amortized queue that is faster than TChan/Chan but doesn’t provide dupTChan, cloneTChan primitives.</p>]]></summary>
</entry>
<entry>
    <title>Anouncing binary conduit</title>
    <link href="http://qnikst.github.com/posts/2013-04-07-announcing-binary-conduit.html" />
    <id>http://qnikst.github.com/posts/2013-04-07-announcing-binary-conduit.html</id>
    <published>2013-04-07T00:00:00Z</published>
    <updated>2013-04-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m happy to announce <a href="http://hackage.haskell.org/package/binary-conduit">binary-conduit</a> an library for <a href="http://hackage.haskell.org/package/conduit">conduit</a> streaming data library using <a href="http://hackage.haskell.org/package/binary">binary</a> package.</p>]]></summary>
</entry>
<entry>
    <title>Немного о gentoo-haskell</title>
    <link href="http://qnikst.github.com/posts/2013-03-31-gentoo-haskell.html" />
    <id>http://qnikst.github.com/posts/2013-03-31-gentoo-haskell.html</id>
    <published>2013-03-31T00:00:00Z</published>
    <updated>2013-03-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Как всем известно у haskell пакетов существует прекрасная система с сборки с центральным репозиторием, в котором хранятся пакеты, однако у этой проблемы существует ряд минусов:</p>
<ul>
<li>далеко не все пакеты собираются друг с другом даже если эти версии разрешены в cabal файле.</li>
<li>далеко не все пакеты протестированы</li>
<li>часть пакетов нацелены на работу под конкретной платформой и обновлять их до выхода следующей платформы не собираются</li>
<li>при обновлении пакета нужно пересобирать все обратные зависимости</li>
<li>в случае если нужны профилировочные библиотеки, то нужно пересобирать все зависимости с опциями профилировки.</li>
<li>полное отстуствие верификации исходников, которые вы качаете.</li>
</ul>
<p>Все эти пункты делают использование haskell не очень приятным, так же проблема усугубляется тем, что во многих дистрибутивах представлены устаревшие версии пакетов, за которыми не успевают следить (не верите, то можете посмотреть результаты <a href="https://docs.google.com/forms/d/1y5WtrCB7O9-jb-2Mzo1MtkToh4O6oY2oBXGkc_Q-cy0/viewanalytics">haskell survey</a> Обычным решением является использование cabal на пользовательном уровне, или сборка в песочницах. Но иногда бывают способы и лучше.</p>
<p>Естественно, каждый дистрибутив пытается по своему предложить решение проблем. В посте описана краткая инфрастурктура gentoo-linux и дополнительные пакеты сильно упрощающие работу с haskell, в целом пост может быть интересен, как пользователям Gentoo, так интересующимся пользователям других дистрибутивов, даже в том случае если не они не планируют переход или использование Gentoo Linux.</p>
<ol style="list-style-type: decimal">
<li><p>Gentoo работает под многими платформами: (alpha amd64 ia64 ppc ppc64 sparc x86) и под каждую есть поставка ghc и пакетов. Сам пакет ghc можно поставить в бинарном виде, в том случае, если его сборка слишком тяжела для хоста.</p></li>
<li><p>Для исправления зависимостей существует программа haskell-updater, которая находит все “поломанные” зависимости и пересобирает нужные пакеты. Не так давно для улучшения ситуации добавлен механизм подслотов (subslots) специальная форма зависимостей позволяющая указать, то что программа должна быть обновлена в случае обновления зависимости. В текущий момент этот метод не может решить все проблемы (и даже приводит к некоторым новым), то уже в скором времени подслоты будут <a href="https://bugs.gentoo.org/show_bug.cgi?id=449094">рекурсивными</a> и полностью решат проблему автоматического обновления зависимостей</p></li>
<li><p>Большая часть пакетов доступных на Hackage может быть установлена из оверлея gentoo-haskell. Это надет дополнительный слой, в котором можно провести дополнительные исправления, такие как фиксация зависимостей и добавление патчей, плюс с каждым пакетом ассоциирована хэш сумма, которая ползволяет автоматически проверять валидность скачанных исходников.</p></li>
</ol>
<p>В нашем проекте проводятся следующие политики:</p>
<ol style="list-style-type: decimal">
<li>в оверлее держится последняя версия пакета, и она патчится таким образом, чтобы она могла работать с последними версиями других пакетов. Для некоторых пакетов есть исключения по запросам от пользователей или в случае серьезного изменеия апи.</li>
<li>Во всех пакетах проверяется то, что тесты проходятся (если они есть).</li>
<li>сделаны утилиты для простого создания новых пакетов <em>действительно простого</em></li>
</ol>
<p>Таким образом в gentoo можно спокойно использовать haskell на системном уровне используя песочницы только в исключительных ситуациях.</p>
<p>Так же в дистрибутив входят допонительные полезные утилиты такие как hoogle с поддержкой локальной базы (т.е. всех установленных пакетов).</p>
<p>Если кому-то интересны подробности, шаги по быстрой установке или хочется рассказать, как в вашем дистрибутиве решаются подобные проблемы, то добро пожаловать в комментарии.</p>
<p>P.S. и важно, что gentoo можно поставить под любой вашей осью, данных механизм называется gentoo prefix, и подробности можно найти <a href="http://www.gentoo.org/proj/en/gentoo-alt/prefix/">тут</a>.</p>
<p>Полезные ссылки:</p>
<p>[1] Страница на gentoo wiki: <a href="">http://wiki.gentoo.org/wiki/Haskell</a></p>
<p>[2] Тематический блог: <a href="">http://gentoohaskell.wordpress.com/</a></p>
<p>[3] Haskell wiki: <a href="">http://www.haskell.org/haskellwiki/Gentoo</a></p>]]></summary>
</entry>
<entry>
    <title>Resourcet usage</title>
    <link href="http://qnikst.github.com/posts/2013-02-28-resourcet-usage.html" />
    <id>http://qnikst.github.com/posts/2013-02-28-resourcet-usage.html</id>
    <published>2013-02-28T00:00:00Z</published>
    <updated>2013-02-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post describes an interesting resourcet usecase that may be usefull due to the lack of liner-types support in haskell.</p>
<p>Lets look at the next problem. Assuming we have got a some sort of transaction mechanism that receives data and then perform transaction, but sometimes it may call callback to users code (originally it’s about <a href="http://github.com/qnikst/2pc">2pc</a> library).</p>
<p>So we have method:</p>
<pre><code>withWH0 :: (Binary b) -&gt; ByteString -&gt; (b -&gt; IO Bool) -&gt; IO ()
withWH0 = undefined</code></pre>
<p>Where Bool is result of transaction i.e. either we accept or decline transaction.</p>
<p>This variant is not good as callback is synchronous, we will not be able to run next transaction untill callback is finished. And it will be a bottleneck for the code.</p>
<p>There can be an interesting solution:</p>
<blockquote>
<p>one can provide an trasaction handler, i.e. a resource that for communication of the user code and library, this resource should be either accepted or declined. If that resource is ‘alive’ it means that user is working on transaction. If resource is not touched by user code a default action should be run, before resource will be cleared.</p>
</blockquote>
<p>The problem that we should somehow guarantee that user will free resource. One solution use linear types, but we don’t have them (or at least it’s too difficult for me and I don’t know how to do it). Another option is to use some kind of region library: one option is <a href="http://hackage.haskell.org/package/regions">regions</a> originaly proposed by <a href="http://okmij.org/ftp/Haskell/regions.html#light-weight">Oleg</a> but this package doesn’t work in recent ghc`s due some unsolved bugs, another option is <a href="http://hackage.haskell.org/package/resourcet">resourcet</a> package written by Michael Snoyman, this package doesn’t give so much guarantees as regions but at least it works. Resourcet package introduce ResourceT monad that forms a block where all resources that were registered in that blog will be closed as soon as compulation would left a block (there is an api for an early close but will not look at it now).</p>
<p>So we can guarantee that:</p>
<ol style="list-style-type: decimal">
<li>every resource registered in the block will be freed</li>
<li>resources freeing will be determinated in time/</li>
<li>resource will be freed only once (second call to release is noop)</li>
</ol>
<p>Here are minimal definition for what we need:</p>
<pre><code>data TH = TH -- ^ transaction handler

-- | accept transaction (send message via network)
accept = undefined  
-- | decline transaction (send message via network)
decline = undefined
-- | real release (synonym for decline)
thRelease = undefined

withWH1 d cb = runResourceT $ do
  let d&#39; = decode d
  th &lt;- accure create thRelease
  cb th d&#39;</code></pre>
<p>Now we create a ResourceT region, register resource there and then call user code, our code is not as safe as resourcet release as user can call accept more that once, so we need to check if it was called.</p>
<p>The best thing that now client can use <code>resourceForkIO</code> to make withWH1 asynchronous.</p>
<p>But there is another issue: how user can queue some part of the messages?</p>
<p>TBD make nice picture</p>
<p>There is a solution: <code>unprotect</code> function. This function allowes you to degerister resource in the current resourcet block and then register it in another block, or register new release action.</p>
<p>Currently resourcet package lacks helpers that allowes to move resource to some other place, so one need to create that functions himself. Here are some advices how one can do it safely.</p>
<p>You need a structure that has the following interface:</p>
<ul>
<li>put :: s -&gt; (a, IO ()) -&gt; m () – put resource into storage</li>
<li>get :: s -&gt; m (ReleaseKey a) – get resource and register it in current process</li>
</ul>
<p>Put and get should be atomic and mask exceptions, moreover if you can’t guarantee that message will be immidiatelly read by another process you should register datastructure in some higher level ResourceT block, this way you’ll guarantee that no resources will be left in store unfreed.</p>
<p>Here are some basic examples of such datastructures:</p>
<p>(this code is not well tested as I’ve used more complicated datastructure for such purpose, that have an additional API, but its not usefull for common case)</p>
<p>At first let’s write an <code>InstantMVar</code>, this structure allow you to send message into other process, where it will be immideatelly read, so we don’t need to store that structure in ‘global’ resource block</p>
<pre><code>data InstanceMVar a = InstanceMVar (MVar (a,IO ())) (MVar ())

newMVar = InstanceMVar &lt;$&gt; newEmptyMVar &lt;*&gt; newEmptyMVar

put (InstanceMVar a b) (key, x) = mask_ $ unprotect key &gt;&gt;= putMVar a . ((,) x) &gt;&gt; takeMVar b

get (InstanceMVar a b) = mask_ $ takeMVar a &gt;&gt;= \(x, r) -&gt; register r &gt;&gt; putMVar b () &gt;&gt; return x</code></pre>
<p>This code will guarantee that resource will be read, however it may lock.</p>
<p>Let’s write a <code>DelayedMVar</code> this structure will not block on write, but should be registered in global resourcet block</p>
<pre><code>newtype DelayedMVar a = DelayedMVar (MVar (a,IO ()))

newDelayedMVar = allocate (DelayedMVar &lt;$&gt; newEmptyMVar) (releaseDelayedMVar)

releaseDelayedMVar (DelayedMVar v) = maybe (return ()) (snd) =&lt;&lt; tryReadMVar v

put (DelayedMVar v) (key, x) = mask_ $ unprotect key &gt;&gt;= putMVar a . ((,) x)

get (DelayedMVar v) = mask_ $ takeMVar a &gt;&gt;= \(x, r) -&gt; register r &gt;&gt; return x</code></pre>
<p>Same way one can write Channel or STM Channel, however channel is not fully safe unless chan is closable.</p>
<pre><code>newtype SChan a = SChan (SChan (a,IO ()))

newSChan = allocate (SChan &lt;$&gt; newChan) releaseChan

releaseChan (ChanMVar v) = go =&lt;&lt; tryReadChan v
  where go Nothing = return ()
        go (Just (x,a)) = a &gt;&gt; tryReadChan v {- we have a possible race condition here -} &gt;&gt;= go</code></pre>
<p>There are many variants each with it’s own tradeoffs so one a free to build a way that matchs his task. But the next things should hold:</p>
<ol style="list-style-type: decimal">
<li>Datastructure should either guarantee that other side will read resource atomically or be registered in ResourceT monad</li>
<li>Read and writes should be exception safe</li>
</ol>]]></summary>
</entry>
<entry>
    <title>OpenRC Extended cgroups support</title>
    <link href="http://qnikst.github.com/posts/2013-02-20-openrc-cgroup.html" />
    <id>http://qnikst.github.com/posts/2013-02-20-openrc-cgroup.html</id>
    <published>2013-02-20T00:00:00Z</published>
    <updated>2013-02-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="openrc-has-extended-cgroups-support">Openrc has extended cgroups support</h1>
<p>Staring with openrc-0.12 (not released ATM) openrc supports cgroup limit configuration. The simpliest and most reasonable way to configure it is use a multiline per-process values:</p>
<p>At first I should note that openrc has optional cgroup support to add it you need to set:</p>
<pre><code>rc_controller_cgroups=&quot;YES&quot;</code></pre>
<p>Otherwise one of the option will be applied and openrc “plugin” will not be loaded. As always settings can be set in rc.conf file and can be overloaded in ‘/etc/conf.d/foo’ file for service foo.</p>
<p>Each option is specified by name of the limit and value. Each option may be a multivalue, e.g.</p>
<pre><code># rc_cgroup_cpu=&quot;
# cpu.shares 512
# &quot;</code></pre>
<p>For more information about the adjustments that can be made with cgroups, see <code>Documentation/cgroups/*</code> in the linux kernel source tree.</p>
<p>Currently next controllers are supported:</p>
<ul>
<li>blkio – block io controller</li>
<li>cpu – cpu controller</li>
<li>cpuacct – cpu accounting information</li>
<li>cpuset – extended cpu configuration</li>
<li>devices – devices access control</li>
<li>memory – memory management</li>
<li>net_prio – network priority options</li>
</ul>
<h3 id="why-do-i-ever-need-cgroups">Why do I ever need cgroups?</h3>
<p>You can check kernel documentation. But roughly speaking you can monitor service processes, and manage resources much better.</p>
<h3 id="differences-with-other-system-managers">Differences with other system managers</h3>
<p>There are some differences between how systemd works, systemd creates hierarchies for system daemons and users in each controller. Openrc uses it’s own cgroup to monitor daemons, and create a group called ‘openrc_<servicename>’ in controller that is configures.</p>
<p>So you can easily use other cgroup daemons like libcgroup with openrc without any problem</p>
<h2 id="future-work">Future work</h2>
<p>There are some work that can be done to make cgroup support better:</p>
<ul>
<li>configure controller merging</li>
<li>cgroup-cleanup, i.e. destroy all childs when stopping service (there are some pathes but they were not applied upstream). We will wait for the real use cases here</li>
<li>cgroup-watchdog, we can monitor if service is dead either by notify_agent (will not require any resources but will not restart service with childs alive) or by inotify (will require a watchdog service running but will have no such problems)</li>
<li>notify-agent callbacks, currently we use notify agent only on openrc cgroup and there is no callback, but it can be fixed</li>
<li>there is an abitify to make an api for freezer, but we’d wait for the real use case before implementing it.</li>
</ul>
<p>Usefull links:</p>
<ul>
<li><a href="https://access.redhat.com/knowledge/docs/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html">Red Hat manual</a></li>
<li><a href="http://www.kernel.org/doc/Documentation/cgroups/cgroups.txt">kernel documentation</a></li>
<li><a href="http://en.wikipedia.org/wiki/Cgroups">wiki</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Сохранение всех задач su- в свою cgroup.</title>
    <link href="http://qnikst.github.com/posts/2013-02-04-su-pam-cgroup-log.html" />
    <id>http://qnikst.github.com/posts/2013-02-04-su-pam-cgroup-log.html</id>
    <published>2013-02-04T00:00:00Z</published>
    <updated>2013-02-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Стоит задача: необходимо все программы запущенные через ‘su’ определить в собственные cgroups. Это можно сделать за три простые шага.</p>
<ol style="list-style-type: decimal">
<li>инициализируем нужную цгруппу, для этого нам нужна именованная группа, чтобы исключить пересечение с системными группами: (данный шаг желательно делегировать системе инициализации дистрибутива)</li>
</ol>
<pre class="shell"><code>  localhost qnikst # mkdir /sys/fs/cgroup/su-log
  localhost qnikst # mount -n -t cgroup -o none,nodev,noexec,nosuid,name=test test /sys/fs/cgroup/su-log</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Пишем простой баш скрипт: в этом сприпте мы создаём каталог для пользователя (если его нет и помещаем туда родительскую задачу (ту, пользуется средствами pam)</li>
</ol>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">localhost</span> qnikst <span class="co"># cat /usr/local/bin/pam_exec_test.sh </span>
<span class="co">#!/bin/sh</span>
<span class="ot">p=</span>/sys/fs/cgroup/su-log/<span class="ot">${PAM_RUSER}</span>
<span class="kw">[</span> <span class="ot">!</span> <span class="ot">-d</span> <span class="st">&quot;</span><span class="ot">${p}</span><span class="st">&quot;</span><span class="kw"> ]</span> <span class="kw">&amp;&amp;</span> <span class="kw">\</span>
   <span class="kw">mkdir</span> <span class="ot">${p}</span>
<span class="kw">echo</span> <span class="ot">${PPID}</span> <span class="kw">&gt;</span> <span class="st">&quot;</span><span class="ot">${p}</span><span class="st">&quot;</span>/tasks</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>пишем правило для pam.d (логи опциональны)</li>
</ol>
<pre><code>session    optional             pam_exec.so   log=/var/log/pam_test_su.log seteuid /usr/local/bin/pam_exec_test.sh</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>наслаждаемся результатом.</li>
</ol>
<p>В данном решении есть проблема: будучи суперпользователем пользователь может перемещать свои задачи по cgroup-ам, для решения этой проблемы нужно писать политику selinux запрещающую переносить задачи выше, чем cgroup породившего их процесса.</p>]]></summary>
</entry>
<entry>
    <title>Using mathjax latex formula with Pandoc-4</title>
    <link href="http://qnikst.github.com/posts/2013-02-04-hakyll-latex.html" />
    <id>http://qnikst.github.com/posts/2013-02-04-hakyll-latex.html</id>
    <published>2013-02-04T00:00:00Z</published>
    <updated>2013-02-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Recently I’ve checked a list of manuals for pandoc and latex, but they were quite outdated.</p>
<p>The problems that by default pandoc tries to use utf only to render formulas but it doesn’t work in many cases. Best solution would be <a href="http://www.mathjax.org/">mathjax</a> as it will work in majority of brousers unlike mathml.</p>
<p>To set up hakyll to use latex one needs to set pandoc compiler options:</p>
<pre><code>    -- ...
    compile \$ pandocCompilerWith defaultHakyllReaderOptions pandocOptions 
    -- ...

pandocOptions :: WriterOptions
pandocOptions = defaultHakyllWriterOptions{ writerHTMLMathMethod = MathJax &quot;&quot; }</code></pre>
<p>But you will have to add mathjax url to pages where you have math, and do nothing at pages without. So you can add a special marker to page header</p>
<pre><code>----
....
mathjax: on
---</code></pre>
<p>and then add a special context that will check marker it sill populate field mathjax with either script url or nothing</p>
<pre><code>mathCtx :: Context a
mathCtx = field &quot;mathjax&quot; $ \item -&gt; do
    metadata &lt;- getMetadata $ itemIdentifier item
    return $ if &quot;mathjax&quot; `M.member` metadata
                  then &quot;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\&quot;&gt;&lt;/script&gt;&quot;
                  else &quot;&quot;</code></pre>
<p>now you need to add $mathjax$ value to your tempate and add math context to your context (I’ve used default.html)</p>
<pre><code>&lt;head&gt;
    ...
    &lt;script src=&quot;/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
    $mathjax$
&lt;/head&gt;</code></pre>
<pre><code>  match &quot;posts/*&quot; $ do
      route $ setExtension &quot;.html&quot;
      compile $ pandocCompilerWith defaultHakyllReaderOptions pandocOptions 
         &gt;&gt;= saveSnapshot &quot;content&quot;
         &gt;&gt;= return . fmap demoteHeaders
         &gt;&gt;= loadAndApplyTemplate &quot;templates/post.html&quot; (postCtx tags)
         &gt;&gt;= loadAndApplyTemplate &quot;templates/default.html&quot; (mathCtx `mappend` defaultContext)
         &gt;&gt;= relativizeUrls</code></pre>
<p>that’s all</p>
<p>Example:</p>
<p><span class="math">\[M_1=\sqrt{\dfrac{(1-q_1)(1-q_2)}{2\beta_1(q_1-q_2)}}\,H_2^{1/4}\,,\qquad
M_2=\sqrt{\dfrac{(1+q_1)(1+q_2)}{2\beta_2(q_2-q_1)}}\,H_2^{1/4}\,,\]</span> and <span class="math">\[{\gamma}_3=\dfrac{2\varkappa H_2^{1/4}}{\sqrt{2(\beta_1-\beta_2)(q_2-q_1)}}\,.\]</span> Such as <span class="math">\(C_1=0\)</span> and <span class="math">\[\dot{q}_k=\{H,q_k\}=-\dfrac{4\beta_1p_2M_1(1+q_k)}{{\gamma}_3}-\dfrac{4\beta_2{\gamma}_1M_2(1-q_k)}{{\gamma}_3}\,,\]</span></p>]]></summary>
</entry>
<entry>
    <title>Формулы которые нужно знать</title>
    <link href="http://qnikst.github.com/posts/2013-02-01-phys-formulae.html" />
    <id>http://qnikst.github.com/posts/2013-02-01-phys-formulae.html</id>
    <published>2013-02-01T00:00:00Z</published>
    <updated>2013-02-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Список формул, которые мне желательно знать и уметь вспомнить/вывести будучи пробуженным посреди ночи</p>
<p>Уравнение теплопроводности:</p>
<p><span class="math">\[D_t F = D_{xx} F = f(x,t)\]</span></p>
<p>Уравнение Лапласа:</p>
<p><span class="math">\[\Delta f = 0\]</span></p>
<p>Уравнение Пуассона:</p>
<p><span class="math">\[\Delta f = g\]</span></p>
<p>Уравнение Геймгольца (эллептическое):</p>
<p><span class="math">\[(\Delta + k^2) u = f\]</span></p>
<p>Волновое уравнение (гиперболическое):</p>
<p><span class="math">\[\Delta u = \frac{1}{v^2} D_{tt} u\]</span></p>
<p>Уравнение Шрёдингера</p>
<p><span class="math">\[-i \hbar \frac{\partial \Psi}{\partial t} = H \Psi\]</span></p>
<p><span class="math">\[\Psi(x,t) = \Psi(x) \exp\left\{ \frac{-2\pi i E t}{h}\right\} \Rightarrow H\Psi = E\Psi\]</span></p>
<p>Задача Штурма-Лиувилля:</p>
<p><span class="math">\[\frac{d}{dx} \left( p(x) \frac{d}{dx} y \right) - q(x)y+\lambda\rho(x)y=0\]</span></p>
<p>Преобразование Лапласа:</p>
<p><span class="math">\[F(x) \equiv L\{f(t)\} = \int_0^{+\infty}e^{-ts}f(t)dt\]</span></p>]]></summary>
</entry>
<entry>
    <title>2013-01-20-automata</title>
    <link href="http://qnikst.github.com/posts/2013-01-20-automata.html" />
    <id>http://qnikst.github.com/posts/2013-01-20-automata.html</id>
    <published>2013-01-20T00:00:00Z</published>
    <updated>2013-01-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>About a half year ago I had a next task: I should run a list of event listeners on a wire and on each handled event that event listener can change (i.e. start listening another event, produce new event listeners, and send requests to the wire). Yes, sound like a FRP task, and once you are familar to FRP this article is not interested for you, except you may try to help me to generalize all logic.</p>
<p>I tried to use monadic approach, however I had too much problems because monads can bind and run opaque functions while all theese computation had to carry additional information, so I end up with function approach: each function returns a command and next function and special runner change it’s state based on this information but I ended with some problems: functions were bloated, function should be written from the end to begining, all additional variables should be passed explicitly through the functions, function can’t be composed as they had types constraints. It was a hell.. A day ago I have read the great arrows totorial http://ertes.de/new/tutorials/arrows.html by Ertugrul Söylemez, and realized that it was an arrow, after some thinking I’ve found a nice solution.</p>
<p>This is a literate haskell post so you can just copy it and compile.</p>
<p>We will need it at the very end to show arrow notation</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE Arrows #-}</span></code></pre>
<p>We need this for defining new arrow instance.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span> Prelude <span class="kw">hiding</span> ((.), id)
<span class="ot">&gt;</span> <span class="kw">import</span> Control.Arrow
<span class="ot">&gt;</span> <span class="kw">import</span> Control.Category</code></pre>
<p>We need this for describing outer world</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span> Control.Monad
<span class="ot">&gt;</span> <span class="kw">import</span> Control.Concurrent.STM
<span class="ot">&gt;</span> <span class="kw">import</span> Control.Concurrent
<span class="ot">&gt;</span> <span class="kw">import</span> Control.Exception</code></pre>
<p>Let’s prepare to solve our problem. At first we need to define an outer world bus i.e. an computation that can recieve requests, and sends responce. We define 2 channels for this purpose: input - requests, output - responce. This will not break generalization as you always can insert a channel based proxy between your computation and real-world bus.</p>
<p>So our realworld wrapper will look like:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; run ::</span> <span class="dt">FIO</span> a b c <span class="ot">-&gt;</span> <span class="dt">Generator</span> b c <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">&gt;</span> run f g i <span class="fu">=</span> 
<span class="ot">&gt;</span>   bracket (<span class="kw">do</span> in_  <span class="ot">&lt;-</span> newTChanIO 
<span class="ot">&gt;</span>               out_ <span class="ot">&lt;-</span> newTChanIO 
<span class="ot">&gt;</span>               t <span class="ot">&lt;-</span> forkIO <span class="fu">$</span> g in_ out_
<span class="ot">&gt;</span>               atomically <span class="fu">$</span> writeTChan in_ i
<span class="ot">&gt;</span>               <span class="fu">return</span> (t,in_,out_))
<span class="ot">&gt;</span>           (\(t, _, _) <span class="ot">-&gt;</span> killThread t)
<span class="ot">&gt;</span>           (\(_, i, o) <span class="ot">-&gt;</span> f i o)</code></pre>
<p>, where FIO and Generator are helper types:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">FIO</span> a b c <span class="fu">=</span> <span class="dt">TChan</span> b <span class="ot">-&gt;</span> <span class="dt">TChan</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Generator</span> b c <span class="fu">=</span> <span class="dt">TChan</span> b <span class="ot">-&gt;</span> <span class="dt">TChan</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre>
<p>A side node that we need to pass initial value as we use bus-driven logic: a message from the bus starts computaion.</p>
<p>Let’s write some generators:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; idGenerator ::</span> <span class="dt">Generator</span> a a
<span class="ot">&gt;</span> idGenerator <span class="fu">=</span> fGenerator <span class="fu">id</span>
<span class="ot">&gt; fGenerator ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Generator</span> b a
<span class="ot">&gt;</span> fGenerator f ic oc <span class="fu">=</span> forever <span class="fu">.</span> atomically <span class="fu">$</span> readTChan oc <span class="fu">&gt;&gt;=</span> writeTChan ic <span class="fu">.</span> f</code></pre>
<p>Now we can review our problem.</p>
<p>We need to define an finite automata, that can either finish it’s computation or return next state. Will write a type for it:</p>
<ol style="list-style-type: decimal">
<li>it will be a newtype (let’s name Auto 2) that has step function</li>
</ol>
<p>newtype Auto2 &lt;..&gt; = Auto2 { stepAuto :: &lt;..&gt; }</p>
<ol start="2" style="list-style-type: decimal">
<li>as it’s an automation it should get input value of type a and return either a new value b or new computation:</li>
</ol>
<p>newtype Auto2 &lt;..&gt; a b = Auto2 { stepAuto :: a -&gt; Either &lt;..&gt; b }</p>
<ol start="3" style="list-style-type: decimal">
<li>we need to carry information about real world bus through all computations and it can’t change</li>
</ol>
<p>newtype Auto2 i o a b = Auto2 {stepAuto :: a -&gt; Either (o, &lt;..&gt;) b}</p>
<ol start="4" style="list-style-type: decimal">
<li>final note is that if we return a new value request than our type is bound by RW-bus: Auto i o i b. So finally we get:</li>
</ol>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Auto2</span> i o a b <span class="fu">=</span> <span class="dt">Auto2</span> {<span class="ot"> stepAuto ::</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> (o, <span class="dt">Auto2</span> i o i b) b}</code></pre>
<p>[TBD: I need to add a nice pictures rendered in latex]</p>
<p>This is not a function, this is a computation, so we need to write explicit runner to make it work:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> runner auto i o <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     x <span class="ot">&lt;-</span> atomically <span class="fu">$</span> readTChan i
<span class="ot">&gt;</span>     <span class="fu">putStr</span> <span class="fu">$</span> <span class="st">&quot;input: &quot;</span><span class="fu">++</span>(<span class="fu">show</span> x) 
<span class="ot">&gt;</span>     <span class="kw">let</span> ret <span class="fu">=</span> stepAuto auto x
<span class="ot">&gt;</span>     <span class="kw">case</span> ret <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="kw">Left</span> (req, next) <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>           <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="st">&quot; requesting: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> req
<span class="ot">&gt;</span>           atomically (writeTChan o req)
<span class="ot">&gt;</span>           runner next i o
<span class="ot">&gt;</span>       <span class="kw">Right</span> ok <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (<span class="st">&quot; result: &quot;</span><span class="fu">++show</span> ok) <span class="fu">&gt;&gt;</span> <span class="fu">return</span> ok</code></pre>
<p>Will write a simple test function that require incremented value:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; upTo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Auto2</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> upTo n f <span class="fu">=</span> <span class="dt">Auto2</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="fu">&gt;=</span> n
<span class="ot">&gt;</span>                      <span class="kw">then</span> <span class="kw">Right</span> <span class="fu">$</span> f x
<span class="ot">&gt;</span>                      <span class="kw">else</span> <span class="kw">Left</span> ((x<span class="fu">+</span><span class="dv">1</span>),  upTo n f)</code></pre>
<p><em>Main&gt; run (runner (upTo 2 (</em>2))) (idGenerator) 0</p>
<p>Loading package array-0.4.0.1 … linking … done.</p>
<p>Loading package stm-2.4.2 … linking … done.</p>
<p>input: 0 requesting: 1</p>
<p>input: 1 requesting: 2</p>
<p>input: 2 result: 4</p>
<p>4</p>
<p>So far so good but, but I’d like not to write requests explicitly, rather to use some ‘request’ function that will break flow:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; request ::</span> o <span class="ot">-&gt;</span> <span class="dt">Auto2</span> i o a i
<span class="ot">&gt;</span> request req <span class="fu">=</span> <span class="dt">Auto2</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">Left</span> (req, <span class="dt">Auto2</span> <span class="fu">$</span> \y <span class="ot">-&gt;</span> <span class="kw">Right</span> y)</code></pre>
<p>*Main&gt; run (runner (request 5)) idGenerator 0</p>
<p>input: 0 requesting: 5</p>
<p>input: 5 result: 5</p>
<p>5</p>
<p>One thing is bad: we need an input to request a state, that input will be ignored, it seems that it’s not a problem and will never hit user, however I have no strong explanation.</p>
<p>Now we need a way to compose such computation, not a problem, because this is a Category, so we need just to write an instance:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Category</span> (<span class="dt">Auto2</span> i o) <span class="kw">where</span>
<span class="ot">&gt;</span>     <span class="fu">id</span> <span class="fu">=</span> <span class="dt">Auto2</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">Right</span> x
<span class="ot">&gt;</span>     auto2 <span class="fu">.</span> auto1 <span class="fu">=</span> <span class="dt">Auto2</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>               <span class="kw">let</span> out1 <span class="fu">=</span> stepAuto auto1 x
<span class="ot">&gt;</span>               <span class="kw">in</span> <span class="kw">case</span> out1 <span class="kw">of</span>
<span class="ot">&gt;</span>                   <span class="kw">Right</span> b <span class="ot">-&gt;</span> stepAuto auto2 b
<span class="ot">&gt;</span>                   <span class="kw">Left</span> (o,auto1&#39;) <span class="ot">-&gt;</span> <span class="kw">Left</span> (o, (auto2 <span class="fu">.</span> auto1&#39;))</code></pre>
<p>id will just return a result and have no effects. Composition will run internal computation and if it’s succeed start outer, otherwise continue to run new inner automata untill it succeeds.</p>
<p>At this point we doesn’t gain many advantages as we have only composition of automata, and will have a problems once we will leave the types pipeline.</p>
<p>Now we’ll define an arrow instance so we will be able to lift opaque functions to the Automata level and create a side channels to carry values alongside with computation:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="dt">Auto2</span> i o) <span class="kw">where</span>
<span class="ot">&gt;</span>     arr f <span class="fu">=</span> <span class="dt">Auto2</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">Right</span> (f x)
<span class="ot">&gt;</span>     first (<span class="dt">Auto2</span> f) <span class="fu">=</span> <span class="dt">Auto2</span> <span class="fu">$</span> \(x, y) <span class="ot">-&gt;</span> 
<span class="ot">&gt;</span>         <span class="kw">let</span> next <span class="fu">=</span> f x
<span class="ot">&gt;</span>         <span class="kw">in</span> <span class="kw">case</span> next <span class="kw">of</span>
<span class="ot">&gt;</span>             <span class="kw">Right</span> b <span class="ot">-&gt;</span> <span class="kw">Right</span> (b, y)
<span class="ot">&gt;</span>             <span class="kw">Left</span>  a <span class="ot">-&gt;</span> arec (\z <span class="ot">-&gt;</span> (z,y)) a
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> arec g (o, <span class="dt">Auto2</span> f) <span class="fu">=</span> <span class="kw">Left</span> <span class="fu">$</span> 
<span class="ot">&gt;</span>          (o, <span class="dt">Auto2</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>               <span class="kw">let</span> next <span class="fu">=</span> f x
<span class="ot">&gt;</span>               <span class="kw">in</span> <span class="kw">case</span> next <span class="kw">of</span>
<span class="ot">&gt;</span>                   <span class="kw">Right</span> b <span class="ot">-&gt;</span> <span class="kw">Right</span> (g b)
<span class="ot">&gt;</span>                   <span class="kw">Left</span> y  <span class="ot">-&gt;</span> arec g y)</code></pre>
<p>Arrow instance just lift a pure function to Automata level, and first run recursive automata and store result in the first box. This is great we can just compose our computation in a straight forward way saving a results alongside a computation</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> test1 <span class="fu">=</span> request <span class="dv">5</span> <span class="fu">&gt;&gt;&gt;</span>
<span class="ot">&gt;</span>         arr (\x <span class="ot">-&gt;</span> (x,x)) <span class="fu">&gt;&gt;&gt;</span>
<span class="ot">&gt;</span>         first (request <span class="dv">6</span>) <span class="fu">&gt;&gt;&gt;</span>
<span class="ot">&gt;</span>         arr (\(x,y) <span class="ot">-&gt;</span> x<span class="fu">+</span>y)</code></pre>
<p>*Main&gt; run (runner (test1)) (idGenerator 0)</p>
<p>input: 0 requesting: 5</p>
<p>input: 5 requesting: 6</p>
<p>input: 6 result: 11</p>
<p>11</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> test2 <span class="fu">=</span> arr (\x <span class="ot">-&gt;</span> ((),x)) <span class="fu">&gt;&gt;&gt;</span>
<span class="ot">&gt;</span>         first (request <span class="dv">4</span>)  <span class="fu">&gt;&gt;&gt;</span>
<span class="ot">&gt;</span>         arr (\(x,y) <span class="ot">-&gt;</span> <span class="kw">if</span> y<span class="fu">&gt;</span><span class="dv">5</span> <span class="kw">then</span> x<span class="fu">+</span>y <span class="kw">else</span> x<span class="fu">-</span>y)</code></pre>
<p>*Main&gt; run (runner (test2)) idGenerator 6</p>
<p>input: 6 requesting: 4</p>
<p>input: 4 result: 10</p>
<p>10</p>
<p>*Main&gt; run (runner (test2)) idGenerator 4</p>
<p>input: 4 requesting: 4</p>
<p>input: 4 result: 0</p>
<p>0</p>
<p>As I said ‘request’ is not a problem as we can feed it with our internal value. Maybe we need to use Void there..</p>
<p>But that’s not all we want to be able to choise between computations</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">ArrowChoice</span> (<span class="dt">Auto2</span> i o) <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="co">-- left :: a b c -&gt; a (Either b d) (Either c d)</span>
<span class="ot">&gt;</span>   left (<span class="dt">Auto2</span> f) <span class="fu">=</span> <span class="dt">Auto2</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">case</span> x <span class="kw">of</span>
<span class="ot">&gt;</span>           <span class="kw">Left</span> b <span class="ot">-&gt;</span> <span class="kw">let</span> next <span class="fu">=</span> f b
<span class="ot">&gt;</span>                     <span class="kw">in</span> <span class="kw">case</span> next <span class="kw">of</span>
<span class="ot">&gt;</span>                         <span class="kw">Right</span> c <span class="ot">-&gt;</span> <span class="kw">Right</span> (<span class="kw">Left</span> c)
<span class="ot">&gt;</span>                         <span class="kw">Left</span> l <span class="ot">-&gt;</span> arec <span class="kw">Left</span> l
<span class="ot">&gt;</span>           <span class="kw">Right</span> d <span class="ot">-&gt;</span> <span class="kw">Right</span> (<span class="kw">Right</span> d)
<span class="ot">&gt;</span>   </code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; test3 ::</span> <span class="dt">Auto2</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> test3 <span class="fu">=</span> arr (\y <span class="ot">-&gt;</span> <span class="kw">if</span> y <span class="fu">&gt;</span> <span class="dv">5</span> <span class="kw">then</span> <span class="kw">Left</span> y <span class="kw">else</span> <span class="kw">Right</span> y) <span class="fu">&gt;&gt;&gt;</span>
<span class="ot">&gt;</span>         left (request <span class="dv">3</span>) <span class="fu">&gt;&gt;&gt;</span>
<span class="ot">&gt;</span>         right (request <span class="dv">7</span>) <span class="fu">&gt;&gt;&gt;</span>
<span class="ot">&gt;</span>         arr (\x <span class="ot">-&gt;</span> <span class="kw">case</span> x <span class="kw">of</span>
<span class="ot">&gt;</span>                 <span class="kw">Left</span> x  <span class="ot">-&gt;</span> x
<span class="ot">&gt;</span>                 <span class="kw">Right</span> y <span class="ot">-&gt;</span> y)</code></pre>
<p>*Main&gt; run (runner (test3)) idGenerator 1</p>
<p>input: 1 requesting: 7</p>
<p>input: 7 result: 7</p>
<p>7</p>
<p>*Main&gt; run (runner (test3)) idGenerator 6</p>
<p>input: 6 requesting: 3</p>
<p>input: 3 result: 3</p>
<p>3</p>
<p>The only problem that it’s not very easy to write in such a style, thats what an arrow notation is done for:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> 
<span class="ot">&gt;</span> test4 <span class="fu">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     <span class="kw">if</span> x <span class="fu">&gt;</span> <span class="dv">5</span> 
<span class="ot">&gt;</span>         <span class="kw">then</span> request <span class="dv">0</span> <span class="fu">-&lt;</span> () 
<span class="ot">&gt;</span>         <span class="kw">else</span> request <span class="dv">10</span> <span class="fu">-&lt;</span> ()</code></pre>
<p>*Main&gt; run (runner (test4)) idGenerator 6</p>
<p>input: 6 requesting: 0</p>
<p>input: 0 result: 0</p>
<p>0</p>
<p>*Main&gt; run (runner (test4)) idGenerator 1</p>
<p>input: 1 requesting: 10</p>
<p>input: 10 result: 10</p>
<p>10</p>
<p>Thats all, and thats really awesome: no more explicit function carrying, explicit RW-bus communication that implicilty coupled with all control flow.</p>
<p>At the end I should note, that this is not all functionallity that was in my module, so I’m brifly name what is not present here and how to add it:</p>
<ol style="list-style-type: decimal">
<li><p>There is only one event listener. To fix it one just need to add a state to the runner that state should save all listeners, feed them input and collect output. It can be done in parallel (explicitly via forkIO/channels or implicilty via par)</p></li>
<li><p>Listener can’t produce new listeners, it’s just a problem of outer type, it can be changed to o’ = (o, [Auto2]), where fst is result and Auto2 is new listeners.</p></li>
<li><p>Listener can send only once command at a time - can be fixed by changing o to [o’].</p></li>
<li><p>Listeners handle any event, there are two options: one write a wrapper that will validate any input and either return an unchanged automata with null request or all automatas should be tagged by their receive type and stored in a map.</p></li>
</ol>
<p>One big note this is just a learning matherial, if you want to do real world, start reading Ertugrul Söylemez and others about FRP.</p>
<p>Help required:</p>
<ul>
<li><p>if you see any mistake feel free to correct me</p></li>
<li><p>I don’t know how to correctly show a executed code blocks it lhs, if you know</p></li>
</ul>]]></summary>
</entry>
<entry>
    <title>announcing imagemagick-hs</title>
    <link href="http://qnikst.github.com/posts/2013-01-19-announcing-imagemagick.html" />
    <id>http://qnikst.github.com/posts/2013-01-19-announcing-imagemagick.html</id>
    <published>2013-01-19T00:00:00Z</published>
    <updated>2013-01-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m happy to announce new <a href="http://hackage.haskell.org/package/imagemagick">haskell binding library to imagemagick</a>.</p>
<p>This library is similar to some other bindings. It has some good points:</p>
<ol style="list-style-type: decimal">
<li><p>it has friendly and helpfull maintainers, that willing to help it’s users</p></li>
<li><p>it’s as safe as possible [1]</p></li>
<li><p>it has basics for functional interfaces</p></li>
<li><p>it has MagickWand interface</p></li>
<li><p>it has built-in examples</p></li>
</ol>
<p>But not everything is good:</p>
<ol style="list-style-type: decimal">
<li><p>we have not ported all API. Really it’s not a problem once you can reqyest adding new functionallity or fix pull-request it =).</p></li>
<li><p>it has known bugs and most of them related to imagemagick itself. I’m ready to investigate further if you will have problems with it.</p></li>
<li><p>it has no haddock documentation. Sorry.. I always had troubles with documentation</p></li>
<li><p>it uses modern version of imagemagick so it may lack some enum definitions. I’d like to find a safe way to use only defined enum values.</p></li>
</ol>
<p>About status and future of library:</p>
<p>I had some cool plans for this bindings such as make full imagemagick API support and provide a functional/declarative inteface but unfortunatelly I have no time for this library. So all functionality will be added on demand, i.e. if you lack some features feel free to request it or pull-request.</p>
<p>[1] library using resourcet for controlling external resources lifetime and scope, it’s not as safe as it could be possible with regions but unlucky regions regions are not working with recent GHC.</p>]]></summary>
</entry>

</feed>
