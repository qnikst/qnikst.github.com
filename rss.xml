<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - All posts</title>
    <link href="http://qnikst.github.com/rss.xml" rel="self" />
    <link href="http://qnikst.github.com" />
    <id>http://qnikst.github.com/rss.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2013-08-23T00:00:00Z</updated>
    <entry>
    <title>Adding license notes to blog pages.</title>
    <link href="http://qnikst.github.com/posts/2013-08-23-licenses-notes-in-hakyll.html" />
    <id>http://qnikst.github.com/posts/2013-08-23-licenses-notes-in-hakyll.html</id>
    <published>2013-08-23T00:00:00Z</published>
    <updated>2013-08-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve finally manged to create configurable license notes for each article:</p>
<p>To do it you need to add additional context:</p>
<pre><code>licenseCtx :: Context a
licenseCtx = field &quot;license&quot; $ \item -&gt; do
    metadata &lt;- getMetadata $ itemIdentifier item
    return $ case M.lookup &quot;license&quot; metadata of
                    Nothing -&gt; &quot;&quot;
                    Just m -&gt; case M.lookup (trim m) licenses of
                                      Nothing -&gt; &quot;unknown license&quot;
                                      Just (u,i) -&gt; &quot;&lt;a href=\&quot;&quot;++u++&quot;\&quot;&gt;&lt;img src=\&quot;&quot;++i++&quot;\&quot;/&gt;&lt;/a&gt;&quot;
  where
    trim = reverse . dropWhile isSpace . reverse . dropWhile isSpace


licenses = m.fromlist 
    [ (&quot;by&quot;,       ( &quot;http://creativecommons.org/licenses/by/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by/3.0/88x31.png&quot;))
    , (&quot;by-sa&quot;,    ( &quot;http://creativecommons.org/licenses/by-sa/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by-sa/3.0/88x31.png&quot;))
    , (&quot;by-nd&quot;,    ( &quot;http://creativecommons.org/licenses/by/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by/3.0/88x31.png&quot;))
    , (&quot;by-nc&quot;,    ( &quot;http://creativecommons.org/licenses/by/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by/3.0/88x31.png&quot;))
    , (&quot;by-nc-sa&quot;, ( &quot;http://creativecommons.org/licenses/by-nc-sa/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png&quot;))
    , (&quot;by-nc-nd&quot;, ( &quot;http://creativecommons.org/licenses/by-nc-nd/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png&quot;))]</code></pre>
<p>Currently only cc-* licenses are added, and but it will be possible to add nother licenses.</p>
<p>To apply license to template just add <code>$license$</code> and add context:</p>
<pre><code>  loadAndApplyTemplate &quot;templates/post.html&quot; (licenseCtx &lt;&gt; postCtx tags)</code></pre>
<p>For my blog I’m trying to use:</p>
<ul>
<li>by - for announces and physics</li>
<li>by-nc-sa - for documentation like posts</li>
<li>by-nc-nd - for personal posts</li>
</ul>]]></summary>
</entry>
<entry>
    <title>Supervision in pure OpenRC using cgroup subsystem.</title>
    <link href="http://qnikst.github.com/posts/2013-08-08-openrc-supervision-using-cgroups.html" />
    <id>http://qnikst.github.com/posts/2013-08-08-openrc-supervision-using-cgroups.html</id>
    <published>2013-08-08T00:00:00Z</published>
    <updated>2013-08-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div style="float:right;width:200px;font-size:0.5em;">
  
Updates:
<ul>
      <li> 
2008.08.09 - small corrections, acknowledgement section added
</li>
    </ul>
  
Versions:
<ul>
      <li> 
Kernel &gt;=2.6.24 &amp;&amp; &lt;=3.10
</li>
      <li> 
Openrc 0.12
</li>
    </ul>
</div>

<h1 id="abstract">Abstract</h1>
<p>This post describes how it’s possible to improve cgroup support in OpenRC to support user hooks, and shows how to create a basic supervision daemon based on cgroups.</p>
<p>This post describes OpenRC-0.11/0.12_beta and some things may change in later versions. Please notify me to post updates here if you find such changes.</p>
<h1 id="introduction">Introduction</h1>
<h2 id="the-problem">The problem</h2>
<p>In a general case, there are many services that should be run and restarted when they fail. There are many other subproblems like when should we restart services and when not. Many existing systems can solve those issues but have different trade-offs. In this post I’ll try to present a simple mechanism that allows to create basic supervision and other nice things.</p>
<h2 id="idea">Idea</h2>
<p>The Linux kernel provides a mechanism to track groups of processes - <code>Cgroups</code>. All process children will put in the process’s cgroup. And it’s easy to track cgroups from user space. If you want to understand cgroups better you may read <a href="https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt">cgroups documentation</a>. Cgroups provide a way of setting limits and controlling groups, that is also useful but at this moment it’s out of the scope.</p>
<p>When all processes in a group die, kernel will call ‘release_notify_agent’ script, proving the path to the cgroup. This may be used to remove empty cgroups and take additional actions.</p>
<p>Idea is that we can check service state to decide if we should restart it.</p>
<h1 id="details">Details</h1>
<h2 id="implementation">Implementation</h2>
<p>Here are improvements and files that should be added to OpenRC to provide the required functionality.</p>
<h3 id="restart-daemon">Restart daemon</h3>
<p>First we need to create a daemon to restart a services, because we can’t start service from agent, as it has <code>PF_NO_SETAFFINITY</code> flag and thus cgroups will not work for any of its children. So let’s have a very simple daemon, it will be extended in the next posts</p>
<pre><code> #!/bin/sh
 if [ $# -lt 1 ] ; then
    echo &quot;usage is $0 &lt;path to fifo&gt;&quot; 
    exit 1
 fi
 
 while [ -p $1 ] ; do 
    while read line ; do
       echo &quot;rc-service $line&quot;;
    done &lt;$1
 done</code></pre>
<h3 id="release-notify-agent-improvement">Release notify agent improvement</h3>
<p>The current release notify agent is very simple; so we extend it to support user hooks. There are some different ways to do it:</p>
<ol style="list-style-type: decimal">
<li>Add it to the service state. (Requires hook in the init script)</li>
<li>Create static structure in a filesystem</li>
</ol>
<p>We will use 2. as it’s simpler and doesn’t lead to a init script hacking. We will have following file structure:</p>
<p>In /etc/conf.d/cgroups there will be hooks, ‘cgroup-release’ for default one ‘service-name.cgroup-release’ for service specific one. Here is my example.</p>
<pre><code>/etc/conf.d/cgroups/
|-- cgroup-release                                            # default release hook
|-- foo.cgroup-release -&gt; service-restart.cgroup-release      # service release hook
`-- service-restart.cgroup-release                            # example script
</code></pre>
<p>This approach doesn’t scale on a multiple hooks but it may be improved after discussion with upstream. Each script can return $RC_CGROUP_CONTINUE exit code, so cgroup will not be deleted after a hook.</p>
<p>Here is a script itself (newer version can be found on <a href="https://github.com/qnikst/openrc/blob/cgroups.release_notification/sh/cgroup-release-agent.sh.in">github</a>):</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="ot">PATH=</span>/bin:/usr/bin:/sbin:/usr/sbin
<span class="ot">cgroup=</span>/sys/fs/cgroup/openrc
<span class="ot">cgroup_rmdir=</span>1
<span class="ot">RC_SVCNAME=$1</span>
<span class="ot">RC_CGROUP_CONTINUE=</span>3; 
<span class="kw">export</span> <span class="ot">RC_CGROUP_CONTINUE</span> <span class="ot">RC_SVCNAME</span> <span class="ot">PATH</span>;

<span class="kw">if [</span> <span class="ot">-n</span> <span class="st">&quot;</span><span class="ot">${RC_SVCNAME}</span><span class="st">&quot;</span><span class="kw"> ]</span> ; <span class="kw">then</span>
  <span class="ot">hook=</span>@SYSCONFDIR@/conf.d/cgroups/<span class="ot">${RC_SVCNAME}</span>.cgroup-release
 <span class="kw"> [</span> <span class="ot">-x</span> <span class="st">&quot;</span><span class="ot">$hook</span><span class="st">&quot;</span><span class="kw"> ]</span> <span class="kw">||</span> <span class="ot">hook=</span>@SYSCONFDIR@/conf.d/cgroups/cgroup-release;
  <span class="kw">if [</span> <span class="ot">-x</span> <span class="st">&quot;</span><span class="ot">$hook</span><span class="st">&quot;</span><span class="kw"> ]</span>; <span class="kw">then</span>
    <span class="st">&quot;</span><span class="ot">$hook</span><span class="st">&quot;</span> <span class="kw">cleanup</span> <span class="st">&quot;</span><span class="ot">$RC_SVCNAME</span><span class="st">&quot;</span> <span class="kw">||</span> <span class="kw">case</span> <span class="ot">$?</span><span class="kw"> in</span> <span class="ot">$RC_CGROUP_CONTINUE</span><span class="kw">)</span> <span class="ot">cgroup_rmdir=</span>0<span class="kw">;;</span> <span class="kw">esac</span> ;
  <span class="kw">fi</span>
<span class="kw">fi</span>

<span class="kw">if [</span> <span class="ot">${cgroup_rmdir}</span> <span class="ot">-eq</span> 1<span class="kw"> ]</span> <span class="kw">&amp;&amp; [</span> <span class="ot">-d</span> <span class="st">&quot;</span><span class="ot">${cgroup}</span><span class="st">/</span><span class="ot">$1</span><span class="st">&quot;</span><span class="kw"> ]</span>; <span class="kw">then</span>
  <span class="kw">for</span> <span class="kw">c</span> in /sys/fs/cgroup/*/<span class="st">&quot;openrc_</span><span class="ot">$1</span><span class="st">&quot;</span> <span class="kw">;</span> <span class="kw">do</span>
    <span class="kw">rmdir</span> <span class="st">&quot;</span><span class="ot">${c}</span><span class="st">&quot;</span>
  <span class="kw">done</span>;
  <span class="kw">rmdir</span> <span class="st">&quot;</span><span class="ot">$cgroup</span><span class="st">/</span><span class="ot">${1}</span><span class="st">&quot;</span>
<span class="kw">fi</span></code></pre>
<p>Restart service script. This script simply checks service state and if it’s 32 (service failed) then start a new instance and set <code>$RC_CGROUP_CONTINUE</code></p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#!/bin/sh</span>
<span class="co"># This script is run for service that need to be restarted</span>
<span class="co"># if it&#39;s last process leaves cgroup.</span>

<span class="ot">action=$1</span>
<span class="ot">service=$2</span>

<span class="kw">if [</span> cleanup <span class="ot">=</span> <span class="st">&quot;</span><span class="ot">$action</span><span class="st">&quot;</span><span class="kw"> ]</span> ; <span class="kw">then</span>

    <span class="kw">rc-service</span> <span class="ot">$service</span> status <span class="kw">&gt;</span> /dev/null
    <span class="kw">case</span> <span class="ot">$?</span><span class="kw"> in</span>
        32<span class="kw">)</span> 
        <span class="kw">/etc/init.d/</span><span class="ot">${service}</span> <span class="kw">-d</span> restart
        <span class="kw">exit</span> <span class="ot">$RC_CGROUP_CONTINUE</span>
                <span class="kw">;;</span>
        *<span class="kw">)</span> 
            <span class="kw">return</span> 0<span class="kw">;;</span>
    <span class="kw">esac</span>
<span class="kw">fi</span></code></pre>
<h2 id="other-solutions">Other solutions</h2>
<p>Generic supervision is quite a complicated problem as there are many conditions when we may suppose that our service failed, like:</p>
<ul>
<li>main process dies;</li>
<li>all service children die;</li>
<li>service does not write logs for some time;</li>
<li>large resource memory/cpu consuming;</li>
<li>service does not respond to control call;</li>
<li>log fd is closed.</li>
</ul>
<p>Some of the options can be translated to another, like large resource consuming can be translated to process death by setting correct limits. And process death (and in some cases even children deaths) can be tracked by log fd (in case of a process in background).</p>
<p>More complex hooks may be also needed, when deciding what to do with failed service, e.g. do not restart if it has failed many times in a short period of time.</p>
<p>So with all required features will be very complicated. So non-specialized subsystems address only a part of a problem domain. Here are some other examples of supervision systems:</p>
<ul>
<li>monit (full featured)</li>
<li>s6 (pid, fd based)</li>
<li>daemon-tools</li>
<li>angel</li>
<li>systemd (pid, cgroups based)</li>
<li>upstart (pid based)</li>
</ul>
<h1 id="future-work">Future work</h1>
<ol style="list-style-type: decimal">
<li>work on inclusion of a user hooks to OpenRC release agent.</li>
<li>improve restart script to track really dead services that can be restarted</li>
</ol>
<h1 id="conclusions-and-futher-work">Conclusions and futher work</h1>
<p>It’s possible to create a very simple and extensible supervision system based on OpenRC, by extending notification systems. Also there are more usecases for it, like:</p>
<ul>
<li>adding system wide notification mechanism via dbus</li>
<li>additional logging system</li>
</ul>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>I want to thank igli for code corrections and usefull tips, and Kirill Zaborsky for correcting lingual mistakes.</p>]]></summary>
</entry>
<entry>
    <title>Using queues in conduits</title>
    <link href="http://qnikst.github.com/posts/2013-04-11-using-tqueues-in-conduit.html" />
    <id>http://qnikst.github.com/posts/2013-04-11-using-tqueues-in-conduit.html</id>
    <published>2013-04-11T00:00:00Z</published>
    <updated>2013-04-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Sometime when you use conduit you need to split processes for example when you have CPU bound and IO bound tasks thus you will have better workload. Also you may need to get events from different sources concurrently, and for such purposes you may want to use <a href="http://hackage.haskell.org/package/stm-conduit">stm-conduit</a> library.</p>
<p>This library provides conduits over STM primitives:</p>
<ul>
<li><a href="http://hackage.haskell.org/packages/archive/stm-chans/1.3.1/doc/html/Control-Concurrent-STM-TMChan.html#t:TMChan">TMChans</a> - closable (finite) STM channels</li>
<li><a href="http://hackage.haskell.org/packages/archive/stm-chans/1.3.1/doc/html/Control-Concurrent-STM-TBMChan.html#t:TBMChan">TBMChans</a> - closable (finite) bounded STM channels</li>
<li><a href="http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/Control-Concurrent-STM-TQueue.html#t:TQueue">TQueue</a> - infinite STM Queues</li>
<li><a href="http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/Control-Concurrent-STM-TBQueue.html#t:TBQueue">TBQueue</a> - infinite bounded STM Queues</li>
</ul>
<p>and closable queues comming soon.</p>
<p>Here closable means that you can close a primitives outside it, so source will report that it is closed on the opposite infinite primitive will wait for an input forever, so you should use another conduit to handle end of a stream or send an asynchronous exception.</p>
<p>Bounded means that there is a limit of pending messages inside primitive and if that limit is reached any thread that wants to write to the primitive will be blocked on input. This is basically what you need to guarantee limited (or even constant) memory usage.</p>
<p>New primitive TQueue was added in stm-2.3 and provides shared amortized queue that is faster than TChan/Chan but doesn’t provide dupTChan, cloneTChan primitives.</p>]]></summary>
</entry>
<entry>
    <title>Anouncing binary conduit</title>
    <link href="http://qnikst.github.com/posts/2013-04-07-announcing-binary-conduit.html" />
    <id>http://qnikst.github.com/posts/2013-04-07-announcing-binary-conduit.html</id>
    <published>2013-04-07T00:00:00Z</published>
    <updated>2013-04-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m happy to announce <a href="http://hackage.haskell.org/package/binary-conduit">binary-conduit</a> an library for <a href="http://hackage.haskell.org/package/conduit">conduit</a> streaming data library using <a href="http://hackage.haskell.org/package/binary">binary</a> package.</p>]]></summary>
</entry>
<entry>
    <title>Немного о gentoo-haskell</title>
    <link href="http://qnikst.github.com/posts/2013-03-31-gentoo-haskell.html" />
    <id>http://qnikst.github.com/posts/2013-03-31-gentoo-haskell.html</id>
    <published>2013-03-31T00:00:00Z</published>
    <updated>2013-03-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Как всем известно у haskell пакетов существует прекрасная система с сборки с центральным репозиторием, в котором хранятся пакеты, однако у этой проблемы существует ряд минусов:</p>
<ul>
<li>далеко не все пакеты собираются друг с другом даже если эти версии разрешены в cabal файле.</li>
<li>далеко не все пакеты протестированы</li>
<li>часть пакетов нацелены на работу под конкретной платформой и обновлять их до выхода следующей платформы не собираются</li>
<li>при обновлении пакета нужно пересобирать все обратные зависимости</li>
<li>в случае если нужны профилировочные библиотеки, то нужно пересобирать все зависимости с опциями профилировки.</li>
<li>полное отстуствие верификации исходников, которые вы качаете.</li>
</ul>
<p>Все эти пункты делают использование haskell не очень приятным, так же проблема усугубляется тем, что во многих дистрибутивах представлены устаревшие версии пакетов, за которыми не успевают следить (не верите, то можете посмотреть результаты <a href="https://docs.google.com/forms/d/1y5WtrCB7O9-jb-2Mzo1MtkToh4O6oY2oBXGkc_Q-cy0/viewanalytics">haskell survey</a> Обычным решением является использование cabal на пользовательном уровне, или сборка в песочницах. Но иногда бывают способы и лучше.</p>
<p>Естественно, каждый дистрибутив пытается по своему предложить решение проблем. В посте описана краткая инфрастурктура gentoo-linux и дополнительные пакеты сильно упрощающие работу с haskell, в целом пост может быть интересен, как пользователям Gentoo, так интересующимся пользователям других дистрибутивов, даже в том случае если не они не планируют переход или использование Gentoo Linux.</p>
<ol style="list-style-type: decimal">
<li><p>Gentoo работает под многими платформами: (alpha amd64 ia64 ppc ppc64 sparc x86) и под каждую есть поставка ghc и пакетов. Сам пакет ghc можно поставить в бинарном виде, в том случае, если его сборка слишком тяжела для хоста.</p></li>
<li><p>Для исправления зависимостей существует программа haskell-updater, которая находит все “поломанные” зависимости и пересобирает нужные пакеты. Не так давно для улучшения ситуации добавлен механизм подслотов (subslots) специальная форма зависимостей позволяющая указать, то что программа должна быть обновлена в случае обновления зависимости. В текущий момент этот метод не может решить все проблемы (и даже приводит к некоторым новым), то уже в скором времени подслоты будут <a href="https://bugs.gentoo.org/show_bug.cgi?id=449094">рекурсивными</a> и полностью решат проблему автоматического обновления зависимостей</p></li>
<li><p>Большая часть пакетов доступных на Hackage может быть установлена из оверлея gentoo-haskell. Это надет дополнительный слой, в котором можно провести дополнительные исправления, такие как фиксация зависимостей и добавление патчей, плюс с каждым пакетом ассоциирована хэш сумма, которая ползволяет автоматически проверять валидность скачанных исходников.</p></li>
</ol>
<p>В нашем проекте проводятся следующие политики:</p>
<ol style="list-style-type: decimal">
<li>в оверлее держится последняя версия пакета, и она патчится таким образом, чтобы она могла работать с последними версиями других пакетов. Для некоторых пакетов есть исключения по запросам от пользователей или в случае серьезного изменеия апи.</li>
<li>Во всех пакетах проверяется то, что тесты проходятся (если они есть).</li>
<li>сделаны утилиты для простого создания новых пакетов <em>действительно простого</em></li>
</ol>
<p>Таким образом в gentoo можно спокойно использовать haskell на системном уровне используя песочницы только в исключительных ситуациях.</p>
<p>Так же в дистрибутив входят допонительные полезные утилиты такие как hoogle с поддержкой локальной базы (т.е. всех установленных пакетов).</p>
<p>Если кому-то интересны подробности, шаги по быстрой установке или хочется рассказать, как в вашем дистрибутиве решаются подобные проблемы, то добро пожаловать в комментарии.</p>
<p>P.S. и важно, что gentoo можно поставить под любой вашей осью, данных механизм называется gentoo prefix, и подробности можно найти <a href="http://www.gentoo.org/proj/en/gentoo-alt/prefix/">тут</a>.</p>
<p>Полезные ссылки:</p>
<p>[1] Страница на gentoo wiki: <a href="">http://wiki.gentoo.org/wiki/Haskell</a></p>
<p>[2] Тематический блог: <a href="">http://gentoohaskell.wordpress.com/</a></p>
<p>[3] Haskell wiki: <a href="">http://www.haskell.org/haskellwiki/Gentoo</a></p>]]></summary>
</entry>
<entry>
    <title>Resourcet usage</title>
    <link href="http://qnikst.github.com/posts/2013-02-28-resourcet-usage.html" />
    <id>http://qnikst.github.com/posts/2013-02-28-resourcet-usage.html</id>
    <published>2013-02-28T00:00:00Z</published>
    <updated>2013-02-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post describes an interesting resourcet usecase that may be usefull due to the lack of liner-types support in haskell.</p>
<p>Lets look at the next problem. Assuming we have got a some sort of transaction mechanism that receives data and then perform transaction, but sometimes it may call callback to users code (originally it’s about <a href="http://github.com/qnikst/2pc">2pc</a> library).</p>
<p>So we have method:</p>
<pre><code>withWH0 :: (Binary b) -&gt; ByteString -&gt; (b -&gt; IO Bool) -&gt; IO ()
withWH0 = undefined</code></pre>
<p>Where Bool is result of transaction i.e. either we accept or decline transaction.</p>
<p>This variant is not good as callback is synchronous, we will not be able to run next transaction untill callback is finished. And it will be a bottleneck for the code.</p>
<p>There can be an interesting solution:</p>
<blockquote>
<p>one can provide an trasaction handler, i.e. a resource that for communication of the user code and library, this resource should be either accepted or declined. If that resource is ‘alive’ it means that user is working on transaction. If resource is not touched by user code a default action should be run, before resource will be cleared.</p>
</blockquote>
<p>The problem that we should somehow guarantee that user will free resource. One solution use linear types, but we don’t have them (or at least it’s too difficult for me and I don’t know how to do it). Another option is to use some kind of region library: one option is <a href="http://hackage.haskell.org/package/regions">regions</a> originaly proposed by <a href="http://okmij.org/ftp/Haskell/regions.html#light-weight">Oleg</a> but this package doesn’t work in recent ghc`s due some unsolved bugs, another option is <a href="http://hackage.haskell.org/package/resourcet">resourcet</a> package written by Michael Snoyman, this package doesn’t give so much guarantees as regions but at least it works. Resourcet package introduce ResourceT monad that forms a block where all resources that were registered in that blog will be closed as soon as compulation would left a block (there is an api for an early close but will not look at it now).</p>
<p>So we can guarantee that:</p>
<ol style="list-style-type: decimal">
<li>every resource registered in the block will be freed</li>
<li>resources freeing will be determinated in time/</li>
<li>resource will be freed only once (second call to release is noop)</li>
</ol>
<p>Here are minimal definition for what we need:</p>
<pre><code>data TH = TH -- ^ transaction handler

-- | accept transaction (send message via network)
accept = undefined  
-- | decline transaction (send message via network)
decline = undefined
-- | real release (synonym for decline)
thRelease = undefined

withWH1 d cb = runResourceT $ do
  let d&#39; = decode d
  th &lt;- accure create thRelease
  cb th d&#39;</code></pre>
<p>Now we create a ResourceT region, register resource there and then call user code, our code is not as safe as resourcet release as user can call accept more that once, so we need to check if it was called.</p>
<p>The best thing that now client can use <code>resourceForkIO</code> to make withWH1 asynchronous.</p>
<p>But there is another issue: how user can queue some part of the messages?</p>
<p>TBD make nice picture</p>
<p>There is a solution: <code>unprotect</code> function. This function allowes you to degerister resource in the current resourcet block and then register it in another block, or register new release action.</p>
<p>Currently resourcet package lacks helpers that allowes to move resource to some other place, so one need to create that functions himself. Here are some advices how one can do it safely.</p>
<p>You need a structure that has the following interface:</p>
<ul>
<li>put :: s -&gt; (a, IO ()) -&gt; m () – put resource into storage</li>
<li>get :: s -&gt; m (ReleaseKey a) – get resource and register it in current process</li>
</ul>
<p>Put and get should be atomic and mask exceptions, moreover if you can’t guarantee that message will be immidiatelly read by another process you should register datastructure in some higher level ResourceT block, this way you’ll guarantee that no resources will be left in store unfreed.</p>
<p>Here are some basic examples of such datastructures:</p>
<p>(this code is not well tested as I’ve used more complicated datastructure for such purpose, that have an additional API, but its not usefull for common case)</p>
<p>At first let’s write an <code>InstantMVar</code>, this structure allow you to send message into other process, where it will be immideatelly read, so we don’t need to store that structure in ‘global’ resource block</p>
<pre><code>data InstanceMVar a = InstanceMVar (MVar (a,IO ())) (MVar ())

newMVar = InstanceMVar &lt;$&gt; newEmptyMVar &lt;*&gt; newEmptyMVar

put (InstanceMVar a b) (key, x) = mask_ $ unprotect key &gt;&gt;= putMVar a . ((,) x) &gt;&gt; takeMVar b

get (InstanceMVar a b) = mask_ $ takeMVar a &gt;&gt;= \(x, r) -&gt; register r &gt;&gt; putMVar b () &gt;&gt; return x</code></pre>
<p>This code will guarantee that resource will be read, however it may lock.</p>
<p>Let’s write a <code>DelayedMVar</code> this structure will not block on write, but should be registered in global resourcet block</p>
<pre><code>newtype DelayedMVar a = DelayedMVar (MVar (a,IO ()))

newDelayedMVar = allocate (DelayedMVar &lt;$&gt; newEmptyMVar) (releaseDelayedMVar)

releaseDelayedMVar (DelayedMVar v) = maybe (return ()) (snd) =&lt;&lt; tryReadMVar v

put (DelayedMVar v) (key, x) = mask_ $ unprotect key &gt;&gt;= putMVar a . ((,) x)

get (DelayedMVar v) = mask_ $ takeMVar a &gt;&gt;= \(x, r) -&gt; register r &gt;&gt; return x</code></pre>
<p>Same way one can write Channel or STM Channel, however channel is not fully safe unless chan is closable.</p>
<pre><code>newtype SChan a = SChan (SChan (a,IO ()))

newSChan = allocate (SChan &lt;$&gt; newChan) releaseChan

releaseChan (ChanMVar v) = go =&lt;&lt; tryReadChan v
  where go Nothing = return ()
        go (Just (x,a)) = a &gt;&gt; tryReadChan v {- we have a possible race condition here -} &gt;&gt;= go</code></pre>
<p>There are many variants each with it’s own tradeoffs so one a free to build a way that matchs his task. But the next things should hold:</p>
<ol style="list-style-type: decimal">
<li>Datastructure should either guarantee that other side will read resource atomically or be registered in ResourceT monad</li>
<li>Read and writes should be exception safe</li>
</ol>]]></summary>
</entry>
<entry>
    <title>OpenRC Extended cgroups support</title>
    <link href="http://qnikst.github.com/posts/2013-02-20-openrc-cgroup.html" />
    <id>http://qnikst.github.com/posts/2013-02-20-openrc-cgroup.html</id>
    <published>2013-02-20T00:00:00Z</published>
    <updated>2013-02-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="openrc-has-extended-cgroups-support">Openrc has extended cgroups support</h1>
<p>Staring with openrc-0.12 (not released ATM) openrc supports cgroup limit configuration. The simpliest and most reasonable way to configure it is use a multiline per-process values:</p>
<p>At first I should note that openrc has optional cgroup support to add it you need to set:</p>
<pre><code>rc_controller_cgroups=&quot;YES&quot;</code></pre>
<p>Otherwise one of the option will be applied and openrc “plugin” will not be loaded. As always settings can be set in rc.conf file and can be overloaded in ‘/etc/conf.d/foo’ file for service foo.</p>
<p>Each option is specified by name of the limit and value. Each option may be a multivalue, e.g.</p>
<pre><code># rc_cgroup_cpu=&quot;
# cpu.shares 512
# &quot;</code></pre>
<p>For more information about the adjustments that can be made with cgroups, see <code>Documentation/cgroups/*</code> in the linux kernel source tree.</p>
<p>Currently next controllers are supported:</p>
<ul>
<li>blkio – block io controller</li>
<li>cpu – cpu controller</li>
<li>cpuacct – cpu accounting information</li>
<li>cpuset – extended cpu configuration</li>
<li>devices – devices access control</li>
<li>memory – memory management</li>
<li>net_prio – network priority options</li>
</ul>
<h3 id="why-do-i-ever-need-cgroups">Why do I ever need cgroups?</h3>
<p>You can check kernel documentation. But roughly speaking you can monitor service processes, and manage resources much better.</p>
<h3 id="differences-with-other-system-managers">Differences with other system managers</h3>
<p>There are some differences between how systemd works, systemd creates hierarchies for system daemons and users in each controller. Openrc uses it’s own cgroup to monitor daemons, and create a group called ‘openrc_<servicename>’ in controller that is configures.</p>
<p>So you can easily use other cgroup daemons like libcgroup with openrc without any problem</p>
<h2 id="future-work">Future work</h2>
<p>There are some work that can be done to make cgroup support better:</p>
<ul>
<li>configure controller merging</li>
<li>cgroup-cleanup, i.e. destroy all childs when stopping service (there are some pathes but they were not applied upstream). We will wait for the real use cases here</li>
<li>cgroup-watchdog, we can monitor if service is dead either by notify_agent (will not require any resources but will not restart service with childs alive) or by inotify (will require a watchdog service running but will have no such problems)</li>
<li>notify-agent callbacks, currently we use notify agent only on openrc cgroup and there is no callback, but it can be fixed</li>
<li>there is an abitify to make an api for freezer, but we’d wait for the real use case before implementing it.</li>
</ul>
<p>Usefull links:</p>
<ul>
<li><a href="https://access.redhat.com/knowledge/docs/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html">Red Hat manual</a></li>
<li><a href="http://www.kernel.org/doc/Documentation/cgroups/cgroups.txt">kernel documentation</a></li>
<li><a href="http://en.wikipedia.org/wiki/Cgroups">wiki</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Сохранение всех задач su- в свою cgroup.</title>
    <link href="http://qnikst.github.com/posts/2013-02-04-su-pam-cgroup-log.html" />
    <id>http://qnikst.github.com/posts/2013-02-04-su-pam-cgroup-log.html</id>
    <published>2013-02-04T00:00:00Z</published>
    <updated>2013-02-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Стоит задача: необходимо все программы запущенные через ‘su’ определить в собственные cgroups. Это можно сделать за три простые шага.</p>
<ol style="list-style-type: decimal">
<li>инициализируем нужную цгруппу, для этого нам нужна именованная группа, чтобы исключить пересечение с системными группами: (данный шаг желательно делегировать системе инициализации дистрибутива)</li>
</ol>
<pre class="shell"><code>  localhost qnikst # mkdir /sys/fs/cgroup/su-log
  localhost qnikst # mount -n -t cgroup -o none,nodev,noexec,nosuid,name=test test /sys/fs/cgroup/su-log</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Пишем простой баш скрипт: в этом сприпте мы создаём каталог для пользователя (если его нет и помещаем туда родительскую задачу (ту, пользуется средствами pam)</li>
</ol>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">localhost</span> qnikst <span class="co"># cat /usr/local/bin/pam_exec_test.sh </span>
<span class="co">#!/bin/sh</span>
<span class="ot">p=</span>/sys/fs/cgroup/su-log/<span class="ot">${PAM_RUSER}</span>
<span class="kw">[</span> <span class="ot">!</span> <span class="ot">-d</span> <span class="st">&quot;</span><span class="ot">${p}</span><span class="st">&quot;</span><span class="kw"> ]</span> <span class="kw">&amp;&amp;</span> <span class="kw">\</span>
   <span class="kw">mkdir</span> <span class="ot">${p}</span>
<span class="kw">echo</span> <span class="ot">${PPID}</span> <span class="kw">&gt;</span> <span class="st">&quot;</span><span class="ot">${p}</span><span class="st">&quot;</span>/tasks</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>пишем правило для pam.d (логи опциональны)</li>
</ol>
<pre><code>session    optional             pam_exec.so   log=/var/log/pam_test_su.log seteuid /usr/local/bin/pam_exec_test.sh</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>наслаждаемся результатом.</li>
</ol>
<p>В данном решении есть проблема: будучи суперпользователем пользователь может перемещать свои задачи по cgroup-ам, для решения этой проблемы нужно писать политику selinux запрещающую переносить задачи выше, чем cgroup породившего их процесса.</p>]]></summary>
</entry>
<entry>
    <title>Using mathjax latex formula with Hakyll-4</title>
    <link href="http://qnikst.github.com/posts/2013-02-04-hakyll-latex.html" />
    <id>http://qnikst.github.com/posts/2013-02-04-hakyll-latex.html</id>
    <published>2013-02-04T00:00:00Z</published>
    <updated>2013-02-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Recently I’ve checked a list of manuals for pandoc and latex, but they were quite outdated.</p>
<p>The problems that by default pandoc tries to use utf only to render formulas but it doesn’t work in many cases. Best solution would be <a href="http://www.mathjax.org/">mathjax</a> as it will work in majority of brousers unlike mathml.</p>
<p>To set up hakyll to use latex one needs to set pandoc compiler options:</p>
<pre><code>    -- ...
    compile \$ pandocCompilerWith defaultHakyllReaderOptions pandocOptions 
    -- ...

pandocOptions :: WriterOptions
pandocOptions = defaultHakyllWriterOptions{ writerHTMLMathMethod = MathJax &quot;&quot; }</code></pre>
<p>But you will have to add mathjax url to pages where you have math, and do nothing at pages without. So you can add a special marker to page header</p>
<pre><code>----
....
mathjax: on
---</code></pre>
<p>and then add a special context that will check marker it sill populate field mathjax with either script url or nothing</p>
<pre><code>mathCtx :: Context a
mathCtx = field &quot;mathjax&quot; $ \item -&gt; do
    metadata &lt;- getMetadata $ itemIdentifier item
    return $ if &quot;mathjax&quot; `M.member` metadata
                  then &quot;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\&quot;&gt;&lt;/script&gt;&quot;
                  else &quot;&quot;</code></pre>
<p>now you need to add $mathjax$ value to your tempate and add math context to your context (I’ve used default.html)</p>
<pre><code>&lt;head&gt;
    ...
    &lt;script src=&quot;/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
    $mathjax$
&lt;/head&gt;</code></pre>
<pre><code>  match &quot;posts/*&quot; $ do
      route $ setExtension &quot;.html&quot;
      compile $ pandocCompilerWith defaultHakyllReaderOptions pandocOptions 
         &gt;&gt;= saveSnapshot &quot;content&quot;
         &gt;&gt;= return . fmap demoteHeaders
         &gt;&gt;= loadAndApplyTemplate &quot;templates/post.html&quot; (postCtx tags)
         &gt;&gt;= loadAndApplyTemplate &quot;templates/default.html&quot; (mathCtx `mappend` defaultContext)
         &gt;&gt;= relativizeUrls</code></pre>
<p>that’s all</p>
<p>Example:</p>
<p><span class="math">\[M_1=\sqrt{\dfrac{(1-q_1)(1-q_2)}{2\beta_1(q_1-q_2)}}\,H_2^{1/4}\,,\qquad
M_2=\sqrt{\dfrac{(1+q_1)(1+q_2)}{2\beta_2(q_2-q_1)}}\,H_2^{1/4}\,,\]</span> and <span class="math">\[{\gamma}_3=\dfrac{2\varkappa H_2^{1/4}}{\sqrt{2(\beta_1-\beta_2)(q_2-q_1)}}\,.\]</span> Such as <span class="math">\(C_1=0\)</span> and <span class="math">\[\dot{q}_k=\{H,q_k\}=-\dfrac{4\beta_1p_2M_1(1+q_k)}{{\gamma}_3}-\dfrac{4\beta_2{\gamma}_1M_2(1-q_k)}{{\gamma}_3}\,,\]</span></p>]]></summary>
</entry>
<entry>
    <title>Формулы которые нужно знать</title>
    <link href="http://qnikst.github.com/posts/2013-02-01-phys-formulae.html" />
    <id>http://qnikst.github.com/posts/2013-02-01-phys-formulae.html</id>
    <published>2013-02-01T00:00:00Z</published>
    <updated>2013-02-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Список формул, которые мне желательно знать и уметь вспомнить/вывести будучи пробуженным посреди ночи</p>
<p>Уравнение теплопроводности:</p>
<p><span class="math">\[D_t F = D_{xx} F = f(x,t)\]</span></p>
<p>Уравнение Лапласа:</p>
<p><span class="math">\[\Delta f = 0\]</span></p>
<p>Уравнение Пуассона:</p>
<p><span class="math">\[\Delta f = g\]</span></p>
<p>Уравнение Геймгольца (эллептическое):</p>
<p><span class="math">\[(\Delta + k^2) u = f\]</span></p>
<p>Волновое уравнение (гиперболическое):</p>
<p><span class="math">\[\Delta u = \frac{1}{v^2} D_{tt} u\]</span></p>
<p>Уравнение Шрёдингера</p>
<p><span class="math">\[-i \hbar \frac{\partial \Psi}{\partial t} = H \Psi\]</span></p>
<p><span class="math">\[\Psi(x,t) = \Psi(x) \exp\left\{ \frac{-2\pi i E t}{h}\right\} \Rightarrow H\Psi = E\Psi\]</span></p>
<p>Задача Штурма-Лиувилля:</p>
<p><span class="math">\[\frac{d}{dx} \left( p(x) \frac{d}{dx} y \right) - q(x)y+\lambda\rho(x)y=0\]</span></p>
<p>Преобразование Лапласа:</p>
<p><span class="math">\[F(x) \equiv L\{f(t)\} = \int_0^{+\infty}e^{-ts}f(t)dt\]</span></p>]]></summary>
</entry>

</feed>
