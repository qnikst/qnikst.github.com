<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - All posts</title>
    <link href="http://qnikst.github.com/rss.xml" rel="self" />
    <link href="http://qnikst.github.com" />
    <id>http://qnikst.github.com/rss.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2014-08-12T00:00:00Z</updated>
    <entry>
    <title>Formal Power series in haskell</title>
    <link href="http://qnikst.github.com/posts/2014-08-11-series.markdown.html" />
    <id>http://qnikst.github.com/posts/2014-08-11-series.markdown.html</id>
    <published>2014-08-12T00:00:00Z</published>
    <updated>2014-08-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Code and math in this post is done with the great help of Korolyov V. This post is written as a literate haskell file so it’s possible to copy it in a text file and run it in ghci. All sources can be found in <a href="https://github.com/qnikst/haskell-fun/tree/master/series">haskell-fun</a> repository.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE BangPatterns #-}</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.Fix</span></code></pre>
<p>We want to implement a with formal series expansion using haskell. Formal series can be expressed as follows:</p>
<p><span class="math">\[ f(x) = \sum\limits_{i=0}^\infty a_ix^i \]</span></p>
<p>And also address a Taylor series as an example. For a function <span class="math">\(f\)</span> we can expand it an any given point <span class="math">\(x_0\)</span>, then:</p>
<p><span class="math">\[ f(x) = f(x_0) + \sum_{k=1}\frac{f^{(k)}}{k!}(x-x_0)^k \]</span></p>
<p>Here we wanto to introduce a data structure that is capable for representation of such series. For such datastructure we have 2 main candidates:</p>
<ol style="list-style-type: decimal">
<li><p>List - a datastructure with two constructors that represent a possibly infinite single-linked list.</p></li>
<li><p>Stream - a datastructure with one constructor that represent an infinite stream of values.</p></li>
</ol>
<p>We may want to select a list because this way we may represent a finite series (as some functions have all coefficients equal to <span class="math">\(0\)</span> starting at some point, or if function diverge than all element will be represented as machine zero starting at some point). But we decide to use ‘Stream’ data type in order not to have a branching in functions.</p>
<p>It’s possible to use an existing library for <code>Stream</code> – <a href="https://hackage.haskell.org/package/Stream">Stream package</a>. However here we decide to implement our own data type for educational purposes. However if this module will grow to a real library the implementation likely will be changed to the one from the common package.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">S</span> a <span class="fu">=</span> <span class="dt">S</span> <span class="fu">!</span>a (<span class="dt">S</span> a)</code></pre>
<h2 id="instances">Instances</h2>
<p>Having a data structure we may define a set of instances.</p>
<h3 id="functor">Functor</h3>
<p>Series is a Functor:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">S</span> <span class="kw">where</span>
<span class="ot">&gt;</span>    fmap f (<span class="dt">S</span> a x) <span class="fu">=</span> <span class="dt">S</span> (f a) (fmap f x)</code></pre>
<p>An interesting note that <span class="math">\(fmap ~ (f :: a \to b)\)</span> moves a function that is represented by a serie from <span class="math">\(a \to a\)</span> to <span class="math">\(b \to b\)</span> that may not be a desired behaviour when <span class="math">\(a \neq b\)</span>.</p>
<h3 id="num">Num</h3>
<p>In order to use series in calculations we need to define a <code>Num</code> instance. But befor we will introduce few helpers:</p>
<p>A product of scalar and series:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; (^*) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> (<span class="fu">^*</span>) a <span class="fu">=</span> fmap (<span class="fu">*</span>a)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; (*^) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> (<span class="fu">*^</span>) <span class="fu">=</span> flip (<span class="fu">^*</span>)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; (/^) ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> (<span class="fu">/^</span>) s a <span class="fu">=</span> fmap (<span class="fu">/</span> a) s</code></pre>
<p>And pointwise product for future (see Library section for szipWith implementation):</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; (^*^) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> (<span class="fu">^*^</span>) <span class="fu">=</span> szipWith (<span class="fu">*</span>)</code></pre>
<p>Now we may give a ‘Num’ instance:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Num</span> (<span class="dt">S</span> a) <span class="kw">where</span>
<span class="ot">&gt;</span>   (<span class="dt">S</span> a x) <span class="fu">+</span> (<span class="dt">S</span> b y) <span class="fu">=</span> <span class="dt">S</span> (a <span class="fu">+</span> b) (x <span class="fu">+</span> y)
<span class="ot">&gt;</span>   abs s <span class="fu">=</span> fmap abs s
<span class="ot">&gt;</span>   negate s <span class="fu">=</span> fmap negate s
<span class="ot">&gt;</span>   signum s <span class="fu">=</span> fmap signum s
<span class="ot">&gt;</span>   (<span class="dt">S</span> a x) <span class="fu">*</span> (<span class="dt">S</span> b y) <span class="fu">=</span> <span class="dt">S</span> (a <span class="fu">*</span> b) (a <span class="fu">^*</span> y <span class="fu">+</span>  b <span class="fu">^*</span> x <span class="fu">+</span> <span class="dt">S</span> <span class="dv">0</span> (x <span class="fu">*</span> y))
<span class="ot">&gt;</span>   fromInteger x <span class="fu">=</span> <span class="dt">S</span> (fromInteger x) <span class="dv">0</span></code></pre>
<p>Here are 2 tricky parts, first one is implementation of <code>*</code> second one is implementation of <code>fromInteger</code>. For <code>*</code> we need to think of an expansion like of polymonial, i.e. <span class="math">\(S a b = a + b \cdot p\)</span>. Then we can write the following:</p>
<p><span class="math">\[
\begin{aligned}
 (S~a~x) \cdot (S~b~y) &amp;= (a + x p) \cdot (b + y p) = \\
  &amp;= (a b + a y p + b x p + x y p^2) = \\
  &amp;= S~(a b)~(a y + b x + x y p)     = \\
  &amp;= S~(a b)~(fmap~(*a)~y + fmap~(*b)~x + S~0~(x * y))
\end{aligned}
\]</span></p>
<p>There are 2 possible implementations for fromInteger:</p>
<ol style="list-style-type: decimal">
<li><p><code>fromInteger x = S (fromInteger x) (fromInteger x)</code></p></li>
<li><p><code>fromInteger x = S (fromInteger x) 0</code></p></li>
</ol>
<p>For <code>fromInteger</code> we need to select an implemention such that <span class="math">\(fromInteger 1 * a == a\)</span> <span class="math">\(fromInteger 0 + a = a\)</span> <span class="math">\(fromInteger 0 * a == 0\)</span> for any <span class="math">\(a\)</span>. So then we see that we can select only the second one, otherwise properties for <span class="math">\(1\)</span> will not hold.</p>
<h3 id="fractional">Fractional</h3>
<p>Now we can add a simple Fractional instance.</p>
<p>We say that <span class="math">\((S\,b\,y) = \cfrac{1}{(S\, a\, x)}\)</span> iff <span class="math">\((S\, b\, y)\)</span> is the solution of equation <span class="math">\((S\,b\,y)\,\cdot\,(S\,a\,x) = 1\)</span>. So the following intance is the result of this system of equations:</p>
<p><span class="math">\[
\begin{aligned}
  b_0 a_0 &amp; = 1,\\
  b_0 a_1 + b_1 a_0 &amp; = 0,\\
  b_0 a_2 + b_1 a_1 + a_2 a_0 &amp; = 0,\\
  \ldots
\end{aligned}
\]</span></p>
<p>These equations can be resursively solved by moving the last term from left-side convolutions to the right side, and dividing by <span class="math">\((-a_0)\)</span>. Moreover the rest of terms on the left are convolutions too, then as now series <span class="math">\(a\)</span> convolve with the tail of series <span class="math">\(b\)</span>. That fact may be used for compact of definition of recursive equations:</p>
<p><span class="math">\[
\begin{aligned}
  b_0 &amp; = \cfrac{1}{a_0},\\
  b_i &amp; = \cfrac{-1}{a_0} \sum\limits_{j = 0}^{i - 1} b_{j} a_{j + 1}.
\end{aligned}
\]</span></p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Fractional</span> (<span class="dt">S</span> a) <span class="kw">where</span>
<span class="ot">&gt;</span>   recip (<span class="dt">S</span> a x) <span class="fu">=</span> fix <span class="fu">$</span> fmap (<span class="fu">/</span> (<span class="fu">-</span>a)) <span class="fu">.</span> <span class="dt">S</span> (<span class="fu">-</span><span class="dv">1</span>) <span class="fu">.</span> (<span class="fu">*</span> x)
<span class="ot">&gt;</span>   fromRational x <span class="fu">=</span> <span class="dt">S</span> (fromRational x) <span class="dv">0</span></code></pre>
<p>Formulas for composition and inversion. Only series with zeroed head can be composed or reversed. Composition is handled according to Horner’s method:</p>
<p><span class="math">\[
\begin{aligned}
  f(x) &amp;= \sum\limits_{i=0}^{\infty} a_i x^i =
           a_0 + x \sum\limits_{i=0}^{\infty} a_{i+1} x^i,\\
  g(x) &amp;= \sum\limits_{j=1}^{\infty} b_j x^j =
           x \sum\limits_{j=0}^{\infty} b_{j+1} x^j, \\
  f(g(x)) &amp;= a_0 + g(x) \sum\limits_{i=0}^{\infty} a_{i+1} g(x)^i = \\
          &amp;= a_0 + x \left(\sum\limits_{j=0}^{\infty} b_{j+1} x^j\right)
              \left(\sum\limits_{i=0}^{\infty} a_{i+1} g(x)^i\right).
\end{aligned}
\]</span></p>
<p>The product of two series can be treated recursively, so:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; compose ::</span> (<span class="dt">Num</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> compose (<span class="dt">S</span> a x) (<span class="dt">S</span> <span class="dv">0</span> y) <span class="fu">=</span> <span class="dt">S</span> a (y <span class="fu">*</span> compose x (<span class="dt">S</span> <span class="dv">0</span> y))
<span class="ot">&gt;</span> compose _ _ <span class="fu">=</span> error <span class="st">&quot;compose: Non-zero head&quot;</span></code></pre>
<p>Inversion can be done by the following formula:</p>
<p><span class="math">\[
\begin{eqnarray}
  f(g(x)) &amp; = x, \\
  a_1 g(x) + a_2 g^2(x) + \ldots &amp; = x, \\
  g(x) (a_1 + a_2 g(x) + \ldots) &amp; = x, \\
  b_1 x + b_2 x^2 + \ldots &amp; = \cfrac{x}{a_1 + a_2 g(x) + \ldots}, \\
  b_1 + b_2 x + \ldots &amp; = \cfrac{1}{a_1 + a_2 g(x) + \ldots}.
\end{eqnarray}
\]</span></p>
<p>The last equality gives the recursive rule:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; inverse ::</span> (<span class="dt">Fractional</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> inverse (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> <span class="kw">let</span> y <span class="fu">=</span> <span class="dt">S</span> <span class="dv">0</span> (recip <span class="fu">$</span> compose x y) <span class="kw">in</span> y
<span class="ot">&gt;</span> inverse _ <span class="fu">=</span> error <span class="st">&quot;inverse: Non-zero head&quot;</span></code></pre>
<p>According to general theory elementary special functions cannot be evaluated on the non-zero headed series. We try to handle this situaton by breaking the series into two parts: the head and the zero-headed tail.</p>
<p>The head is treated by classic functions, the tail is treated by composing argument series with classical series of elementary functions, and the combination is done by ad-hoc formulas. The first example of the ad-hoc formula:</p>
<p><span class="math">\[
\begin{eqnarray}
  \sin \sum\limits_{i = 0}^{\infty} a_i x^i =
       \sin (a_0 + \sum\limits_{i = 1}^{\infty} a_i x^i) =
  \sin a_0 \cdot \cos \sum\limits_{i = 1}^{\infty} a_i x^i +
       \cos a_0 \cdot \sin \sum\limits_{i = 1}^{\infty} a_i x^i.
\end{eqnarray}
\]</span></p>
<p>Here <span class="math">\(\cos a_0\)</span> and <span class="math">\(\sin a_0\)</span> are sine and cosine of scalar. And the sine/cosine of zero-headed series can be calculated by composition of the argument with well-known series of sine/cosine.</p>
<p>The second example. Let’s look at the <span class="math">\(\arcsin\)</span>, definitions:</p>
<p><span class="math">\[
\begin{eqnarray}
  \sum\limits_{i = 0}^{\infty} b_i x^i = \arcsin \sum\limits_{i = 0}^{\infty} a_i x^i,\\
  \sin\sum\limits_{i = 0}^{\infty} b_i x^i = \sum\limits_{i = 0}^{\infty} a_i x^i.
\end{eqnarray}
\]</span></p>
<p>And solution for an ad-hoc formula is obtained as follows (using the fact <span class="math">\(b_0 = \arcsin a_0\)</span>):</p>
<p><span class="math">\[
\begin{eqnarray}
  \sin\sum\limits_{i = 1}^{\infty} b_i x^i =
    \sin\left(\sum\limits_{i = 0}^{\infty} b_i x^i - b_0 \right) = \\
  = \cos b_0 \cdot \sin\sum\limits_{i = 0}^{\infty} b_i x^i -
    \sin b_0 \cdot \cos\sum\limits_{i = 0}^{\infty} b_i x^i = \\
  = \sqrt{1 - a_0^2} \cdot \sum\limits_{i = 0}^{\infty} a_i x^i -
    a_0 \cdot \sqrt{1 - \left(\sum\limits_{i = 0}^{\infty} a_i x^i\right)^2}.
\end{eqnarray}
\]</span></p>
<p>The full formula is done by adding <span class="math">\(b_0\)</span>:</p>
<p><span class="math">\[
\begin{equation}
  \sum\limits_{i = 0}^{\infty} b_i x^i =
    \arcsin a_0 + \arcsin
       \left[
       \sqrt{1 - a_0^2} \cdot
       \sum\limits_{i = 0}^{\infty} a_i x^i -
       a_0 \cdot \sqrt{1 - \left(\sum\limits_{i = 0}^{\infty} a_i x^i\right)^2}
       \right].
\end{equation}
\]</span></p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> (<span class="dt">Floating</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Floating</span> (<span class="dt">S</span> a) <span class="kw">where</span>
<span class="ot">&gt;</span>   pi <span class="fu">=</span> <span class="dt">S</span> pi <span class="dv">0</span>
<span class="ot">&gt;</span>   exp (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> texp <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   exp (<span class="dt">S</span> a x) <span class="fu">=</span> exp a <span class="fu">^*</span> exp (<span class="dt">S</span> <span class="dv">0</span> x)
<span class="ot">&gt;</span>   log (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> tlog <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   log (<span class="dt">S</span> a x) <span class="fu">=</span> <span class="dt">S</span> (log a) <span class="dv">0</span> <span class="fu">+</span> log (<span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> fmap (<span class="fu">/</span> a) x)
<span class="ot">&gt;</span>   sin (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> tsin <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   sin (<span class="dt">S</span> a x) <span class="fu">=</span> sin a <span class="fu">^*</span> cos (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">+</span> cos a <span class="fu">^*</span> sin (<span class="dt">S</span> <span class="dv">0</span> x)
<span class="ot">&gt;</span>   cos (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> tcos <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   cos (<span class="dt">S</span> a x) <span class="fu">=</span> cos a <span class="fu">^*</span> cos (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">-</span> sin a <span class="fu">^*</span> sin (<span class="dt">S</span> <span class="dv">0</span> x)</code></pre>
<p>An interesting example is sqrt, as usual we want to find <span class="math">\(b_n\)</span> such that:</p>
<p><span class="math">\[ \sum\limits_{n=0}^\infty b_nx^n \cdot \sum\limits_{n=0}^\infty b_nx^n = \sum\limits_{n=0}^n a_i x^n \]</span></p>
<p>Rewrite the formula in a head-tail form, where <span class="math">\(y\)</span> – is a tail of b, and <span class="math">\(p\)</span> – is a tail of incomming series:</p>
<p><span class="math">\[ (b_0 + x * y) (b_ 0 + x * y) = a0 + x p\]</span></p>
<p><span class="math">\[ b_0^2 + 2 x y + x^2 y = a0 + x p\]</span></p>
<p>by grouping elements with 0 and 1 power of <span class="math">\(x\)</span>, we find:</p>
<p><span class="math">\[
\begin{equation}
  \left\lbrace
  \begin{matrix}
     b_0 &amp; = \sqrt{a_0} \\
     y &amp; = \frac{p-y^2}{2 \sqrt{a_0}}
  \end{matrix}
  \right.
\end{equation}
\]</span></p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>   sqrt (<span class="dt">S</span> <span class="dv">0</span> (<span class="dt">S</span> <span class="dv">0</span> x)) <span class="fu">=</span> <span class="dt">S</span> <span class="dv">0</span> (sqrt x)
<span class="ot">&gt;</span>   sqrt (<span class="dt">S</span> <span class="dv">0</span> _) <span class="fu">=</span> <span class="kw">let</span> sq <span class="fu">=</span> <span class="dt">S</span> (<span class="dv">0</span> <span class="fu">/</span> <span class="dv">0</span>) sq <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> sq
<span class="ot">&gt;</span>   sqrt (<span class="dt">S</span> a x) <span class="fu">=</span> <span class="kw">let</span> sqa <span class="fu">=</span> sqrt a
<span class="ot">&gt;</span>                      sqx <span class="fu">=</span> (x <span class="fu">-</span> <span class="dt">S</span> <span class="dv">0</span> (sqx <span class="fu">*</span> sqx)) <span class="fu">/^</span> (<span class="dv">2</span> <span class="fu">*</span> sqrt a)
<span class="ot">&gt;</span>                  <span class="kw">in</span> <span class="dt">S</span> sqa sqx
<span class="ot">&gt;</span>   asin (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> tasin <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   asin (<span class="dt">S</span> a x) <span class="fu">=</span> <span class="kw">let</span> <span class="dt">S</span> _ y <span class="fu">=</span> sqrt (<span class="dv">1</span> <span class="fu">-</span> a <span class="fu">*</span> a) <span class="fu">^*</span> (<span class="dt">S</span> a x) <span class="fu">-</span>
<span class="ot">&gt;</span>                              a <span class="fu">^*</span> sqrt (<span class="dv">1</span> <span class="fu">-</span> (<span class="dt">S</span> a x) <span class="fu">*</span> (<span class="dt">S</span> a x))
<span class="ot">&gt;</span>                  <span class="kw">in</span> <span class="dt">S</span> (asin a) <span class="dv">0</span> <span class="fu">+</span> asin (<span class="dt">S</span> <span class="dv">0</span> y)
<span class="ot">&gt;</span>   acos (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> tacos <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   acos (<span class="dt">S</span> a x) <span class="fu">=</span> <span class="kw">let</span> <span class="dt">S</span> _ y <span class="fu">=</span> a <span class="fu">^*</span> (<span class="dt">S</span> a x) <span class="fu">-</span>
<span class="ot">&gt;</span>                              sqrt (<span class="dv">1</span> <span class="fu">-</span> a <span class="fu">*</span> a) <span class="fu">^*</span> sqrt (<span class="dv">1</span> <span class="fu">-</span> (<span class="dt">S</span> a x) <span class="fu">*</span> (<span class="dt">S</span> a x))
<span class="ot">&gt;</span>                  <span class="kw">in</span> <span class="dt">S</span> (acos a) <span class="dv">0</span> <span class="fu">+</span> acos (<span class="dt">S</span> <span class="dv">0</span> y)
<span class="ot">&gt;</span>   atan (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> tatan <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   atan (<span class="dt">S</span> a x) <span class="fu">=</span> <span class="kw">let</span> <span class="dt">S</span> _ y <span class="fu">=</span> <span class="dt">S</span> <span class="dv">0</span> x <span class="fu">/</span> (<span class="dv">1</span> <span class="fu">+</span> a <span class="fu">^*</span> (<span class="dt">S</span> a x))
<span class="ot">&gt;</span>                  <span class="kw">in</span> <span class="dt">S</span> (atan a) <span class="dv">0</span> <span class="fu">+</span> atan (<span class="dt">S</span> <span class="dv">0</span> y)
<span class="ot">&gt;</span>   sinh x <span class="fu">=</span> (exp x <span class="fu">-</span> exp (<span class="fu">-</span>x)) <span class="fu">/^</span> <span class="dv">2</span>
<span class="ot">&gt;</span>   cosh x <span class="fu">=</span> (exp x <span class="fu">+</span> exp (<span class="fu">-</span>x)) <span class="fu">/^</span> <span class="dv">2</span>
<span class="ot">&gt;</span>   asinh x <span class="fu">=</span> log (x <span class="fu">+</span> sqrt (x <span class="fu">*</span> x <span class="fu">+</span> <span class="dv">1</span>))
<span class="ot">&gt;</span>   acosh x <span class="fu">=</span> undefined <span class="co">-- log (x + sqrt (x * x - 1))</span>
<span class="ot">&gt;</span>   atanh x <span class="fu">=</span> log ((<span class="dv">1</span> <span class="fu">+</span> x) <span class="fu">/</span> (<span class="dv">1</span> <span class="fu">-</span> x)) <span class="fu">/^</span> <span class="dv">2</span></code></pre>
<h2 id="library">Library</h2>
<p>Now we can define mathematic functions on the power series. The derivative:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; diff ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> diff s <span class="fu">=</span> fmap fromInteger (fromList [<span class="dv">1</span><span class="fu">..</span>]) <span class="fu">^*^</span> stail s</code></pre>
<p>And the integral:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; integral ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> integral c  s <span class="fu">=</span> <span class="dt">S</span> c (s <span class="fu">^*^</span> fmap (recip<span class="fu">.</span>fromInteger) (fromList [<span class="dv">1</span><span class="fu">..</span>]) )</code></pre>
<h3 id="generic-functions">Generic functions:</h3>
<p>In order to inspect a stream we can introduce a helper function:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; stake ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> stake <span class="dv">0</span> _       <span class="fu">=</span> []
<span class="ot">&gt;</span> stake n (<span class="dt">S</span> a s) <span class="fu">=</span> a<span class="fu">:</span>stake (n<span class="fu">-</span><span class="dv">1</span>) s</code></pre>
<p>Here all functions will be prefixed with <code>s</code> however if you write a module for working with streams you may prefer to not add it and ask user to import module qualified.</p>
<p>Here is a function that builds a stream from the list (and the other way):</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fromList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> fromList (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">S</span> x (fromList xs) <span class="co">-- works only on infinite list</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; fromListNum ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> fromListNum [] <span class="fu">=</span> <span class="dv">0</span>
<span class="ot">&gt;</span> fromListNum (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">S</span> x (fromListNum xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt; toList ::</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> toList (<span class="dt">S</span> x xs) <span class="fu">=</span> x <span class="fu">:</span> toList xs</code></pre>
<p>In order to write an usefull functions and series we will introduce a folding:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sscan ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> b <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> sscan f i (<span class="dt">S</span> x s) <span class="fu">=</span>
<span class="ot">&gt;</span>  <span class="kw">let</span> k <span class="fu">=</span> f i x
<span class="ot">&gt;</span>  <span class="kw">in</span> <span class="dt">S</span> k (sscan f k s)</code></pre>
<p>Now lets introduce few functions using <code>sfold</code>. A function that will generate a sum of the Stream, i.e. having a stream <code>ssum &lt;a0:a1:a2:..&gt; = &lt;a0:a0+a1:a0+a1+a2:...&gt;</code></p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ssum ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> ssum <span class="fu">=</span> sscan (<span class="fu">+</span>) <span class="dv">0</span></code></pre>
<p>Build a stream by iterating a function</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; siterate ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> siterate f x <span class="fu">=</span> <span class="dt">S</span> x (siterate f (f x))</code></pre>
<p>Build a serie of powers: <span class="math">\(&lt;x,x^2,x^3,...&gt;\)</span></p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> spower x <span class="fu">=</span> <span class="dt">S</span> <span class="dv">1</span> (siterate (<span class="fu">*</span>x) x)</code></pre>
<p>Unfold</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sunfold ::</span> (c <span class="ot">-&gt;</span> (c,a)) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> sunfold f k <span class="fu">=</span> <span class="kw">let</span> (k&#39;,a) <span class="fu">=</span> f k <span class="kw">in</span> <span class="dt">S</span> a (sunfold f k&#39;)</code></pre>
<p>Because we want to implement a teylor serie we want to have a serie of factorials</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sfac ::</span> (<span class="dt">Enum</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> sfac <span class="fu">=</span> sscan (<span class="fu">*</span>) <span class="dv">1</span> (fromList [<span class="dv">1</span><span class="fu">..</span>]) </code></pre>
<p>And now 1/factorials</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sdfac ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> sdfac <span class="fu">=</span> fmap (\x <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">/</span> (fromIntegral x)) sfac</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; szipWith ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> b <span class="ot">-&gt;</span> <span class="dt">S</span> c
<span class="ot">&gt;</span> szipWith f (<span class="dt">S</span> a x) (<span class="dt">S</span> b y) <span class="fu">=</span> <span class="dt">S</span> (f a b) (szipWith f x y)</code></pre>
<p>This is an actual building of the Taylor serie:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; build ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> build t s <span class="fu">=</span> ssum <span class="fu">$</span> spower t <span class="fu">^*^</span> s</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; shead ::</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> shead (<span class="dt">S</span> a s) <span class="fu">=</span> a</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; stail ::</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> stail (<span class="dt">S</span> a s) <span class="fu">=</span> s</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sdropWhile ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> sdropWhile p s<span class="fu">@</span>(<span class="dt">S</span> a xs)
<span class="ot">&gt;</span>   <span class="fu">|</span> p a <span class="fu">=</span> sdropWhile p xs
<span class="ot">&gt;</span>   <span class="fu">|</span> otherwise <span class="fu">=</span> s</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; eps ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> eps e s <span class="fu">=</span> snd <span class="fu">.</span> shead <span class="fu">.</span> sdropWhile (\(x,y) <span class="ot">-&gt;</span> abs (x <span class="fu">-</span> y) <span class="fu">&gt;=</span> e)
<span class="ot">&gt;</span>         <span class="fu">$</span> szipWith (,) s (stail s)</code></pre>
<h2 id="taylor-series-for-some-analytic-functions">Taylor series for some analytic functions</h2>
<p>Here we defined examples for the functions with analytically known series at 0.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; texp ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> texp <span class="fu">=</span> <span class="dt">S</span> <span class="dv">1</span> sdfac</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tlog ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tlog <span class="fu">=</span> <span class="kw">let</span> go n s <span class="fu">=</span> <span class="dt">S</span> (s <span class="fu">/</span> n) (go (n <span class="fu">+</span> <span class="dv">1</span>) (<span class="fu">-</span>s))
<span class="ot">&gt;</span>        <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span> <span class="dv">1</span>)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tsin ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tsin <span class="fu">=</span> <span class="kw">let</span> s <span class="fu">=</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">.</span> <span class="dt">S</span> (<span class="fu">-</span><span class="dv">1</span>) <span class="fu">$</span> s
<span class="ot">&gt;</span>        <span class="kw">in</span> s <span class="fu">^*^</span> texp</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tcos ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tcos <span class="fu">=</span> <span class="kw">let</span> s <span class="fu">=</span> <span class="dt">S</span> <span class="dv">1</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">.</span> <span class="dt">S</span> (<span class="fu">-</span><span class="dv">1</span>) <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> s
<span class="ot">&gt;</span>        <span class="kw">in</span> s <span class="fu">^*^</span> texp</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tasin ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tasin <span class="fu">=</span> <span class="kw">let</span> go n <span class="fu">=</span> <span class="dt">S</span> (<span class="dv">1</span> <span class="fu">/</span> n) (fmap (<span class="fu">*</span> (n <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>))) <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> go (n <span class="fu">+</span> <span class="dv">2</span>))
<span class="ot">&gt;</span>         <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span>)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tacos ::</span> (<span class="dt">Eq</span> a, <span class="dt">Floating</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tacos <span class="fu">=</span> pi <span class="fu">/</span> <span class="dv">2</span> <span class="fu">-</span> tasin</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tatan ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tatan <span class="fu">=</span> <span class="kw">let</span> go s n <span class="fu">=</span> <span class="dt">S</span> (s <span class="fu">/</span> n) <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> go (<span class="fu">-</span>s) (n <span class="fu">+</span> <span class="dv">2</span>)
<span class="ot">&gt;</span>         <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> go <span class="dv">1</span> <span class="dv">1</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tsinh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tsinh <span class="fu">=</span> <span class="kw">let</span> s <span class="fu">=</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="fu">$</span> s
<span class="ot">&gt;</span>         <span class="kw">in</span> s <span class="fu">^*^</span> texp</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tcosh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tcosh <span class="fu">=</span> <span class="kw">let</span> s <span class="fu">=</span> <span class="dt">S</span> <span class="dv">1</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> s
<span class="ot">&gt;</span>         <span class="kw">in</span> s <span class="fu">^*^</span> texp</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tasinh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tasinh <span class="fu">=</span> <span class="kw">let</span> go s n <span class="fu">=</span> <span class="dt">S</span> (s <span class="fu">/</span> n) (fmap (<span class="fu">*</span> (n <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>))) <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> go (<span class="fu">-</span>s) (n <span class="fu">+</span> <span class="dv">2</span>))
<span class="ot">&gt;</span>          <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span> <span class="dv">1</span>)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tacosh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tacosh <span class="fu">=</span> undefined</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tatanh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tatanh <span class="fu">=</span> <span class="kw">let</span> go n <span class="fu">=</span> <span class="dt">S</span> (recip n) <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> go (n <span class="fu">+</span> <span class="dv">2</span>)
<span class="ot">&gt;</span>          <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span>)</code></pre>
<h2 id="todo">TODO</h2>
<p>Some thing were not covered in this file, taylor series were not statically protected agains calling actions on the series build at the different points, so we assume that every Taylor serie is built at <span class="math">\(0\)</span>.</p>
<p>Not all functions from the Floating instance were implemented.</p>
<p>It’s possible to generalize <span class="math">\(asin/sin\)</span> approach for wider class of functions, but it was not done yet.</p>]]></summary>
</entry>
<entry>
    <title>Playing with types: type level numbers</title>
    <link href="http://qnikst.github.com/posts/2014-08-07-playing-with-types.html" />
    <id>http://qnikst.github.com/posts/2014-08-07-playing-with-types.html</id>
    <published>2014-08-07T00:00:00Z</published>
    <updated>2014-08-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>As always I’m terribly sorry for my bad english, but writing the posts and having a feedback is the only reasonable way to improve it.</p>
</blockquote>
<p>This post describes an easy exercise that gives a feeling of use typelevel numbers. This post is a part of another work that hopefully will be covered in following posts.</p>
<p>If you want to know more about typelevel literals and friends you can take a look at the <a href="http://ponies.io/posts/2014-07-30-typelits.html">following post</a> it describes the theory much better than I can.</p>
<p>Intead of using type level Strings we will address numbers. In this post I want to create a datatype that will contain a number that is known <em>statically</em> (at compilation time) and which can be extracted from type at <em>runtime</em>.</p>
<p>The first part of the problem (having a number) in a type may be interesting if you want to distiguish types assosiated with different numbers.</p>
<p>For simplicity we will take <a href="https://hackage.haskell.org/package/tagged-0.7.2/docs/Data-Tagged.html">Data.Tagged.Tagged</a> type from <code>tagged</code> package. However it’s possible to create our own type as I did at the beggining (just I did a first time).</p>
<p>We add helper methods that allow us to extract infomation about the type-parameter from the value:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toProxy ::</span> <span class="dt">Tagged</span> n a  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n
toProxy _ <span class="fu">=</span> <span class="dt">Proxy</span></code></pre>
<p>And add a constrictor helper that allow to create a type with information about number that is provided by us.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkT ::</span> proxy n <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tagged</span> n a
mkT _ a <span class="fu">=</span> <span class="dt">Tagged</span> a</code></pre>
<p>Just check that we can create a fancy values:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Nothing</span>) <span class="dv">8</span>
mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Nothing</span>) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> <span class="ch">&#39;Nothing a</span></code></pre>
<h1 id="naturals">Naturals</h1>
<p>From this point we can start real fun. At first lest create a value with natural type parameter:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span>
mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> <span class="dv">3</span> a</code></pre>
<p>Now we want to be able to use this information at runtime. Let’s introduce a new method that will use <code>natVal</code> function:</p>
<pre class="haskel"><code>natVal :: forall n proxy. KnownNat n =&gt; proxy n -&gt; Integer` </code></pre>
<p>take a type that acts as a type proxy and returns the integer assosiated with a type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">useT ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Tagged</span> n a <span class="ot">-&gt;</span> a
useT t<span class="fu">@</span>(<span class="dt">Tagged</span> a) <span class="fu">=</span> fromIntegral (natVal (toProxy t)) <span class="fu">+</span> a</code></pre>
<p>Here we are:</p>
<ol style="list-style-type: decimal">
<li><p>extracting type information by calling <code>toProxy</code></p></li>
<li><p>extracting natural number from a proxy by calling <code>natVal</code></p></li>
<li><p>returning a calculated results</p></li>
</ol>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> useT <span class="fu">$</span> mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span>
<span class="dv">11</span></code></pre>
<h1 id="positive-rational">Positive rational</h1>
<p>On the next step we will introduce a code that works for natural numbers, by definition rational number is <code>a % b</code>, where <code>a \in Z</code> and <code>b \in N</code>. Lets lift this information to a type level by introducing a typelevel rational:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> (<span class="fu">:%%</span>) a b</code></pre>
<p>And introduce type extraction mechanisms</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | extract numerator type</span>
numerator<span class="ot"> ::</span> proxy (n <span class="fu">:%%</span> m) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n
numerator _ <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="co">-- | Extract denomenator type </span>
<span class="ot">denomenator ::</span> proxy (n <span class="fu">:%%</span> m)  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> m
denomenator _ <span class="fu">=</span> <span class="dt">Proxy</span></code></pre>
<p>Today we don’t conver math operations over the type-parameters, this may be a topic for another post. So now we may be quite happy as we can create values tagged by something that looks like a rational number.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span>
mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>) a</code></pre>
<p>Now we can write a function that will use information about the type at runtime:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">useTF ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (n <span class="fu">:%%</span> m) a <span class="ot">-&gt;</span> a
useTF t<span class="fu">@</span>(<span class="dt">Tagged</span> a) <span class="fu">=</span> v <span class="fu">+</span> a
  <span class="kw">where</span> v <span class="fu">=</span> fromRational <span class="fu">$</span>
               natVal (numerator <span class="fu">$</span> toProxy t) <span class="fu">:%</span> natVal (denomenator <span class="fu">$</span> toProxy t)</code></pre>
<p>Lets check:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> useTF <span class="fu">$</span> mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span>
<span class="dv">8</span><span class="fu">.</span><span class="dv">375</span></code></pre>
<h1 id="positive-real.">Positive real.</h1>
<p>Now we want to solve the following problem: it’s not easy to write types for ratio, the reason that for a complex cases we need somehow to find the ratio that fits. Also we want to support real numbers. Having in mind the fact that real values are not supported on the typelevel, we may be quite happy with Rational approximation.</p>
<p>In order to solve those 2 problems we need:</p>
<ol style="list-style-type: decimal">
<li><p>real values support</p></li>
<li><p>ability to write code easily</p></li>
</ol>
<p>We will introduce a TH function that will find a good approximation and create required type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkFloatProxy ::</span> <span class="dt">RealFrac</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
mkFloatProxy x <span class="fu">=</span> [<span class="fu">|</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="fu">$</span>(nk a) <span class="fu">:%%</span> <span class="fu">$</span>(nk b)) <span class="fu">|</span>]
  <span class="kw">where</span> (a <span class="fu">:%</span> b) <span class="fu">=</span> toRational x
          nk x <span class="fu">=</span> sigT (litT (numTyLit x)) (<span class="dt">ConT</span> <span class="fu">$</span> mkName <span class="st">&quot;Nat&quot;</span>)</code></pre>
<p>the magic that we have in <code>nk x</code> we need to create a type parameter of kind <code>Nat</code>. Now we can write a code like:</p>
<blockquote>
<p>test = mkT $(mkFloatProxy pi) 7.0</p>
</blockquote>
<p>This is quite nice, next steps may be support of negative values, using SomeNat and operations on values.</p>]]></summary>
</entry>
<entry>
    <title>О stockdb</title>
    <link href="http://qnikst.github.com/posts/2013-12-30-haskell-laziness.html" />
    <id>http://qnikst.github.com/posts/2013-12-30-haskell-laziness.html</id>
    <published>2013-12-30T00:00:00Z</published>
    <updated>2013-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>(Старый пост взятый из исходников блога, так что он может содержать несколько устаревшие данные, кроме бенчмарков сделаных в августе 2014)</p>
<p>Недавно я столкнулся с задачей оптимизации программы написанной Максом Лапшиным (<span class="citation">@maxlapshin</span>). Программу говорят, что уже смотрели и другие программисты, но все же я решился потратить время и посмотреть, что там не так.</p>
<p>Первое, что мне первое бросилось в глаза это то, что одно из основных свойств языка “ленивость” совсем не использовалось, в связи с этим я собираюсь акцентировать внимание именно на этом аспекте.</p>
<p>Что позволяет ленивость:</p>
<pre><code>1. Возможность не вычислять значения, которые не используются

2. Возможность создания эффективных персистентных структур данных (см. Окасаки)

3. Возможность создания итеративных вычислений</code></pre>
<p>Естественно, все это дается не бесплатно:</p>
<pre><code>1. Ленивость приводит к оверхеду по памяти, т.к. нужно хранить больше информации

2. Ленивость может приводить к повторным вычислениям в многопоточных программах

3. Ленивость может приводить к “утечкам”, т.е. случаям, когда вместо результато
   создаются структуры описывающие отложенные вычисления “thunk” и их накапливается
   очень большое количество. Часто этот эффект называют memory leak, хотя лично
   мне не нравится данный термин, поскольку обычно он используется для описания
   неиспользуемой, но не освобожденной памяти.</code></pre>
<p>Особенно неприятной является третья проблема, как но её решение, в очень многих случаях, заключается в применении следующего правила:</p>
<blockquote>
<p>Не использовать ленивые поля в стуктурах данных, если это специально не требуется.</p>
</blockquote>
<h2 id="строгость-структур-данных">Строгость структур данных</h2>
<p>В этом случае если вы не знаете, нужна ли вам ленивость, делайте поле строгим. Так же если переиспользование не нужно или данные по размеру меньше, чем указатель, то можно их сразу распаковать {-# UNPACK #-} это снимет один уровень индирекции.</p>
<p>Вместо списков зачастую выгоднее иметь вектора, что уменьшает уровень индирекции и ускоряет работу с ними, особенно это выгодно в случае, если размер вектора известен или он создается целиком и больше не изменяется.</p>
<p>Стоит отметить, что для данной задачи оптимизации не привносят много плюсов, поскольку создаваемые стуктуры никак не используются.</p>
<h2 id="неправильные-библиотеки">“Неправильные” библиотеки</h2>
<p>В коде использовалась очень неэффективная библиотека binary-strict, хотя абсолютно никакой необходимости использовать как строгие байтстроки, так и эту библиотеку не было. В общем-то, в этом была основная проблема и замена библиотеки на binary и binary-bits дало максимальную часть прироста скорости.</p>
<p>Так же работа на уровне бит для всего разбора это слишком дорого, поскольку битовые операции требуются только для разбора diff записей. Поэтому четкое разделение runBitGet и runGet сильно помогает для разделение операций, так же сделать часть операций полиморфными по монаде.</p>
<p>Следующй шаг это выделение всего что можно в Applicative синтаксис, что хоть в данном случае и не приводит к заметному ускорению, но упрощает код. Итеративный подход</p>
<p>Следующий момент в использовании reverse/snoc подхода при создании списков, данный метод является монолитным, т.е. если мы начинаем вычисление, то оно доводится до конца. Но в большинстве случаев этого не хочется, т.к. во-первых не все данные могут быть использованы во-вторых итеративный подход позволяет обрабатывать данные по частям, не держа их все в памяти если это не необходимо. Поскольку haskell язык ленивый, то вместо reverse/snoc, можно использовать go/snoc, где go создает хвост списка.</p>
<p>Поэтому код</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">parsePayload&#39; <span class="dv">0</span> acc <span class="fu">=</span> return (reverse acc)
parsePayload&#39; count acc <span class="fu">=</span> <span class="kw">do</span>
  stock <span class="ot">&lt;-</span> readRow previous
  parsePayload&#39; (count <span class="fu">-</span> <span class="dv">1</span>) (stock <span class="fu">:</span> acc)</code></pre>
<p>можно переписать как:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">parsePayload&#39; <span class="dv">0</span> <span class="fu">=</span> return []
parsePayload&#39; count <span class="fu">=</span> <span class="kw">do</span>
  l <span class="ot">&lt;-</span> readRow
  ls <span class="ot">&lt;-</span> parsePayload&#39; (count<span class="fu">-</span><span class="dv">1</span>)
  return <span class="fu">$!</span> l<span class="fu">:</span>ls</code></pre>
<p>На самом деле данный код не сильно лучше предыдущего варианта, поскольку тоже является монолитным, но он приведен здесь как промежуточный шаг, и для того, чтобы рассмотреть отличия. В первом случае мы сначала создаем весь список O(N) по памяти и сложности и потом разворачиваем, соответсвенно при том же порядке сложности мы получаем вдвое большую константу, при этом используется куча. Во-втором варианте увеличение костанты не происходит, но вместо кучи используется стек, что имеет свои минусы. Так же в случае ленивой монады, т.е. когда вместо результата мы возвращаем действие производящее результат мы получаем уже инетаривный результат (правда к монаде Get это не относится).</p>
<p>Дальнейшее улучшение может быть произведено за счет того, что нам не нужно возвращать все данные в монаде, а достаточно обрабатывать одну запись и выходить, при помощи метода runGetOrFail.</p>
<p>На самом деле нужно идти дальше и делать composable операции создавая сначала поток объектов и diff-ов и объединяя их отдельной операцией. Но об этом в другой раз, если у меня дойдут руки до написания полноценной библиотеки для работы с такими файлами.</p>
<h2 id="код-и-результаты">Код и результаты:</h2>
<p>Код можно найти на <a href="https://github.com/maxlapshin/stockdb-hs">github</a>, ветку с изменениями примерно там же.</p>
<p>В оригинальную программу требуется добавить модификацию позволяющую считывать нужное количество записей, а не только 10000:</p>
<pre><code>diff --git a/stockdb.hs b/stockdb.hs
index 75fa7da..8ecf2e1 100644
--- a/stockdb.hs
+++ b/stockdb.hs
@@ -81,7 +81,7 @@ runEither (Left e)  = fail e
 readStocks :: BS.ByteString -&gt; Either String [Stock]
 readStocks = parsePayload . BS.drop (289 * 4) . skipHeaders where
     parsePayload payload = BG.runBitGet payload $
-        parsePayload&#39; 10000 (fail &quot;First row must be full&quot;) []
+        parsePayload&#39; 167544 (fail &quot;First row must be full&quot;) []
     parsePayload&#39; 0 previous acc = return (reverse acc)
     parsePayload&#39; count previous acc = do
         stock &lt;- readRow previous</code></pre>
<p>Время работы оригинальной программы:</p>
<pre><code>qnikst@localhost ~/workspace/myself/stockdb-hs $ \time -v ./stockdb out.stock-2
167544
     Command being timed: &quot;./stockdb out.stock-2&quot;
     User time (seconds): 13.96
     System time (seconds): 1.00
     Percent of CPU this job got: 99%
     Elapsed (wall clock) time (h:mm:ss or m:ss): 0:14.98
     Average shared text size (kbytes): 0
     Average unshared data size (kbytes): 0
     Average stack size (kbytes): 0
     Average total size (kbytes): 0
     Maximum resident set size (kbytes): 15146224
     Average resident set size (kbytes): 0
     Major (requiring I/O) page faults: 0
     Minor (reclaiming a frame) page faults: 945203
     Voluntary context switches: 1
     Involuntary context switches: 1550
     Swaps: 0
     File system inputs: 0
     File system outputs: 0
     Socket messages sent: 0
     Socket messages received: 0
     Signals delivered: 0
     Page size (bytes): 4096
     Exit status: 0</code></pre>
<p>Время работы обновленной программы</p>
<pre><code>167544
     Command being timed: &quot;./stockdb out.stock-2&quot;
     User time (seconds): 5.11
     System time (seconds): 0.27
     Percent of CPU this job got: 99%
     Elapsed (wall clock) time (h:mm:ss or m:ss): 0:05.39
     Average shared text size (kbytes): 0
     Average unshared data size (kbytes): 0
     Average stack size (kbytes): 0
     Average total size (kbytes): 0
     Maximum resident set size (kbytes): 783664
     Average resident set size (kbytes): 0
     Major (requiring I/O) page faults: 0
     Minor (reclaiming a frame) page faults: 233956
     Voluntary context switches: 1
     Involuntary context switches: 542
     Swaps: 0
     File system inputs: 0
     File system outputs: 0
     Socket messages sent: 0
     Socket messages received: 0
     Signals delivered: 0
     Page size (bytes): 4096
     Exit status: 0</code></pre>
<p>Итого ускорение посчти в 3 раза по скорости, а потребление мапяти уменьшилось в 20 раз.</p>]]></summary>
</entry>
<entry>
    <title>Supervision inside OpenRC</title>
    <link href="http://qnikst.github.com/posts/2013-11-06-openrc-supervision.html" />
    <id>http://qnikst.github.com/posts/2013-11-06-openrc-supervision.html</id>
    <published>2013-11-06T00:00:00Z</published>
    <updated>2013-11-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The role of the supervision in the init systems becomes crucial. And many administrators wants some kind of s-vision support from the scratch. Here are some thoughts about this problem and a way how things will be solved inside OpenRC.</p>
<p><small>(As always I’m sorry for my english and maybe problems in technitial details, so any feedback is apprecated</small></p>
<h1 id="the-problem.">The problem.</h1>
<p>The idea of supervision is to take care about running processes and restart them in the case if they fail. It’s interesting to say that ‘fail’ may mean different things:</p>
<ol style="list-style-type: decimal">
<li>Process exited (with non zero EXIT_CODE);</li>
<li>Process fail to work as expected.</li>
</ol>
<p>In the most systems only first meaning is addressed, however it’s not very carefull and in systems where <em>reliance</em> is required we need to use additional tools to support 2.</p>
<p>Another set of problem is about how we will decide if we want to restart service and run cleanup actions. And this problem is not easy at all, i.e. we may want to stop restarting service if it fails constantly, or increase timeout in restarts and so on.</p>
<p>Also we may want additional features like say, remote access/control to supervised services, additinal notification.</p>
<p>And it’s clear that it’s insane to support all required tools inside one service management package, and there the solution will be: ‘give a user possibility to delegate supervision problem to the standalone application’.</p>
<p>So the solution would be the following:</p>
<ol style="list-style-type: decimal">
<li>Let OpenRC know that user may want s-vision for some services and what module he want to use;</li>
<li>Provide a set of existing modules;</li>
<li>Give an ability to create new modules.</li>
</ol>
<h1 id="monit">Monit</h1>
<p>I’ve started to work on ‘monit’ approach. Monit (http://mmonit.com/monit/) is a monitoring that allowes user to monitor services and give much possibilites for their control. This tool provides a special language that describes how each service should be monitored started and restarted.</p>
<p>Currently it’s possible to run monit as a standalone daemon and then control supervision via monit itself by calling <code>monit foo start</code>/<code>monit foo stop</code>. However having OpenRC as a common point for services control is a good idea.</p>
<p>All the code available on s-vision branch (https://github.com/qnikst/openrc/compare/s-vision) and will be merged to mainline after some discussion with other developers and administrators that have a good experience with running monit.</p>
<p>In order to put service under monit control one need:</p>
<ol style="list-style-type: decimal">
<li><p>Run monit under inittab control (or other low level s-vision subsystem). This can be done by adding:</p>
<pre><code>MO:2345:respawn:/usr/bin/monit -Ic /etc/monitrc</code></pre></li>
</ol>
<p>to inittab</p>
<ol start="2" style="list-style-type: decimal">
<li><p>Add temporary config path under monit control (/etc/monitrc)</p>
<pre><code>INCLUDE /run/openrc-monit/*</code></pre></li>
<li><p>Create control file for service under <code>/etc/conf.d/monit-files/servicename</code></p></li>
<li><p>Add s-vision module to conf.d file, i.e.</p>
<pre><code>rc_supervise_module=&quot;monit&quot;
rc_monit_type=&quot;file&quot;</code></pre></li>
</ol>
<p>When you will trigger service start it will check that it is supervised, copy all related files to the temporary config path, and then call <code>monit start service</code>, that will trigger file once again, but init will understand that it is monitored, and start service as usual.</p>
<p><span class="label label-warning"> Update: </span> the idea is just to hook up into <code>start_post</code> all call <code>monit restart</code> and <code>monit monitor</code> from there.</p>
<h1 id="future-work">Future work</h1>
<p>There are a couple of work to be done before merging:</p>
<ol style="list-style-type: decimal">
<li><p>Introduce other <code>monit_types</code> like:</p>
<ul>
<li>simple - where basic control file generated automatically on the fly</li>
<li>native - where existing configuration can be reused.</li>
</ul></li>
<li><p>Understand if it possible to run runscript only once</p></li>
<li><p>Cleanup code</p></li>
<li><p>Export general API that other s-vision subsystems can use</p></li>
</ol>
<p>All comments are welcome</p>]]></summary>
</entry>
<entry>
    <title>Basic pathfinding</title>
    <link href="http://qnikst.github.com/posts/2013-09-08-pathfinding.html" />
    <id>http://qnikst.github.com/posts/2013-09-08-pathfinding.html</id>
    <published>2013-09-08T00:00:00Z</published>
    <updated>2013-09-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div style="float:right">
<strong>Updates:</strong><br />2013-09-09: fixes by <span class="citation">@qrilka</span>
</div>
<p>In this post I’ll review basic approach to pathfinding using functional approach. It possible that this post doesn’t contain the best approach and all other solutions are welcome.</p>
<div class="row">
<div class="span8">
<p>On the right you can see example of a simple map.</p>
<p>Here is a list of imports. I need it because this is pure lhs file that can be <a href="/posts/2013-09-08-pathfinding.lhs">downloaded</a> and executed in ghci, so you can skip it.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Data.List</span>
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Data.Monoid</span>
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Data.Map</span> (<span class="dt">Map</span>)
<span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Data.Set</span> (<span class="dt">Set</span>)
<span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span>
<span class="ot">&gt;</span> <span class="kw">import           </span><span class="dt">Data.Function</span></code></pre>
<p>We will solve simple task of finding the shortest path from one location to another (from 5 to 1). As a first step lets introduce some basic types. Most of them are just type synonyms:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Loc</span>     <span class="fu">=</span> <span class="dt">Int</span>                      <span class="co">-- Location</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Dist</span>    <span class="fu">=</span> <span class="dt">Int</span>                      <span class="co">-- Distance</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">History</span> <span class="fu">=</span> [<span class="dt">Loc</span>]                    <span class="co">-- History</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">LMap</span>    <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">Loc</span> [(<span class="dt">Loc</span>,<span class="dt">Dist</span>)]     <span class="co">-- map</span>
<span class="ot">&gt;</span> <span class="co">-- here is example of the map</span>
<span class="ot">&gt; testMap ::</span> <span class="dt">LMap</span>
<span class="ot">&gt;</span> testMap <span class="fu">=</span> Map.fromList [(<span class="dv">1</span>,[(<span class="dv">2</span>,<span class="dv">5</span>),(<span class="dv">3</span>,<span class="dv">40</span>),(<span class="dv">5</span>,<span class="dv">100</span>)])
<span class="ot">&gt;</span>                        ,(<span class="dv">2</span>,[(<span class="dv">1</span>,<span class="dv">5</span>),(<span class="dv">3</span>,<span class="dv">10</span>),(<span class="dv">4</span>,<span class="dv">30</span>)])
<span class="ot">&gt;</span>                        ,(<span class="dv">3</span>,[(<span class="dv">1</span>,<span class="dv">40</span>),(<span class="dv">2</span>,<span class="dv">10</span>),(<span class="dv">5</span>,<span class="dv">20</span>),(<span class="dv">4</span>,<span class="dv">10</span>)])
<span class="ot">&gt;</span>                        ,(<span class="dv">4</span>,[(<span class="dv">2</span>,<span class="dv">30</span>),(<span class="dv">3</span>,<span class="dv">10</span>),(<span class="dv">5</span>,<span class="dv">5</span>)])
<span class="ot">&gt;</span>                        ,(<span class="dv">5</span>,[(<span class="dv">1</span>,<span class="dv">100</span>),(<span class="dv">3</span>,<span class="dv">20</span>),(<span class="dv">4</span>,<span class="dv">5</span>)])
<span class="ot">&gt;</span>                        ]</code></pre>
<br />
</div>
<div class="span4">
<img src="/images/posts/pathfinding/1.png" class="img-polaroid"/>
</div>
</div>
<p>## Basic algorithm</p>
<p>The basic idea of our solution is: ‘we need to create a list of the locations that is reachable from initial location sorted by distance’. You can this about this solution like we move in all possible directions at the same time. Then we can filter out final destination and find history related to the correct solution.</p>
<p>Terms: <code>frontier</code> - a list of possible locations with distance from the starting point, sorted by ascending distance.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Frontier0</span> <span class="fu">=</span> [(<span class="dt">Loc</span>, <span class="dt">Dist</span>)]</code></pre>
<p>So algorithm of generating result list will look like:</p>
<ol start="0" style="list-style-type: decimal">
<li>Add starting point with zero distance to the <code>frontier</code>.</li>
<li>Take the first location from the frontier. It will be our next <code>current location</code>.</li>
<li><code>p1</code> &lt;- get list of the locations reachable from the <code>current location</code> in one step.</li>
<li><code>p2</code> &lt;- sum distance to the current distance with the distance from the <code>current location</code> to each possible location from <code>p1</code>. Now we have a list of possible locations with distances from the starting point.</li>
<li>Add list of the new possible locations (<code>p2</code>) to the <code>frontier</code>.</li>
<li>goto 1.</li>
</ol>
<p>This algorithm will create a list of the possible destinations from the current point. The key of the algorithm is that frontier should be sorted by distance, so every time we will take closest position. It will guarantee that our algorithm will not diverge.</p>
<p>As you’ll see the solution will be a direct translation of literal description to the code. And that is a very nice property of haskell.</p>
<p>Here are few images describing process:</p>
<div class="row">
<div class="span4">
<img src="/images/posts/pathfinding/2.png" class="img-polaroid"/>
</div>
<div class="span8">
<p>Here is an image of the current state after step 0.</p>
<p>We added <code>5</code> to the frontier and then take it as a <code>current location</code>.</p>
<p>Now we have 3 new locations reachable: <code>1</code>, <code>3</code> and <code>4</code> (marked with red).</p>
And <code>4</code> with distance 5 will be moved to the result list (dashed). <br />
</div>
</div>
<div class="row">
<div class="span4">
<img src="/images/posts/pathfinding/3.png" class="img-polaroid"/>
</div>
<div class="span8">
<p>Here is next step.</p>
<p>We took <code>4</code> as a new current element.</p>
<p>We found 2 new reachabe locations: <code>2</code> and <code>3</code>.</p>
<p>We added current distance (5) to distances to the current locations and add them to the frontier.</p>
<code>&lt;&gt;</code> is a function that will merge and sort 2 lists. You can see result of the merge shown with dashed lines. <br />
</div>
</div>
<p>## Additional types.</p>
<p>Now we can review types that we will use.</p>
<p>### Candidate</p>
<p>All elements in a resulting set and a frontier are possible canditas for a solution, so they need to contain all temporary information (Distance) and information that we will need when we’ll filter out this solution (History). So we need to introduce a newtype for a candate, we use newtype here because we will need to redefine some properties otherwise we could use a tuple <code>(,,)</code>:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Candidate</span> <span class="fu">=</span> <span class="dt">Candidate</span> (<span class="dt">Loc</span>,<span class="dt">Dist</span>,<span class="dt">History</span>) <span class="kw">deriving</span> <span class="dt">Eq</span>   <span class="co">-- possible solution</span></code></pre>
<p>And helper functions:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; candidateLoc ::</span> <span class="dt">Candidate</span> <span class="ot">-&gt;</span> <span class="dt">Loc</span>
<span class="ot">&gt;</span> candidateLoc (<span class="dt">Candidate</span> (x,_,_)) <span class="fu">=</span> x
<span class="ot">&gt;</span> 
<span class="ot">&gt; candidateHist ::</span> <span class="dt">Candidate</span> <span class="ot">-&gt;</span> <span class="dt">History</span>
<span class="ot">&gt;</span> candidateHist (<span class="dt">Candidate</span> (_,_,x)) <span class="fu">=</span> x</code></pre>
<p>### Ascending list</p>
<p>As we have seen in the algorithm resulting list and frontier are ascending lists. So we may introduce special type that will preserve this property. This will help us to avoid additional mistakes, and can help with undestanding of our solution. This type is isomorphic to the List, however we can’t just use a newtype as we shouldn’t unpack pure list from the AscList:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">AscList</span> a <span class="fu">=</span> (<span class="fu">:&lt;</span>) a (<span class="dt">AscList</span> a) <span class="fu">|</span> <span class="dt">Nil</span></code></pre>
<p>It’s easy to see that AscList forms a monoid with regard to <code>concat</code> operation, so we can use this information:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">AscList</span> a) <span class="kw">where</span>
<span class="ot">&gt;</span>   mempty <span class="fu">=</span> <span class="dt">Nil</span>
<span class="ot">&gt;</span>   mappend <span class="dt">Nil</span> b <span class="fu">=</span> b
<span class="ot">&gt;</span>   mappend a <span class="dt">Nil</span> <span class="fu">=</span> a
<span class="ot">&gt;</span>   mappend a&#39;<span class="fu">@</span>(a <span class="fu">:&lt;</span> as) b&#39;<span class="fu">@</span>(b <span class="fu">:&lt;</span> bs)
<span class="ot">&gt;</span>      <span class="fu">|</span> a <span class="fu">&lt;</span> b <span class="fu">=</span> a <span class="fu">:&lt;</span> (as <span class="fu">&lt;&gt;</span> b&#39;)
<span class="ot">&gt;</span>      <span class="fu">|</span> otherwise <span class="fu">=</span> b <span class="fu">:&lt;</span> (a&#39; <span class="fu">&lt;&gt;</span> bs)</code></pre>
<p>Introduce two helper functions:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- | create ascending list from arbitrary list</span>
<span class="ot">&gt; fromList ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">AscList</span> a
<span class="ot">&gt;</span> fromList <span class="fu">=</span> mconcat <span class="fu">.</span> map singleton 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | convert value to Ascending List</span>
<span class="ot">&gt; singleton ::</span> a <span class="ot">-&gt;</span> <span class="dt">AscList</span> a
<span class="ot">&gt;</span> singleton x <span class="fu">=</span> x <span class="fu">:&lt;</span> <span class="dt">Nil</span></code></pre>
<p>In order to use Candidates in an AscList we need to introduce ordering on the Candidates:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Candidate</span> <span class="kw">where</span>
<span class="ot">&gt;</span>     compare (<span class="dt">Candidate</span> (_,d1,_)) (<span class="dt">Candidate</span> (_,d2,_)) <span class="fu">=</span> compare d1 d2</code></pre>
<p>Now we can guarantee that lists are properly ordered.</p>
<p>### Builder seed.</p>
<p>In order to create list we will use <code>unfoldr :: (b -&gt; Maybe (a, b)) -&gt; b -&gt; [a]</code> combinator. On each step we will create one new element and return new seed. So we will need to store frontier in the seed. Additionaly we will use one optimization: we will store a list of visited locations (that exists in result array) and we will filter out locations that we have visited, so we need to store a set of location. So resulting type will look like:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Visited</span> <span class="fu">=</span> <span class="dt">Set</span> <span class="dt">Loc</span>                  <span class="co">-- visited locations</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Seed</span> <span class="fu">=</span> (<span class="dt">AscList</span> <span class="dt">Candidate</span>,<span class="dt">Visited</span>) <span class="co">-- seed of the algorithm</span></code></pre>
<p>## Solver</p>
<p>Now we are ready to introduce our solver:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; solve ::</span> <span class="dt">LMap</span>       <span class="co">-- ^ map</span>
<span class="ot">&gt;</span>       <span class="ot">-&gt;</span> <span class="dt">Loc</span>        <span class="co">-- ^ finish location</span>
<span class="ot">&gt;</span>       <span class="ot">-&gt;</span> <span class="dt">Loc</span>        <span class="co">-- ^ start location</span>
<span class="ot">&gt;</span>       <span class="ot">-&gt;</span> <span class="dt">History</span>
<span class="ot">&gt;</span> solve mp finish <span class="fu">=</span> reverse
<span class="ot">&gt;</span>                 <span class="fu">.</span> (finish<span class="fu">:</span>)     <span class="co">-- we need to add finish place to the list</span>
<span class="ot">&gt;</span>                 <span class="fu">.</span> candidateHist <span class="co">-- we are interested in history only</span>
<span class="ot">&gt;</span>                 <span class="fu">.</span> head          <span class="co">-- we need only first solution</span>
<span class="ot">&gt;</span>                 <span class="fu">.</span> filter ((<span class="fu">==</span>finish) <span class="fu">.</span> candidateLoc)  <span class="co">-- take last result</span>
<span class="ot">&gt;</span>                 <span class="fu">.</span> unfoldr go    <span class="co">-- generate list of candidates using frontier</span>
<span class="ot">&gt;</span>                 <span class="fu">.</span> initial       <span class="co">-- initialize frontier using starting point</span>
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;</span>     initial i <span class="fu">=</span> (singleton <span class="fu">$</span> <span class="dt">Candidate</span> (i,<span class="dv">0</span>,[]),Set.empty)</code></pre>
<p>In go we need to guarantee that current seed in greater (using Candidate’s ordering) that any other element in list. We can guarantee it because:</p>
<ol start="0" style="list-style-type: decimal">
<li>when we have no elements in list we use first candidate with zero distance</li>
<li>all elements in frontier has length &gt; than current location. because we use AscList.</li>
<li>all possible locations from current location &gt; than current location as their distance is (current location distance + x, where x ≥ 0).</li>
</ol>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;     go ::</span> <span class="dt">Seed</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Candidate</span>,<span class="dt">Seed</span>)
<span class="ot">&gt;</span>     go (<span class="dt">Nil</span>,_) <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>     go ((<span class="dt">Candidate</span> (x,d,h) <span class="fu">:&lt;</span> xs),visited) <span class="fu">=</span>
<span class="ot">&gt;</span>        <span class="kw">case</span> Map.lookup x mp <span class="kw">of</span>  <span class="co">-- read possible locations from map</span>
<span class="ot">&gt;</span>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> go (xs,visited)       <span class="co">-- if thre is no destinaction proceed with next element</span>
<span class="ot">&gt;</span>          <span class="dt">Just</span> ls <span class="ot">-&gt;</span> <span class="kw">let</span> ls&#39;   <span class="fu">=</span> fromList  <span class="co">-- generate AscList from current position</span>
<span class="ot">&gt;</span>                               <span class="fu">.</span> map (\(yl,yd) <span class="ot">-&gt;</span> <span class="dt">Candidate</span> (yl,yd<span class="fu">+</span>d,x<span class="fu">:</span>h))  <span class="co">-- increment distance (see 2.)</span>
<span class="ot">&gt;</span>                               <span class="fu">.</span> filter ((<span class="ot">`Set.notMember`</span> visited) <span class="fu">.</span> fst) <span class="fu">$</span> ls <span class="co">-- remove elements that we have visited</span>
<span class="ot">&gt;</span>                     <span class="kw">in</span> <span class="dt">Just</span> ( <span class="dt">Candidate</span> (x,d,h)
<span class="ot">&gt;</span>                               , (ls&#39; <span class="fu">&lt;&gt;</span> xs, Set.insert x visited))</code></pre>
<p>Yachoo! we have a solver. However it will work badly on the big maps and we need to use more advanced methods, like A<up>*</up>. But we need to fix Candidate ordering function.</p>
<p>I’ve heard that it is possible to use comonad approach to solve this problem however I couldn’t find any example of this approach.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> test <span class="fu">=</span> solve testMap <span class="dv">5</span> <span class="dv">1</span></code></pre>
<p>as a result we will have [5,4,3,2,1]. That is correct solution.</p>]]></summary>
</entry>
<entry>
    <title>Сериализация структур данных в Haskell.<br/> Часть 1: типы данных</title>
    <link href="http://qnikst.github.com/posts/2013-09-06-serialization-p1.html" />
    <id>http://qnikst.github.com/posts/2013-09-06-serialization-p1.html</id>
    <published>2013-09-06T00:00:00Z</published>
    <updated>2013-09-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div style="float:right; width:200px">
<strong>Updates:</strong><br /> 2013-09-06: исправлены ошибки в тексте (спасибо qrilka)
</div>
<p><em>У меня тут в черновиках завалялась старый пост про сериализацию стуктур данных в haskell, доводить её до ума и продолжать мне немного лень, но если будет интересно то могу продолжать. Изначально серия статей предполагалась одновременно с доведением до ума пакета <a href="https://github.com/qnikst/strictput">strictput</a></em></p>
<p>Этим постом я хочу начать небольшую серию статей про сериализацию данных в Haskell. и описание библиотек их реализующих.</p>
<h1 id="типы-данных">Типы данных</h1>
<p>Перед тем как рассматривать непосредственно существующие системы сериализации и сопутсвующие им алгоритмы нужно рассмотреть типы данных, в которые можно сериализовать стуктуры. Это позволит упростить описание самой сериализации, а так же улучшит понимание низкого уровня задачи.</p>
<p>Сама задача сериализации может возникать в двух случаях:</p>
<ol style="list-style-type: decimal">
<li>Взаимодействие с внешним рантаймом, например FFI;</li>
<li>Взаимодействие с внешним миром (IPC, передача в сеть и т.д.)</li>
</ol>
<p>Разница между этими задачами заключается в том, что в первом случае, данные находятся в пространстве одного процесса (группы процессов), а во втором — в разных, и там будет произведено их копирование (существуют варианты, при которых копирование произведено не будет, но их мы оставим в стороне). В связи с этим структуры данных для варинта 1 не должны быть перемещены GC при сборке мусора, поскольку сериализация главным образом интересна нам для второго сценария, то мы не будем посвящать много времени рассмотрению непереносимых (pinned) структур, а будем только отмечать данное свойство.</p>
<h2 id="c-интерфейс">‘C’ интерфейс</h2>
<p>При взаимодействии с файлами или сетью для передачи бинарных данных в C принятно использовать пару “указатель, размер данных”, которая описывает откуда брать данные и сколько. Существуют более интересные варианты для векторной записи (семейство функций read/writev), в этом случае используется массив структур:</p>
<p>struct iovec { void *iov_base; size_t iov_len; }</p>
<p>в некоторых типах данных можно использовать данный подход, что позволит повысить их производительность, но об этом будет сказано отдельно.</p>
<p>Данный интерфейс может быть изображен в haskell как (# Addr#,CSize #) но крайне не рекомендуется так делать, поскольку это сильно усложнит работу с данными, при этом не принося выгоды, поскольку во многих случаях компилятор может преобразовать структуру к виду аналогичному данному.</p>
<p>Для данных, которые являются строковыми в C часто ещё использются null-terminated строки</p>
<h3 id="типы-haskell-соотвествующие-c-интерфейсу">Типы haskell соотвествующие C интерфейсу</h3>
<p>В haskell существуют следующие типы соответсующие указателям в C:</p>
<h4 id="addr">Addr#</h4>
<p>Addr# - unlifted unpacked тип данных являющийся указателем. Стоит напомнить, что данный тип является строгим по построению. С помощью данного типа можно обращаться напрямую к данным внутри примитивных частей программы. Функции для работы с этим типом есть в GHC.Prim (пакет ghc-prim) и Control.Primitive (пакет primitive). Обычно использовние Addr# не нужно, поскольку компилятор умеет приводить приводить работу к данному типу (за это отвечает анализатор строгости).</p>
<h4 id="ptr">Ptr</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Ptr</span> a <span class="fu">=</span> <span class="dt">Ptr</span> (<span class="dt">Addr</span><span class="st">#)</span></code></pre>
<p>Типизированная обертка над Addr (lifted, unpacked по умолчанию (изменится в ghc 7.8)), с помощью данного типа данных можно работать с указателями в “обычном” haskell коде. В подавляющем большинстве случаев ленивость и boxing убираются компилятором. Данный тип не “держит” содержимое на которое указывает и не защищает его от сборки GC.</p>
<p>Функции для работы с указателями предоставляются модулем ‘Foreign.Ptr’</p>
<h4 id="foreignptr">ForeignPtr</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ForeignPtr</span> <span class="fu">=</span> <span class="dt">ForeignPtr</span> <span class="dt">Addr</span><span class="st"># ForeignPtrConents</span></code></pre>
<p>Указатель, к которому можно привязывать финализаторы: действие которое должно быть выполнено как только не осталось ссылок на ForeignPtr из кода.</p>
<h2 id="общее-описание-структур-данных">Общее описание структур данных</h2>
<h3 id="cstringcstring-len">CString/CString Len</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">type</span> <span class="dt">CString</span> <span class="fu">=</span> <span class="dt">Ptr</span> <span class="dt">CChar</span> <span class="co">-- Defined in `Foreign.C.String`</span>
    <span class="kw">type</span> <span class="dt">CStringLen</span> <span class="fu">=</span> (<span class="dt">Ptr</span> <span class="dt">CChar</span>, <span class="dt">Int</span>) <span class="co">-- Defined in `Foreign.C.String`</span></code></pre>
<p>Тип данных соответсвующий null-terminated и length строкам соответсвенно, обычно используется для взаимодействия с C кодом, поскольку данный тип строк является pinned. Данный тип может быть эффективно использован для низкоуровнего взаимодействия с C кодом. Стоит отметить, что существует модификация CString (ACString) в которой выделение происходит на стеке, а не в куче.</p>
<p>Характеристики:</p>
<ul>
<li>строгий</li>
<li>небезопасный</li>
<li>не предоставляет возможности работы с данными</li>
</ul>
<p>Операции над типом:</p>
<ul>
<li>библиотеки haskell не предоставляют операций над данным типом данных</li>
</ul>
<h3 id="string">String</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">type</span> <span class="dt">String</span> <span class="fu">=</span> [<span class="dt">Char</span>]</code></pre>
<p>Очень широко используемый тип данных для внутреннего представления текcтовых строк в виде потока (Stream/Lazy-Cons-List). Данный тип предоставляется базовой библиотекой Prelude и поэтому весьма часто используется не по назначению. Поскольку структура данных является ленивой, то возможно создание бесконечных и цикличеких списков, а так же итеративное построение списка.</p>
<p>Характеристики:</p>
<ul>
<li>ленивый</li>
<li>безопасный</li>
<li>простой в использовании</li>
<li>можно использовать pattern matching без дополнительных расширений</li>
<li>очень низкая локальность данных (не кэш локальный)</li>
<li>высокий overhead по памяти для хранения списка (x+8+2)*n+8</li>
<li>очень низкая скорость работы</li>
<li>внутренний (не pinned тип)</li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.646">build/foldr deforestation</a></li>
<li>IO библиотека существует, но все методы являются ленивыми, что подвергается жесткой критике, рекомендуется использовать не ленивый ввод-вывод, а итеративные библиотеки такие как pipes, conduit, или iteratee.</li>
</ul>
<p>Build/forldr deforestation позволяет не создавать списки в том случае, если это без этого можно обойтись, например, в случаях, если списки играют роль “клея” между операциями,.</p>
<p>Операции над структурой данных:</p>
<ul>
<li>size: O(N) /N прыжков по памяти/ const по памяти</li>
<li>a <code>append</code> b: O(size a), O(size a) выделяется строка O(size a), ‘a’ может быть освобождена.</li>
<li>a +: b -&gt; O(1),</li>
<li>a :+ b -&gt; O(size a)</li>
</ul>
<p>Все операции изменяющие структуру данных пересоздают структуру слева от списка.</p>
<h3 id="word8">[Word8]</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">data</span> [] a <span class="fu">=</span> [] <span class="fu">|</span> a <span class="fu">:</span> [a]</code></pre>
<p>Аналог String для бинарных типов данных, к данному типу применяемы все пункты относящиеся к String, кроме того, что нету возможностей работы с вводом выводом.</p>
<h3 id="text">Text</h3>
<p>Современный внутренний тип для предствления строковых данных. Однако рассмотрение данного типа выходит за рамки поста.</p>
<h3 id="bytestring">ByteString</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">data</span> <span class="dt">ByteString</span> <span class="fu">=</span> <span class="dt">PS</span> 
          <span class="ot">{-# UNPACK #-}</span> (<span class="dt">ForeignPtr</span> <span class="dt">Word8</span>) 
          <span class="ot">{-# UNPACK #-}</span> <span class="dt">Int</span> 
          <span class="ot">{-# UNPACK #-}</span> <span class="dt">Int</span></code></pre>
<p>Данная структура обощает представление данных CStringLen добавляя в него параметр offset, что позволяет сильно расширить круг операций, которые доступны и безопасны. Для данного типа вся работа с памятью скрыта и пользовател предоставляется чистый и безопасный интерфейс для работы.</p>
<p>Размер структуры ~16байт+выделенная память, она является полностью строгой.</p>
<p>Данный тип работает с pinned memory посредством libc вызовов и предоставляет быстрый интерфейс для работы с бинарными данными. Операции не требующие изменения самих данных (take,drop) создают новый заголовок O(1), 8 Byte располагающийся в памяти RTS (relocable). Операции требующие изменения данных создают новую строку. Данная структура данных не поддерживает deforestation, но является самой эффективной структурой данных для хранения строк, которые должны быть прочитаны и не изменяются.</p>
<p>То, что каждый из блоков данных содержит указатель на начало выделенной памяти позволяет обходиться без дополнительного копирования структуры удаляя её в том случае, если на неё никто не ссылается.</p>
<h3 id="lazy-bytestring">Lazy ByteString</h3>
<p>data ByteString = Empty | Chunk !Internal.ByteString ByteString</p>
<p>Как можно увидеть данная структура изоморфна списку байтстрок, однако есть существенное отличие: внутри каждого чанка существует не произвольная строка, а строка определенного размера. (64k)</p>
<h2 id="перевод-типов-данных-друг-в-друга">Перевод типов данных друг в друга</h2>
<p>Для того, чтобы показать как перечисленные типы данных переходят друг в друга, в конце поста я привел абсолютно невоспринимаемую картинку (кто хочет може предложить мне более адекватный вариант).</p>
<p>При переводе типов из одного в другой нужно следить за следующими вещами:</p>
<ol style="list-style-type: decimal">
<li>алгоритмическая сложность операции;</li>
<li>размер выделяемых структур данных;</li>
<li>энергичность/ленивость операции;</li>
<li>безопасность операции.</li>
</ol>
<p>С первым пунктом все важно, второй тоже важен, так как агрессивное использование памяти существенно может изменить поведение программы относительно ожидаемого. То же относится и к ленивости, в этом случае нужно понимать, какие плюсы идут от ленивости, и не может ли произойти каскадное “форсирование” вычислений в тот момент, когда этого допускать нельзя.</p>
<p>С безопасностью операций дело обстоит интереснее, в том случае если мы передаем выделенную память вне рантайма Haskell, мы не можем гарантировать чистоту данной структуры, так как внешнее окружениме может изменять память как хочет. Обычно для сохранения чистоты в рантайм передается не сама структура, а её копия ’useAs*’. В этом случае нужно понимать, что данный подход приводит к увеличению сложности алгоритма и дополнительной нагрузке на память.</p>
<p>Картинка кликабельна: <a href="/images/posts/parser-1/1.png" target="_blank"><img src="/images/posts/parser-1/1.png"/></a></p>]]></summary>
</entry>
<entry>
    <title>My ghci</title>
    <link href="http://qnikst.github.com/posts/2013-09-04-my-ghci.html" />
    <id>http://qnikst.github.com/posts/2013-09-04-my-ghci.html</id>
    <published>2013-09-04T00:00:00Z</published>
    <updated>2013-09-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div style="float:right;width:200px;font-size:0.7em">
<strong>Updates:</strong><br />2013-09-05: add link to dotfile
</div>
<p>Here is small collection of my ghci scripts taken from different places. For complete file see my <a href="http://github.com/qnikst/dotfiles/ghc/ghci">dotfiles</a>.</p>
<h2 id="pointfree">Pointfree</h2>
<p>Convert expression into <a href="http://www.haskell.org/haskellwiki/Pointfree">pointfree</a> style. You need to have <a href="http://hackage.haskell.org/package/pointfree">pointree package</a> installed in order to use this function (in case of Gentoo run <code>emerge dev-haskell/pointfree</code>).</p>
<pre><code>-- pointfree
:def pf \str -&gt; return $ &quot;:! pointfree \&quot;&quot; ++ str ++ &quot;\&quot;&quot;</code></pre>
<h2 id="haskell-docs">Haskell-docs</h2>
<p>Show documentation on given function. In order to use it you need to intall <a href="http://hackage.haskell.org/package/haskell-docs">haskell-doc package</a> and built documentation for packages.</p>
<p>In Gentoo case: 1. echo ‘dev-haskell/* docs’ &gt;&gt; /etc/portage/package.use 2. <code>emerge dev-haskell/haskell-docs</code></p>
<pre><code>-- documentation
:def doc \input -&gt; return (&quot;:!haskell-docs &quot; ++ input)</code></pre>
<p>The format is following: <modulename> <name> [<package name>]</p>
<blockquote>
<p>:doc System.IO getContents base The getContents operation returns all user input as a single string, which is read lazily as it is needed (same as hGetContents stdin).</p>
</blockquote>
<h2 id="ghc-vis">GHC-Vis</h2>
<p>A great tool to show how expressions will be presented in memory. You can use it in order to understand your data structure and laziness/strictness of expressions. As usual you need to install <a href="http://hackage.haskell.org/package/ghc-vis">ghc-vis package</a>. Documentation for package (nice pictures included): http://felsin9.de/nnis/ghc-vis/</p>
<pre><code>-- ghc-vis
:script //usr/share/ghc-vis-0.7.1/ghc-7.6.3/ghci</code></pre>
<h2 id="hoogle">Hoogle</h2>
<p>To enable searching with hoogle (either local or global) you can install <a href="http://hackage.haskell.org/package/hoogle">hoogle package</a>.</p>
<pre><code>:def hoogle \str -&gt; return $ &quot;:! hoogle --count=15 \&quot;&quot; ++ str ++ &quot;\&quot;&quot;</code></pre>
<h2 id="prompt">Prompt</h2>
<p>To hide a big list of imported modules and have a nice look’n’feel you can change you ghci prompt.</p>
<pre><code>:set prompt &quot;λ&gt; &quot;</code></pre>
<p>To see list of imported modules you can type: <code>:show imports</code>.</p>]]></summary>
</entry>
<entry>
    <title>Adding license notes to blog pages.</title>
    <link href="http://qnikst.github.com/posts/2013-08-23-licenses-notes-in-hakyll.html" />
    <id>http://qnikst.github.com/posts/2013-08-23-licenses-notes-in-hakyll.html</id>
    <published>2013-08-23T00:00:00Z</published>
    <updated>2013-08-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve finally manged to create configurable license notes for each article:</p>
<p>To do it you need to add additional context:</p>
<pre><code>licenseCtx :: Context a
licenseCtx = field &quot;license&quot; $ \item -&gt; do
    metadata &lt;- getMetadata $ itemIdentifier item
    return $ case M.lookup &quot;license&quot; metadata of
                    Nothing -&gt; &quot;&quot;
                    Just m -&gt; case M.lookup (trim m) licenses of
                                      Nothing -&gt; &quot;unknown license&quot;
                                      Just (u,i) -&gt; &quot;&lt;a href=\&quot;&quot;++u++&quot;\&quot;&gt;&lt;img src=\&quot;&quot;++i++&quot;\&quot;/&gt;&lt;/a&gt;&quot;
  where
    trim = reverse . dropWhile isSpace . reverse . dropWhile isSpace


licenses = m.fromlist 
    [ (&quot;by&quot;,       ( &quot;http://creativecommons.org/licenses/by/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by/3.0/88x31.png&quot;))
    , (&quot;by-sa&quot;,    ( &quot;http://creativecommons.org/licenses/by-sa/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by-sa/3.0/88x31.png&quot;))
    , (&quot;by-nd&quot;,    ( &quot;http://creativecommons.org/licenses/by/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by/3.0/88x31.png&quot;))
    , (&quot;by-nc&quot;,    ( &quot;http://creativecommons.org/licenses/by/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by/3.0/88x31.png&quot;))
    , (&quot;by-nc-sa&quot;, ( &quot;http://creativecommons.org/licenses/by-nc-sa/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png&quot;))
    , (&quot;by-nc-nd&quot;, ( &quot;http://creativecommons.org/licenses/by-nc-nd/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png&quot;))]</code></pre>
<p>Currently only cc-* licenses are added, and but it will be possible to add another.</p>
<p>To apply license to template just add <code>$license$</code> and add context:</p>
<pre><code>  loadAndApplyTemplate &quot;templates/post.html&quot; (licenseCtx &lt;&gt; postCtx tags)</code></pre>
<p>For my blog I’m trying to use:</p>
<ul>
<li>by - for announces and physics</li>
<li>by-nc-sa - for documentation like posts</li>
<li>by-nc-nd - for personal posts</li>
</ul>]]></summary>
</entry>
<entry>
    <title>Supervision in pure OpenRC using cgroup subsystem.</title>
    <link href="http://qnikst.github.com/posts/2013-08-08-openrc-supervision-using-cgroups.html" />
    <id>http://qnikst.github.com/posts/2013-08-08-openrc-supervision-using-cgroups.html</id>
    <published>2013-08-08T00:00:00Z</published>
    <updated>2013-08-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div style="float:right;width:200px;font-size:0.5em;">
Updates:
<ul>
      <li> 
2008.08.09 - small corrections, acknowledgement section added
</li>
    </ul>
  
Versions:
<ul>
      <li> 
Kernel &gt;=2.6.24 &amp;&amp; &lt;=3.10
</li>
      <li> 
Openrc 0.12
</li>
    </ul>
</div>
<h1 id="abstract">Abstract</h1>
<p>This post describes how it’s possible to improve cgroup support in OpenRC to support user hooks, and shows how to create a basic supervision daemon based on cgroups.</p>
<p>This post describes OpenRC-0.11/0.12_beta and some things may change in later versions. Please notify me to post updates here if you find such changes.</p>
<h1 id="introduction">Introduction</h1>
<h2 id="the-problem">The problem</h2>
<p>In a general case, there are many services that should be run and restarted when they fail. There are many other subproblems like when should we restart services and when not. Many existing systems can solve those issues but have different trade-offs. In this post I’ll try to present a simple mechanism that allows to create basic supervision and other nice things.</p>
<h2 id="idea">Idea</h2>
<p>The Linux kernel provides a mechanism to track groups of processes - <code>Cgroups</code>. All process children will put in the process’s cgroup. And it’s easy to track cgroups from user space. If you want to understand cgroups better you may read <a href="https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt">cgroups documentation</a>. Cgroups provide a way of setting limits and controlling groups, that is also useful but at this moment it’s out of the scope.</p>
<p>When all processes in a group die, kernel will call ‘release_notify_agent’ script, proving the path to the cgroup. This may be used to remove empty cgroups and take additional actions.</p>
<p>Idea is that we can check service state to decide if we should restart it.</p>
<h1 id="details">Details</h1>
<h2 id="implementation">Implementation</h2>
<p>Here are improvements and files that should be added to OpenRC to provide the required functionality.</p>
<h3 id="restart-daemon">Restart daemon</h3>
<p>First we need to create a daemon to restart a services, because we can’t start service from agent, as it has <code>PF_NO_SETAFFINITY</code> flag and thus cgroups will not work for any of its children. So let’s have a very simple daemon, it will be extended in the next posts</p>
<pre><code> #!/bin/sh
 if [ $# -lt 1 ] ; then
    echo &quot;usage is $0 &lt;path to fifo&gt;&quot; 
    exit 1
 fi
 
 while [ -p $1 ] ; do 
    while read line ; do
       echo &quot;rc-service $line&quot;;
    done &lt;$1
 done</code></pre>
<h3 id="release-notify-agent-improvement">Release notify agent improvement</h3>
<p>The current release notify agent is very simple; so we extend it to support user hooks. There are some different ways to do it:</p>
<ol style="list-style-type: decimal">
<li>Add it to the service state. (Requires hook in the init script)</li>
<li>Create static structure in a filesystem</li>
</ol>
<p>We will use 2. as it’s simpler and doesn’t lead to a init script hacking. We will have following file structure:</p>
<p>In /etc/conf.d/cgroups there will be hooks, ‘cgroup-release’ for default one ‘service-name.cgroup-release’ for service specific one. Here is my example.</p>
<pre><code>/etc/conf.d/cgroups/
|-- cgroup-release                                            # default release hook
|-- foo.cgroup-release -&gt; service-restart.cgroup-release      # service release hook
`-- service-restart.cgroup-release                            # example script
</code></pre>
<p>This approach doesn’t scale on a multiple hooks but it may be improved after discussion with upstream. Each script can return $RC_CGROUP_CONTINUE exit code, so cgroup will not be deleted after a hook.</p>
<p>Here is a script itself (newer version can be found on <a href="https://github.com/qnikst/openrc/blob/cgroups.release_notification/sh/cgroup-release-agent.sh.in">github</a>):</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="ot">PATH=</span>/bin:/usr/bin:/sbin:/usr/sbin
<span class="ot">cgroup=</span>/sys/fs/cgroup/openrc
<span class="ot">cgroup_rmdir=</span>1
<span class="ot">RC_SVCNAME=$1</span>
<span class="ot">RC_CGROUP_CONTINUE=</span>3; 
<span class="kw">export</span> <span class="ot">RC_CGROUP_CONTINUE</span> <span class="ot">RC_SVCNAME</span> <span class="ot">PATH</span>;

<span class="kw">if [</span> <span class="ot">-n</span> <span class="st">&quot;</span><span class="ot">${RC_SVCNAME}</span><span class="st">&quot;</span><span class="kw"> ]</span> ; <span class="kw">then</span>
  <span class="ot">hook=</span>@SYSCONFDIR@/conf.d/cgroups/<span class="ot">${RC_SVCNAME}</span>.cgroup-release
 <span class="kw"> [</span> <span class="ot">-x</span> <span class="st">&quot;</span><span class="ot">$hook</span><span class="st">&quot;</span><span class="kw"> ]</span> <span class="kw">||</span> <span class="ot">hook=</span>@SYSCONFDIR@/conf.d/cgroups/cgroup-release;
  <span class="kw">if [</span> <span class="ot">-x</span> <span class="st">&quot;</span><span class="ot">$hook</span><span class="st">&quot;</span><span class="kw"> ]</span>; <span class="kw">then</span>
    <span class="st">&quot;</span><span class="ot">$hook</span><span class="st">&quot;</span> <span class="kw">cleanup</span> <span class="st">&quot;</span><span class="ot">$RC_SVCNAME</span><span class="st">&quot;</span> <span class="kw">||</span> <span class="kw">case</span> <span class="ot">$?</span><span class="kw"> in</span> <span class="ot">$RC_CGROUP_CONTINUE</span><span class="kw">)</span> <span class="ot">cgroup_rmdir=</span>0<span class="kw">;;</span> <span class="kw">esac</span> ;
  <span class="kw">fi</span>
<span class="kw">fi</span>

<span class="kw">if [</span> <span class="ot">${cgroup_rmdir}</span> <span class="ot">-eq</span> 1<span class="kw"> ]</span> <span class="kw">&amp;&amp; [</span> <span class="ot">-d</span> <span class="st">&quot;</span><span class="ot">${cgroup}</span><span class="st">/</span><span class="ot">$1</span><span class="st">&quot;</span><span class="kw"> ]</span>; <span class="kw">then</span>
  <span class="kw">for</span> <span class="kw">c</span> in /sys/fs/cgroup/*/<span class="st">&quot;openrc_</span><span class="ot">$1</span><span class="st">&quot;</span> <span class="kw">;</span> <span class="kw">do</span>
    <span class="kw">rmdir</span> <span class="st">&quot;</span><span class="ot">${c}</span><span class="st">&quot;</span>
  <span class="kw">done</span>;
  <span class="kw">rmdir</span> <span class="st">&quot;</span><span class="ot">$cgroup</span><span class="st">/</span><span class="ot">${1}</span><span class="st">&quot;</span>
<span class="kw">fi</span></code></pre>
<p>Restart service script. This script simply checks service state and if it’s 32 (service failed) then start a new instance and set <code>$RC_CGROUP_CONTINUE</code></p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#!/bin/sh</span>
<span class="co"># This script is run for service that need to be restarted</span>
<span class="co"># if it&#39;s last process leaves cgroup.</span>

<span class="ot">action=$1</span>
<span class="ot">service=$2</span>

<span class="kw">if [</span> cleanup <span class="ot">=</span> <span class="st">&quot;</span><span class="ot">$action</span><span class="st">&quot;</span><span class="kw"> ]</span> ; <span class="kw">then</span>

    <span class="kw">rc-service</span> <span class="ot">$service</span> status <span class="kw">&gt;</span> /dev/null
    <span class="kw">case</span> <span class="ot">$?</span><span class="kw"> in</span>
        32<span class="kw">)</span> 
        <span class="kw">/etc/init.d/</span><span class="ot">${service}</span> <span class="kw">-d</span> restart
        <span class="kw">exit</span> <span class="ot">$RC_CGROUP_CONTINUE</span>
                <span class="kw">;;</span>
        *<span class="kw">)</span> 
            <span class="kw">return</span> 0<span class="kw">;;</span>
    <span class="kw">esac</span>
<span class="kw">fi</span></code></pre>
<h2 id="other-solutions">Other solutions</h2>
<p>Generic supervision is quite a complicated problem as there are many conditions when we may suppose that our service failed, like:</p>
<ul>
<li>main process dies;</li>
<li>all service children die;</li>
<li>service does not write logs for some time;</li>
<li>large resource memory/cpu consuming;</li>
<li>service does not respond to control call;</li>
<li>log fd is closed.</li>
</ul>
<p>Some of the options can be translated to another, like large resource consuming can be translated to process death by setting correct limits. And process death (and in some cases even children deaths) can be tracked by log fd (in case of a process in background).</p>
<p>More complex hooks may be also needed, when deciding what to do with failed service, e.g. do not restart if it has failed many times in a short period of time.</p>
<p>So with all required features will be very complicated. So non-specialized subsystems address only a part of a problem domain. Here are some other examples of supervision systems:</p>
<ul>
<li>monit (full featured)</li>
<li>s6 (pid, fd based)</li>
<li>daemon-tools</li>
<li>angel</li>
<li>systemd (pid, cgroups based)</li>
<li>upstart (pid based)</li>
</ul>
<h1 id="future-work">Future work</h1>
<ol style="list-style-type: decimal">
<li>work on inclusion of a user hooks to OpenRC release agent.</li>
<li>improve restart script to track really dead services that can be restarted</li>
</ol>
<h1 id="conclusions-and-futher-work">Conclusions and futher work</h1>
<p>It’s possible to create a very simple and extensible supervision system based on OpenRC, by extending notification systems. Also there are more usecases for it, like:</p>
<ul>
<li>adding system wide notification mechanism via dbus</li>
<li>additional logging system</li>
</ul>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>I want to thank igli for code corrections and usefull tips, and Kirill Zaborsky for correcting lingual mistakes.</p>]]></summary>
</entry>
<entry>
    <title>Using queues in conduits</title>
    <link href="http://qnikst.github.com/posts/2013-04-11-using-tqueues-in-conduit.html" />
    <id>http://qnikst.github.com/posts/2013-04-11-using-tqueues-in-conduit.html</id>
    <published>2013-04-11T00:00:00Z</published>
    <updated>2013-04-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Sometime when you use conduit you need to split processes for example when you have CPU bound and IO bound tasks thus you will have better workload. Also you may need to get events from different sources concurrently, and for such purposes you may want to use <a href="http://hackage.haskell.org/package/stm-conduit">stm-conduit</a> library.</p>
<p>This library provides conduits over STM primitives:</p>
<ul>
<li><a href="http://hackage.haskell.org/packages/archive/stm-chans/1.3.1/doc/html/Control-Concurrent-STM-TMChan.html#t:TMChan">TMChans</a> - closable (finite) STM channels</li>
<li><a href="http://hackage.haskell.org/packages/archive/stm-chans/1.3.1/doc/html/Control-Concurrent-STM-TBMChan.html#t:TBMChan">TBMChans</a> - closable (finite) bounded STM channels</li>
<li><a href="http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/Control-Concurrent-STM-TQueue.html#t:TQueue">TQueue</a> - infinite STM Queues</li>
<li><a href="http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/Control-Concurrent-STM-TBQueue.html#t:TBQueue">TBQueue</a> - infinite bounded STM Queues</li>
</ul>
<p>and closable queues comming soon.</p>
<p>Here closable means that you can close a primitives outside it, so source will report that it is closed on the opposite infinite primitive will wait for an input forever, so you should use another conduit to handle end of a stream or send an asynchronous exception.</p>
<p>Bounded means that there is a limit of pending messages inside primitive and if that limit is reached any thread that wants to write to the primitive will be blocked on input. This is basically what you need to guarantee limited (or even constant) memory usage.</p>
<p>New primitive TQueue was added in stm-2.3 and provides shared amortized queue that is faster than TChan/Chan but doesn’t provide dupTChan, cloneTChan primitives.</p>]]></summary>
</entry>

</feed>
