<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - All posts</title>
    <link href="https://qnikst.github.io/rss.xml" rel="self" />
    <link href="https://qnikst.github.io" />
    <id>https://qnikst.github.io/rss.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2016-05-06T00:00:00Z</updated>
    <entry>
    <title>Solving one problem towards an open union</title>
    <link href="https://qnikst.github.io/posts/2016-06-19-on-the-way-to-unions.html" />
    <id>https://qnikst.github.io/posts/2016-06-19-on-the-way-to-unions.html</id>
    <published>2016-05-06T00:00:00Z</published>
    <updated>2016-05-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Recently on <a href="https://gitter.im/ruHaskell/forall">#ruHakell</a> gitter channel there was a question about how to make compiler happy. I managed to fix the problem, though it was not straightforward. Here I describe a problem and solution.</p>
<p>As the original code is not mine but <span class="citation">[@int-index]</span>(https://github.com/int-index) I may be not correct in description on an intent. Also I’ll not get deep into the details of the new extensions, because I may be not correct in all details.</p>
<p>The original code was <a href="">https://gist.github.com/int-index/c6b853351912d177cfcefd54678b27ff</a>. Copy here for the history:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeInType, GADTs, TypeFamilies #-}</span>

<span class="kw">import </span><span class="dt">Data.Kind</span> (<span class="dt">Type</span>)

<span class="kw">data</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">N</span>

<span class="kw">data</span> <span class="dt">Fin</span><span class="ot"> ::</span> <span class="dt">N</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">FZ</span><span class="ot"> ::</span> <span class="dt">Fin</span> (<span class="dt">S</span> n)
  <span class="dt">FS</span><span class="ot"> ::</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> <span class="dt">Fin</span> (<span class="dt">S</span> n)

<span class="kw">type</span> family <span class="dt">FieldCount</span> (<span class="ot">t ::</span> <span class="dt">Type</span>)<span class="ot"> ::</span> <span class="dt">N</span>

<span class="kw">type</span> family <span class="dt">FieldType</span> (<span class="ot">t ::</span> <span class="dt">Type</span>) (<span class="ot">i ::</span> <span class="dt">Fin</span> (<span class="dt">FieldCount</span> t))<span class="ot"> ::</span> <span class="dt">Type</span>

<span class="kw">data</span> <span class="dt">T</span>

<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">FieldCount</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))

<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">FieldType</span> <span class="dt">T</span> <span class="dt">FZ</span> <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">FieldType</span> <span class="dt">T</span> (<span class="dt">FS</span> <span class="dt">FZ</span>) <span class="fu">=</span> <span class="dt">Bool</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">FieldType</span> <span class="dt">T</span> (<span class="dt">FS</span> (<span class="dt">FS</span> <span class="dt">FZ</span>)) <span class="fu">=</span> <span class="dt">String</span></code></pre></div>
<p>And type instances didn’t typecheck with a very strange error:</p>
<pre><code>fieldtype.hs:19:27: error:
    • Expected kind ‘Fin (FieldCount T)’,
        but ‘&#39;FZ’ has kind ‘Fin (&#39;S n0)’
    • In the second argument of ‘FieldType’, namely ‘FZ’
      In the type instance declaration for ‘FieldType’</code></pre>
<p>I’m not able to explain why we have that error, and it looks like a bug to me, or that some <a href="https://ghc.haskell.org/trac/ghc/wiki/NewAxioms">axioms</a> prevents typechecker from inferring right types.</p>
<p>So my first solution was to break the task into simpler ones. First, is that it’s easy to write type function that returns field that is needed:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">FiledTypeI</span> (<span class="ot">t ::</span> <span class="dt">Type</span>) (<span class="ot">i ::</span> <span class="dt">N</span>)<span class="ot"> ::</span> <span class="dt">Type</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">FieldTypeI</span> <span class="dt">T</span> <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">FieldTypeI</span> <span class="dt">T</span> (<span class="dt">S</span> <span class="dt">Z</span>) <span class="fu">=</span> <span class="dt">Bool</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">FieldTypeI</span> <span class="dt">T</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)) <span class="fu">=</span> <span class="dt">String</span></code></pre></div>
<p>this works fine, we can check in ghci:</p>
<pre><code>*Main&gt; :kind! FieldTypeI T (S Z)
FieldTypeI T (S Z) :: *
= Bool</code></pre>
<p>Now we need to be able to convert <code>Fin N</code> to the raw <code>N</code>, this can be easily done with a closed type family:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">F2II</span> (<span class="ot">a ::</span> <span class="dt">Fin</span> n)<span class="ot"> ::</span> <span class="dt">N</span> <span class="kw">where</span>
  <span class="dt">F2II</span> (<span class="dt">FS</span> n) <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">F2</span> <span class="dt">II</span> n)
  <span class="dt">F2II</span> <span class="dt">FZ</span>     <span class="fu">=</span> <span class="dt">Z</span></code></pre></div>
<p>so far so good. Now we can check in the repl:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">FieldTypeI</span> <span class="dt">T</span> (<span class="dt">F2II</span> (<span class="dt">FS</span> <span class="dt">FZ</span><span class="ot"> ::</span> <span class="dt">Fin</span> (<span class="dt">FieldCount</span> <span class="dt">T</span>)))
<span class="dt">FieldTypeI</span> <span class="dt">T</span> (<span class="dt">F2II</span> (<span class="dt">FS</span> <span class="dt">FZ</span><span class="ot"> ::</span> <span class="dt">Fin</span> (<span class="dt">FieldCount</span> <span class="dt">T</span>)))<span class="ot"> ::</span> <span class="fu">*</span>
<span class="fu">=</span> <span class="dt">Bool</span></code></pre></div>
<p>At this point we may expect that everything is ok, and now we can just write a type synonym to hide ugliness:</p>
<pre><code>type DoesNotWork (t::Type) (i :: Fin (FieldCount t)) = FieldTypeI t (F2II i)</code></pre>
<p>Here we have all types known and all requred dependencies. But it doesn’t work:</p>
<pre><code>*Main&gt; :kind! DoesNotWork T (FS FZ)
DoesNotWork T (FS FZ) :: Type
= FieldTypeI T (F2II (&#39;FS &#39;FZ))</code></pre>
<p>even written as a typefamily</p>
<pre><code>type family DoesNotWork (t :: Type) (i :: Fin (FieldCount t) where
  DoesNotWork t i = FieldTypeI t (F2II i)</code></pre>
<p>Later invesigation showed that <code>t</code> and <code>FieldCount t</code> on the same side doesn’t work well.</p>
<p>So solution here is no remove them. One way is to introduce a <code>cast</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Cast</span> (<span class="ot">t ::</span> <span class="dt">N</span>) (<span class="ot">i ::</span> <span class="dt">Fin</span> n)<span class="ot"> ::</span> <span class="dt">Fin</span> t <span class="kw">where</span>
  <span class="dt">Cast</span> (<span class="dt">S</span> <span class="dt">Z</span>) <span class="dt">FZ</span> <span class="fu">=</span> <span class="dt">FZ</span>
  <span class="dt">Cast</span> (<span class="dt">S</span> n) <span class="dt">FZ</span> <span class="fu">=</span> <span class="dt">FZ</span>
  <span class="dt">Cast</span> (<span class="dt">S</span> n) (<span class="dt">FS</span> k) <span class="fu">=</span> <span class="dt">FS</span> (<span class="dt">Cast</span> n k)</code></pre></div>
<p>Now we can use this cast function to write a nice wrapper:</p>
<pre><code>type family FieldType (t :: Type) (i :: Fin p) where
  FieldType t i = FieldTypeI t (F2II (Cast (FieldCount t) i))</code></pre>
<p>And everything works!</p>
<pre><code>*Main&gt; :kind! FieldType T (FS FZ)
FieldType T (FS FZ) :: *
= Bool</code></pre>
<p>However, there are some problems with this solution as we have lost dependency between types <code>t</code> and <code>Fin (f t)</code>. This means that if we write unsupported index, we will not be warn with a nice message from the start, but we will fail to compute <code>FieldType</code> function, with possibly more scary error message.</p>]]></summary>
</entry>
<entry>
    <title>Создание объекта через замыкания (пост ответ)</title>
    <link href="https://qnikst.github.io/posts/2015-09-16-object-as-automaton.markdown.html" />
    <id>https://qnikst.github.io/posts/2015-09-16-object-as-automaton.markdown.html</id>
    <published>2015-09-15T00:00:00Z</published>
    <updated>2015-09-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>В целом тем кто читал <a href="https://www.cis.upenn.edu/~bcpierce/tapl/">TAPL</a> чтение данного поста не рекомендуется, так же тем кто хочет знать как делать правильно лучше сразу брать TAPL и читать его. Так же тут не описывается полноценное ООП, для этого можно посмотреть в сторону <a href="http://arxiv.org/abs/cs/0509027">Object Haskell</a>, где показывается вариант реализации через гетерогенные списки.</p>
<p>В одном из тредов на <a href="http://umnik.point.im/vhpti">point.im</a> возник вопрос, каким образом можно сделать “объект” (состояние и функции связанные с ним) с помощью функций.</p>
<p>Здесь и далее будет использоваться haskell и немного комментариев о других языках, так же будет использоваться подход идеоматичный для haskell, другие варианты тоже будут мельком обсуждены.</p>
<p>Итак нам как обычно потребуется немного расширений языка</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TypeFamilies #-}</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.IO</span></code></pre></div>
<p>Общая идея заключается в том, чтобы создать автомат (mealy machine), который на вход получает запросы, а на выходе дает результат (+ новую версию себя). Рассмотрим сначала простейший вариант:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">M1</span> a <span class="fu">=</span> <span class="dt">M1</span> {<span class="ot"> runM1 ::</span> forall b <span class="fu">.</span> a b <span class="ot">-&gt;</span> b }</code></pre></div>
<p>Тут мы создаем тип обёртку, над замыканием, которое принимает на вход запрос типа <code>a b</code> и отдает результат типа <code>b</code>. Таким образом объекты типизируются видом запросов, которые они могут обрабатывать. Можно записать простой пример запросов для системы логирования:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">LogLevel</span> <span class="fu">=</span> <span class="dt">Debug</span> <span class="fu">|</span> <span class="dt">Info</span> <span class="fu">|</span> <span class="dt">Warn</span> <span class="fu">|</span> <span class="dt">Error</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">LogRequest</span> a <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="dt">WriteLog</span><span class="ot"> ::</span> <span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">LogRequest</span> (<span class="dt">IO</span> ())
<span class="ot">&gt;</span>   <span class="dt">SetLevel</span><span class="ot"> ::</span> <span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">LogRequest</span> <span class="dt">LogObject</span>
<span class="ot">&gt;</span>   <span class="dt">GetLevel</span><span class="ot"> ::</span> <span class="dt">LogRequest</span> <span class="dt">LogLevel</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">LogObject</span> <span class="fu">=</span> <span class="dt">M1</span> <span class="dt">LogRequest</span></code></pre></div>
<p>Здесь мы имеем три типа запроса, первый - записал лог, создает действие типа <code>IO ()</code>, т.е. выполняет какой-то эффект, второе - обновляет уровень логирования возвращая новый обьект из текущего, и третье это чистое действие, получение уровня логирования из текущего.</p>
<p>Теперь мы можем создавать различне логгеры, например:</p>
<p>Для того, чтобы не делать копипаст создадим базовый логгер:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; dummyLogger ::</span> <span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">LogObject</span>
<span class="ot">&gt;</span> dummyLogger lvl <span class="fu">=</span> <span class="dt">M1</span> go <span class="kw">where</span>
<span class="ot">&gt;   go ::</span> <span class="dt">LogRequest</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span>   go <span class="dt">WriteLog</span>{} <span class="fu">=</span> error <span class="st">&quot;dummy logger: write log is not implemented&quot;</span>
<span class="ot">&gt;</span>   go (<span class="dt">SetLevel</span> l) <span class="fu">=</span> dummyLogger l
<span class="ot">&gt;</span>   go <span class="dt">GetLevel</span>     <span class="fu">=</span> lvl</code></pre></div>
<p>Пример</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; stdoutLogger0 ::</span> <span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">LogObject</span>
<span class="ot">&gt;</span> stdoutLogger0 lvl <span class="fu">=</span> <span class="dt">M1</span> go <span class="kw">where</span>
<span class="ot">&gt;   go ::</span> <span class="dt">LogRequest</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span>   go (<span class="dt">WriteLog</span> l s)
<span class="ot">&gt;</span>      <span class="fu">|</span> l <span class="fu">&gt;=</span> lvl <span class="fu">=</span> hPutStrLn stderr s
<span class="ot">&gt;</span>      <span class="fu">|</span> otherwise <span class="fu">=</span> return ()
<span class="ot">&gt;</span>   go (<span class="dt">SetLevel</span> l) <span class="fu">=</span> stdoutLogger0 l
<span class="ot">&gt;</span>   go <span class="dt">GetLevel</span> <span class="fu">=</span> runM1 (dummyLogger lvl) <span class="dt">GetLevel</span></code></pre></div>
<p>Абстрактные методы:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; baseLogger ::</span> (<span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ())
<span class="ot">&gt;</span>             <span class="ot">-&gt;</span> <span class="dt">LogLevel</span>
<span class="ot">&gt;</span>             <span class="ot">-&gt;</span> <span class="dt">LogObject</span>
<span class="ot">&gt;</span> baseLogger writeLog lvl <span class="fu">=</span> <span class="dt">M1</span> go <span class="kw">where</span>
<span class="ot">&gt;   go ::</span> <span class="dt">LogRequest</span> a <span class="ot">-&gt;</span> a <span class="co">-- очень важная строчка делающая компилятор счастливым</span>
<span class="ot">&gt;</span>   go (<span class="dt">WriteLog</span> l s) 
<span class="ot">&gt;</span>      <span class="fu">|</span> l <span class="fu">&gt;=</span> lvl <span class="fu">=</span> writeLog l s
<span class="ot">&gt;</span>      <span class="fu">|</span> otherwise <span class="fu">=</span> return ()
<span class="ot">&gt;</span>   go (<span class="dt">SetLevel</span> l) <span class="fu">=</span> baseLogger writeLog l
<span class="ot">&gt;</span>   go <span class="dt">GetLevel</span>     <span class="fu">=</span> lvl</code></pre></div>
<p>Наследование 1:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; stdoutLogger ::</span> <span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">LogObject</span>
<span class="ot">&gt;</span> stdoutLogger lvl <span class="fu">=</span> <span class="dt">M1</span> <span class="fu">$</span> go base <span class="kw">where</span>
<span class="ot">&gt;</span>   base <span class="fu">=</span> baseLogger (\_ s <span class="ot">-&gt;</span> hPutStrLn stderr s) lvl
<span class="ot">&gt;   go ::</span> <span class="dt">LogObject</span> <span class="ot">-&gt;</span> <span class="dt">LogRequest</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span>   go b s<span class="fu">@</span>(<span class="dt">WriteLog</span> <span class="dt">Error</span> _) <span class="fu">=</span> hPutStrLn stdout <span class="st">&quot;AAAAAAAAAAAAAAA!&quot;</span> <span class="fu">&gt;&gt;</span> runM1 b s
<span class="ot">&gt;</span>   go b s<span class="fu">@</span>(<span class="dt">SetLevel</span> l) <span class="fu">=</span> stdoutLogger l <span class="co">-- не удобно :)</span>
<span class="ot">&gt;</span>   go b s <span class="fu">=</span> runM1 base s</code></pre></div>
<p>Наследование 2:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">FileLogObject</span> <span class="fu">=</span> <span class="dt">M1</span> <span class="dt">FileLogRequest</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> family <span class="dt">Outer</span> a <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="dt">Outer</span> <span class="dt">LogObject</span> <span class="fu">=</span> <span class="dt">FileLogObject</span>
<span class="ot">&gt;</span>   <span class="dt">Outer</span> a         <span class="fu">=</span> a
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">FileLogRequest</span> a <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="dt">SetFile</span><span class="ot"> ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">FileLogRequest</span> <span class="dt">FileLogObject</span>
<span class="ot">&gt;</span>   <span class="dt">GetFile</span><span class="ot"> ::</span> <span class="dt">FileLogRequest</span> FilePath
<span class="ot">&gt;</span>   <span class="dt">AsLogObject</span><span class="ot"> ::</span> <span class="dt">LogRequest</span> a <span class="ot">-&gt;</span> <span class="dt">FileLogRequest</span> (<span class="dt">Outer</span> a)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fileLogger ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">FileLogObject</span>
<span class="ot">&gt;</span> fileLogger fp lvl <span class="fu">=</span> <span class="dt">M1</span> <span class="fu">$</span> go (base lvl) <span class="kw">where</span>
<span class="ot">&gt;</span>   base <span class="fu">=</span> baseLogger (\_ s <span class="ot">-&gt;</span> appendFile fp s)
<span class="ot">&gt;   go ::</span> <span class="dt">LogObject</span> <span class="ot">-&gt;</span> <span class="dt">FileLogRequest</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span>   go _ (<span class="dt">SetFile</span> fp&#39;) <span class="fu">=</span> fileLogger fp&#39; lvl
<span class="ot">&gt;</span>   go _ <span class="dt">GetFile</span>       <span class="fu">=</span> fp
<span class="ot">&gt;</span>   go b (<span class="dt">AsLogObject</span> s) <span class="fu">=</span> <span class="kw">case</span> s <span class="kw">of</span>
<span class="ot">&gt;</span>        (<span class="dt">SetLevel</span> l) <span class="ot">-&gt;</span> <span class="dt">M1</span> <span class="fu">$</span> go (runM1 b s)
<span class="ot">&gt;</span>        p <span class="ot">-&gt;</span> runM1 b p</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-</span>
<span class="co">&gt; baseLogger :: (LogLevel -&gt; String -&gt; IO ())</span>
<span class="co">&gt;            -&gt; (LogLevel -&gt; LogObject)</span>
<span class="co">&gt;            -&gt; LogLevel</span>
<span class="co">&gt;            -&gt; LogObject</span>
<span class="co">&gt; baseLogger writeLog newLogger lvl = M1 go where</span></code></pre></div>
<p>И два конкретных</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mkStdErrLogger ::</span> <span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">LogObject</span>
<span class="ot">&gt;</span> mkStdErrLogger <span class="fu">=</span> baseLogger (\_ s <span class="ot">-&gt;</span> hPutStrLn stderr s) mkStdErrLogger</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mkFileLogger ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">LogObject</span>
<span class="ot">&gt;</span> mkFileLogger path <span class="fu">=</span> baseLogger (\_ s <span class="ot">-&gt;</span> appendFile path s) (mkFileLogger path)</code></pre></div>
<p>Пример использования</p>
<pre><code>*Main&gt; let l1 = mkStdErrLogger Warn
*Main&gt; runM1 l1 (WriteLog Info &quot;info&quot;)
*Main&gt; runM1 l1 (WriteLog Error &quot;error&quot;)
error
*Main&gt; runM1 l1 GetLevel
Warn
*Main&gt; let l2 = runM1 l1 (SetLevel Info)
*Main&gt; runM1 l2 (WriteLog Info &quot;info&quot;)
info</code></pre>
<p>Что тут неудобно:</p>
<ol style="list-style-type: decimal">
<li><p>не всегда возвращение нового объекта может быть удобно, есть несколько выходов или завернуть в State, или использовать изменяемые поля. Но в последнем случае доступы к полям тоже будут в <code>IO</code> монаде, заметьте, что сейчас функции, считывающие состояние без его изменения чистые.</p></li>
<li><p>я не знаю как правильно добавлять наследование в таком подходе, или объекты принимающие доп параметры, например, если в FileLogger хочется иметь запрос <code>GetFilePath</code>, тут надо смотреть статью выше. Наверное в ближайшие дни опишу один из вариантов расширения.</p></li>
</ol>
<p>Но для многих задач и этого достаточно.</p>
<p>Что можно улучшать, можно, например, разделить все запросы на запросы записи, чтения и выполнения, например как <code>data Action = Read | Write | Execute</code> и пример можно найти где-то <a href="https://github.com/YoEight/eventstore/blob/refact/testability/Database/EventStore/Internal/Manager/Subscription/Model.hs#L102-L106">здесь</a>.</p>
<p>Абсолютно те же трюки можно провести и в других языках, только вместо pattern-matching будет диспетчеризация по типу, например куча <code>if</code> и проверкой <code>typeof</code> и меньше статических гарантий.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="fu">-</span>}</code></pre></div>]]></summary>
</entry>
<entry>
    <title>Создание объекта через замыкания (пост ответ)</title>
    <link href="https://qnikst.github.io/posts/2015-09-15-object-as-automaton.markdown.html" />
    <id>https://qnikst.github.io/posts/2015-09-15-object-as-automaton.markdown.html</id>
    <published>2015-09-15T00:00:00Z</published>
    <updated>2015-09-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>В целом тем кто читал <a href="https://www.cis.upenn.edu/~bcpierce/tapl/">TAPL</a> чтение данного поста не рекомендуется, так же тем кто хочет знать как делать правильно лучше сразу брать TAPL и читать его. Так же тут не описывается полноценное ООП, для этого можно посмотреть в сторону <a href="http://arxiv.org/abs/cs/0509027">Object Haskell</a>, где показывается вариант реализации через гетерогенные списки.</p>
<p>В одном из тредов на <a href="http://umnik.point.im/vhpti">point.im</a> возник вопрос, каким образом можно сделать “объект” (состояние и функции связанные с ним) с помощью функций.</p>
<p>Здесь и далее будет использоваться haskell и немного комментариев о других языках, так же будет использоваться подход идеоматичный для haskell, другие варианты тоже будут мельком обсуждены.</p>
<p>Итак нам как обычно потребуется немного расширений языка</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE RankNTypes #-}</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.IO</span></code></pre></div>
<p>Общая идея заключается в том, чтобы создать автомат (mealy machine), который на вход получает запросы, а на выходе дает результат (+ новую версию себя). Рассмотрим сначала простейший вариант:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">M1</span> a <span class="fu">=</span> <span class="dt">M1</span> {<span class="ot"> runM1 ::</span> forall b <span class="fu">.</span> a b <span class="ot">-&gt;</span> b }</code></pre></div>
<p>Тут мы создаем тип обёртку, над замыканием, которое принимает на вход запрос типа <code>a b</code> и отдает результат типа <code>b</code>. Таким образом объекты типизируются видом запросов, которые они могут обрабатывать. Можно записать простой пример запросов для системы логирования:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">LogLevel</span> <span class="fu">=</span> <span class="dt">Debug</span> <span class="fu">|</span> <span class="dt">Info</span> <span class="fu">|</span> <span class="dt">Warn</span> <span class="fu">|</span> <span class="dt">Error</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">LogRequest</span> a <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="dt">WriteLog</span><span class="ot"> ::</span> <span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">LogRequest</span> (<span class="dt">IO</span> ())
<span class="ot">&gt;</span>   <span class="dt">SetLevel</span><span class="ot"> ::</span> <span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">LogRequest</span> (<span class="dt">M1</span> <span class="dt">LogRequest</span>)
<span class="ot">&gt;</span>   <span class="dt">GetLevel</span><span class="ot"> ::</span> <span class="dt">LogRequest</span> <span class="dt">LogLevel</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">LogObject</span> <span class="fu">=</span> <span class="dt">M1</span> <span class="dt">LogRequest</span></code></pre></div>
<p>Здесь мы имеем три типа запроса, первый - записал лог, создает действие типа <code>IO ()</code>, т.е. выполняет какой-то эффект, второе - обновляет уровень логирования возвращая новый обьект из текущего, и третье это чистое действие, получение уровня логирования из текущего.</p>
<p>Теперь мы можем создавать различне логгеры, например:</p>
<p>Для того, чтобы не делать копипаст создадим базовый логгер:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; baseLogger ::</span> (<span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ())
<span class="ot">&gt;</span>            <span class="ot">-&gt;</span> (<span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">LogObject</span>)
<span class="ot">&gt;</span>            <span class="ot">-&gt;</span> <span class="dt">LogLevel</span>
<span class="ot">&gt;</span>            <span class="ot">-&gt;</span> <span class="dt">LogObject</span>
<span class="ot">&gt;</span> baseLogger writeLog newLogger lvl <span class="fu">=</span> <span class="dt">M1</span> go <span class="kw">where</span>
<span class="ot">&gt;   go ::</span> <span class="dt">LogRequest</span> a <span class="ot">-&gt;</span> a <span class="co">-- очень важная строчка делающая компилятор счастливым</span>
<span class="ot">&gt;</span>   go (<span class="dt">WriteLog</span> l s) 
<span class="ot">&gt;</span>      <span class="fu">|</span> l <span class="fu">&gt;=</span> lvl <span class="fu">=</span> writeLog l s
<span class="ot">&gt;</span>      <span class="fu">|</span> otherwise <span class="fu">=</span> return ()
<span class="ot">&gt;</span>   go (<span class="dt">SetLevel</span> l) <span class="fu">=</span> newLogger l
<span class="ot">&gt;</span>   go <span class="dt">GetLevel</span>     <span class="fu">=</span> lvl</code></pre></div>
<p>И два конкретных</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mkStdErrLogger ::</span> <span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">LogObject</span>
<span class="ot">&gt;</span> mkStdErrLogger <span class="fu">=</span> baseLogger (\_ s <span class="ot">-&gt;</span> hPutStrLn stderr s) mkStdErrLogger</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mkFileLogger ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">LogLevel</span> <span class="ot">-&gt;</span> <span class="dt">LogObject</span>
<span class="ot">&gt;</span> mkFileLogger path <span class="fu">=</span> baseLogger (\_ s <span class="ot">-&gt;</span> appendFile path s) (mkFileLogger path)</code></pre></div>
<p>Пример использования</p>
<pre><code>*Main&gt; let l1 = mkStdErrLogger Warn
*Main&gt; runM1 l1 (WriteLog Info &quot;info&quot;)
*Main&gt; runM1 l1 (WriteLog Error &quot;error&quot;)
error
*Main&gt; runM1 l1 GetLevel
Warn
*Main&gt; let l2 = runM1 l1 (SetLevel Info)
*Main&gt; runM1 l2 (WriteLog Info &quot;info&quot;)
info</code></pre>
<p>Что тут неудобно:</p>
<ol style="list-style-type: decimal">
<li><p>не всегда возвращение нового объекта может быть удобно, есть несколько выходов или завернуть в State, или использовать изменяемые поля. Но в последнем случае доступы к полям тоже будут в <code>IO</code> монаде, заметьте, что сейчас функции, считывающие состояние без его изменения чистые.</p></li>
<li><p>я не знаю как правильно добавлять наследование в таком подходе, или объекты принимающие доп параметры, например, если в FileLogger хочется иметь запрос <code>GetFilePath</code>, тут надо смотреть статью выше. Наверное в ближайшие дни опишу один из вариантов расширения.</p></li>
</ol>
<p>Но для многих задач и этого достаточно.</p>
<p>Что можно улучшать, можно, например, разделить все запросы на запросы записи, чтения и выполнения, например как <code>data Action = Read | Write | Execute</code> и пример можно найти где-то <a href="https://github.com/YoEight/eventstore/blob/refact/testability/Database/EventStore/Internal/Manager/Subscription/Model.hs#L102-L106">здесь</a>.</p>
<p>Абсолютно те же трюки можно провести и в других языках, только вместо pattern-matching будет диспетчеризация по типу, например куча <code>if</code> и проверкой <code>typeof</code> и меньше статических гарантий.</p>]]></summary>
</entry>
<entry>
    <title>Массовое выделение ресурсов (пост-ответ)</title>
    <link href="https://qnikst.github.io/posts/2015-08-04-resource-allocation.markdown.html" />
    <id>https://qnikst.github.io/posts/2015-08-04-resource-allocation.markdown.html</id>
    <published>2015-08-04T00:00:00Z</published>
    <updated>2015-08-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>В посте <a href="http://ndtimofeev.github.io/ru/posts/2015-08-02-scope.html" class="uri">http://ndtimofeev.github.io/ru/posts/2015-08-02-scope.html</a> ставится вопрос как решить задачу с выделением многих объектов в “Ресурсо-подобном” окружениии.</p>
<p>Попробуем решить данную задачу. Естественно такую задачу можно решить генераций кода и TH, но это путь настоящего лиспера. В то время как Haskell язык с продвинутой системой типов, настолько, что типы могут писать за нас. Вот это и попробуем продемострировать.</p>
<p>Сначала включим немного интересных расширений.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE RankNTypes #-}</span></code></pre></div>
<p>Для решения нашей задачи мы пострим список на уровне типов, тут он будет напоминать тип из пакета <a href="https://hackage.haskell.org/package/vinyl">vinyl</a>, так же гетерогенные списки и похожие стуктуры можно найти в пакетах <a href="https://hackage.haskell.org/package/HList">HList</a>, <a href="https://hackage.haskell.org/package/fixed-vector-hetero">fixed-vector-hetero</a> и других.</p>
<p>Тут мы пишем тип сами, потому, что это просто, и для данной задачи не требуются какие либо дополнительные свойства. Для этого мы создаем GADT структуру данных, тут можно было бы воспользоваться и type family, но в этом случае возникли бы сложности связанные с их неинъективностью.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">H</span> (<span class="ot">p ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) (<span class="ot">c::</span>[<span class="fu">*</span>]) <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="dt">Nil</span><span class="ot">   ::</span> <span class="dt">H</span> p <span class="ch">&#39;[]</span>
<span class="ot">&gt;   (:.)  ::</span> p a <span class="ot">-&gt;</span> <span class="dt">H</span> p as <span class="ot">-&gt;</span> <span class="dt">H</span> p (a <span class="ch">&#39;: as)</span></code></pre></div>
<p>Здесь важно, что у мы создаем не 1 параметр, в котором типы элементов, определяются списком на уровне типов (второй параметр), но и дополнительным типов, который определяет тип элемента, так что элементы списка являются тегами. Это сделано для упрощения написания необходимой функциональность, но может быть легко расширено, если требуется.</p>
<p>Выпишем тип для регионов, которые тут невложенные, что важно, т.к. иначе можно было бы сделать приведение ресурсов к внутреннему региону, как сделано в <a href="https://hackage.haskell.org/package/regions-0.11/docs/Control-Monad-Trans-Region.html#g:4">regions</a>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Scope</span> s c <span class="fu">=</span> <span class="dt">Scope</span> {<span class="ot"> unScope ::</span> <span class="dt">IO</span> c } <span class="co">-- destructor should be private</span>
<span class="ot">&gt;</span>    <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>)</code></pre></div>
<p>Конструктор экспортировать не следует, т.к. пользователю не нужно давать возможность доставать IO действие. Фантомная переменная <code>s</code> нужна для того, чтобы переменные аллоцированные внутри scope не могли из него выйти</p>
<p>Теперь запишем типы используемые в задаче:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">DeviceHnd</span> a   <span class="fu">=</span> <span class="dt">DeviceHnd</span> <span class="dt">String</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)
<span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">StaticHnd</span> s a <span class="fu">=</span> <span class="dt">StaticHnd</span> <span class="dt">String</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</code></pre></div>
<p>Для аллокации и деаллокации ресурсов предлагается использовать следующие функции:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; alloc0 ::</span> <span class="dt">DeviceHnd</span> a <span class="ot">-&gt;</span> <span class="dt">Scope</span> s (<span class="dt">StaticHnd</span> s a)
<span class="ot">&gt;</span> alloc0 (<span class="dt">DeviceHnd</span> s)<span class="fu">=</span> <span class="dt">Scope</span> <span class="fu">$</span> const (<span class="dt">StaticHnd</span> s) <span class="fu">&lt;$&gt;</span> putStrLn (<span class="st">&quot;allocating &quot;</span> <span class="fu">++</span> s)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; dealloc0 ::</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> <span class="dt">Scope</span> s ()
<span class="ot">&gt;</span> dealloc0 (<span class="dt">StaticHnd</span> s) <span class="fu">=</span> <span class="dt">Scope</span> <span class="fu">$</span> putStrLn (<span class="st">&quot;deallocating &quot;</span> <span class="fu">++</span> s)</code></pre></div>
<p>В задаче ставился, вопрос, как сразу выделить много ресурсов, и благодаря информации о типе объектов в гетероненном списке, мы может легко это сделать.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; alloc1 ::</span> <span class="dt">H</span> <span class="dt">DeviceHnd</span> ls <span class="ot">-&gt;</span> <span class="dt">Scope</span> s (<span class="dt">H</span> (<span class="dt">StaticHnd</span> s) ls)
<span class="ot">&gt;</span> alloc1 <span class="dt">Nil</span> <span class="fu">=</span> return <span class="dt">Nil</span>
<span class="ot">&gt;</span> alloc1 (a <span class="fu">:.</span> as) <span class="fu">=</span> (<span class="fu">:.</span>) <span class="fu">&lt;$&gt;</span> alloc0 a <span class="fu">&lt;*&gt;</span> alloc1 as</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; dealloc1 ::</span> <span class="dt">H</span> (<span class="dt">StaticHnd</span> s) ls <span class="ot">-&gt;</span> <span class="dt">Scope</span> s ()
<span class="ot">&gt;</span> dealloc1 <span class="dt">Nil</span> <span class="fu">=</span> return ()
<span class="ot">&gt;</span> dealloc1 (a <span class="fu">:.</span> as) <span class="fu">=</span> dealloc0 a <span class="fu">&gt;&gt;</span> dealloc1 as</code></pre></div>
<p>Тут важную роль играет первый параметр типа гетерогенного списка <code>p</code>, благодаря этой информации мы можем применять функции <code>*0</code> при проходе списка. Если бы мы это не сделали, то пришлось бы ещё реализовавывать ad-hoc полиморфизм добавляя классы-типов и код был бы чуть-чуть более громоздким.</p>
<p>Теперь мы можем реализовать искомый тип:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; withResources ::</span> <span class="dt">H</span> <span class="dt">DeviceHnd</span> ls <span class="ot">-&gt;</span> (forall s <span class="fu">.</span> <span class="dt">H</span> (<span class="dt">StaticHnd</span> s) ls <span class="ot">-&gt;</span> <span class="dt">Scope</span> s b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b
<span class="ot">&gt;</span> withResources ls f <span class="fu">=</span> unScope <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>    h <span class="ot">&lt;-</span> alloc1 ls
<span class="ot">&gt;</span>    v <span class="ot">&lt;-</span> f h
<span class="ot">&gt;</span>    dealloc1 h
<span class="ot">&gt;</span>    return v</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> test <span class="fu">=</span> withResources ((<span class="dt">DeviceHnd</span> <span class="st">&quot;1&quot;</span><span class="ot">::</span><span class="dt">DeviceHnd</span> <span class="dt">Int</span>) <span class="fu">:.</span> ((<span class="dt">DeviceHnd</span> <span class="st">&quot;2&quot;</span><span class="ot">::</span><span class="dt">DeviceHnd</span> <span class="dt">String</span>)<span class="fu">:.</span><span class="dt">Nil</span>)) <span class="fu">$</span>
<span class="ot">&gt;</span>         \(dev1<span class="fu">:.</span>(dev2<span class="fu">:.</span><span class="dt">Nil</span>)) <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>            useInt dev1
<span class="ot">&gt;</span>            useString dev2
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;   useInt ::</span> <span class="dt">StaticHnd</span> s <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Scope</span> s ()
<span class="ot">&gt;</span>   useInt _ <span class="fu">=</span> <span class="dt">Scope</span> <span class="fu">$</span> putStrLn <span class="st">&quot;int&quot;</span>
<span class="ot">&gt;   useString ::</span> <span class="dt">StaticHnd</span> s <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Scope</span> s ()
<span class="ot">&gt;</span>   useString _ <span class="fu">=</span> <span class="dt">Scope</span> <span class="fu">$</span> putStrLn <span class="st">&quot;String&quot;</span></code></pre></div>
<p>И проверить:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> test
<span class="ot">&gt;</span> allocating <span class="dv">1</span>
<span class="ot">&gt;</span> allocating <span class="dv">2</span>
<span class="ot">&gt;</span> int
<span class="ot">&gt;</span> <span class="dt">String</span>
<span class="ot">&gt;</span> deallocating <span class="dv">1</span>
<span class="ot">&gt;</span> deallocating <span class="dv">2</span></code></pre></div>
<p>Все ли это? Нет, во-первых к созданию ресурсов нужно добавить поддержку асинхронных исключений и выделять ресурсы используя <code>bracket</code> или одну из библиотек <code>Regions</code> или <code>resourcet</code>, в этом случае необходимость использования масс-выделения может исчезнуть. С другой стороны, в <code>alloc1</code> мы можем перед аллокацией ресурсов запрашивать все устройства через выделенный объект, что может спасти от возможных deadlock-ов, в случае, если два разных потока одновременно аллоцируют ресурсы в “плохом” порядке.</p>]]></summary>
</entry>
<entry>
    <title>Things to know about exception handling.</title>
    <link href="https://qnikst.github.io/posts/2015-06-03-interesting-exceptions.html" />
    <id>https://qnikst.github.io/posts/2015-06-03-interesting-exceptions.html</id>
    <published>2015-06-03T00:00:00Z</published>
    <updated>2015-06-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Let’s take a look at the simple pattern, in this pattern we want to write an endless program for some purpose:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runit f <span class="fu">=</span> f <span class="ot">`onException`</span> (putStrLn <span class="st">&quot;exception!&quot;</span> <span class="fu">&gt;&gt;</span> runit f)</code></pre></div>
<p>Do you see a huge problem here? And this problem is not with code accuracy, inability to gracefully exit or something like that. There is another problem in this pattern. If you don’t then continue reading.</p>
<p>Assume <code>f</code> is some simple function that loops (for example <code>let f = forever yield</code>). Try to answer the following questions</p>
<ol style="list-style-type: decimal">
<li><p>what will happen if you run <code>runit f</code> in a separate thread (<code>forkIO $ runit f</code>)?</p></li>
<li><p>what will happen if you send an exception to the forked thread?</p></li>
<li><p>what will happen if you send another exception to that thread?</p></li>
</ol>
<p>Now you can try to check your guesses in ghci. If everything is ok then there is nothing new to read for you. However if you are lazy (and didn’t try to answer or run the code), you can continue.</p>
<p>Let’s try to test:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="fu">:</span>m <span class="dt">Control.Exception</span> <span class="dt">Control.Concurrent</span> <span class="dt">GHC.Conc</span> <span class="dt">Control.Monad</span>
<span class="fu">&gt;</span> <span class="kw">let</span> runit f <span class="fu">=</span> f <span class="ot">`onException`</span> (putStrLn <span class="st">&quot;exception!&quot;</span> <span class="fu">&gt;&gt;</span> runit f)
<span class="fu">&gt;</span> x <span class="ot">&lt;-</span> forkIO <span class="fu">$</span> runit <span class="fu">$</span> forever yield
<span class="fu">&gt;</span> x
<span class="dt">ThreadId</span> <span class="dv">154</span>
<span class="fu">&gt;</span> threadStatus x
<span class="dt">ThreadRunning</span></code></pre></div>
<p>Ok everything as expected, thread is running and consuming 100% of one CPU. Now go to the step 2.:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> throwTo x (userError <span class="st">&quot;foo&quot;</span>)
exc<span class="fu">&gt;</span> eption<span class="fu">!</span>
<span class="fu">&gt;</span> threadStatus x
<span class="dt">ThreadRunning</span></code></pre></div>
<p>Exception is caught, everything is OK. Now go to the 3.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> throwTo x (userError <span class="st">&quot;foo&quot;</span>)</code></pre></div>
<p>Hah.. It just hangs!!! We can interrupt it and check thread status</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> threadStatus x
<span class="dt">ThreadRunning</span></code></pre></div>
<p>This is definitely not what could be expected. Lets try to understand what had happened.</p>
<p>As you know exception sending is synchronous in a sense, that <code>throwTo</code> call will not exit unless exception will be delivered to the thread (or the thread dies).</p>
<p>Quote from <a href="https://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Concurrent.html">haddock</a>:</p>
<blockquote>
<p>Exception delivery synchronizes between the source and target thread: <code>throwTo</code> does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</p>
</blockquote>
<p>It’s definitely not an issue of non-reaching safepoint, that is also possible. Another quote:</p>
<blockquote>
<p>In GHC, an exception can only be raised when a thread reaches a safe point, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a <code>throwTo</code>.</p>
</blockquote>
<p>It could be a case if <code>f</code> would be something like <code>f = return $ last [1..]</code> compiled with optimizations turned on. But as we have seen the first exception was delivered successfully. And also we are not in a <em>FFI</em> call. The only left possibility is that the thread is in a masked state. Let’s check it:</p>
<pre><code>&gt; x &lt;- forkIO $ runit (getMaskingState &gt;&gt;= print  &gt;&gt; forever yield)
Unmasked
Prelude Control.Exception Control.Concurrent GHC.Conc Control.Monad&gt; throwTo x (userError &quot;bar&quot;)
exceptiPrelude Control.Exception Control.Concurrent GHC.Conc Control.Monad&gt; on!
MaskedInterruptible</code></pre>
<p>Yes, everything happened as we were expecting the thread is now in a masked state, and so exception can’t be delivered. But why? Maybe we need to take a look at <code>Control.Exception</code> module documentation? You may try, but at least in base-4.8.0 (and in the previous versions) these details were not documented.</p>
<p>But we can try to find out solution somewhere else, for example in RTS documentation:</p>
<blockquote>
<p>A thread can request that asynchronous exceptions not be delivered (“masked”) for the duration of an I/O computation. The primitives</p>
<p>maskAsyncExceptions# :: IO a -&gt; IO a</p>
<p>and</p>
<p>maskUninterruptible# :: IO a -&gt; IO a</p>
<p>are used for this purpose. During a masked section, asynchronous exceptions may be unmasked again temporarily:</p>
<p>unmaskAsyncExceptions# :: IO a -&gt; IO a</p>
<p>Furthermore, asynchronous exceptions are masked automatically during the execution of an exception handler. All three of these primitives leave a continuation on the stack which reverts to the previous state (masked interruptible, masked non-interruptible, or unmasked) on exit.</p>
</blockquote>
<p>Looks like a reason of our problem. Unfortunatelly it’s not in the documentation that usual user would read, but a nice thing to know.</p>
<p>And original code should look like the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runit f <span class="fu">=</span> mask <span class="fu">$</span> \release <span class="ot">-&gt;</span> <span class="kw">do</span>
  ev <span class="ot">&lt;-</span> try <span class="fu">$</span> release f
  <span class="kw">case</span> ev <span class="kw">of</span>
    <span class="dt">Left</span> _ <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;exception&quot;</span> <span class="fu">&gt;&gt;</span> release (runit f)
    <span class="dt">Right</span> x <span class="ot">-&gt;</span> return x</code></pre></div>
<p>You’ll need to pass exception type you are interested in or use <code>catches</code>.</p>
<p>I hope you enjoyed reading this, despite a terrible English that I have.</p>]]></summary>
</entry>
<entry>
    <title>Logging all exceptions in ghci</title>
    <link href="https://qnikst.github.io/posts/2015-04-30-grabbing-exceptions.html" />
    <id>https://qnikst.github.io/posts/2015-04-30-grabbing-exceptions.html</id>
    <published>2015-04-30T00:00:00Z</published>
    <updated>2015-04-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>On one resource there was a question how to log all exception in GHCI. There was a use case where user could start a background processes and some exceptions could be lost.</p>
<p>In a normal program you can use <code>-prof</code> compilation option and run program with <code>+RTS -xc</code> in order to get exceptions messages and stack-traces logged. However I assume that most of the ghc users doesn’t have <code>ghc</code> compiled with profiling flags. So we need to find another option.</p>
<p>And there is a solution. Every forked thread installs a exceptions handler:</p>
<p>From <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Conc-Sync.html#forkIO">GHC.Cons.Sym</a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">forkIO ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span>
forkIO action <span class="fu">=</span> <span class="dt">IO</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span>
   <span class="kw">case</span> (fork<span class="fu">#</span> action_plus s) <span class="kw">of</span> (<span class="fu">#</span> s1, tid <span class="fu">#</span>) <span class="ot">-&gt;</span> (<span class="fu">#</span> s1, <span class="dt">ThreadId</span> tid <span class="fu">#</span>)
    <span class="kw">where</span>
      action_plus <span class="fu">=</span> catchException action childHandler</code></pre></div>
<p>From <a href="">GHC.IO</a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{-</span>
<span class="co">catchException used to handle the passing around of the state to the</span>
<span class="co">action and the handler.  This turned out to be a bad idea - it meant</span>
<span class="co">that we had to wrap both arguments in thunks so they could be entered</span>
<span class="co">as normal (remember IO returns an unboxed pair...).</span>

<span class="co">Now catch# has type</span>

<span class="co">catch# :: IO a -&gt; (b -&gt; IO a) -&gt; IO a</span>

<span class="co">(well almost; the compiler doesn&#39;t know about the IO newtype so we</span>
<span class="co">have to work around that in the definition of catchException below).</span>
<span class="co">-}</span>
<span class="ot">catchException ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</code></pre></div>
<p>In order to set hander we can use:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">setUncaughtExceptionHandler ::</span> (<span class="dt">SomeException</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>
<p>In order to add something to ghci we can load a script by passing it with <code>-ghci-script</code> option</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:</span>m <span class="dt">GHC.Conc.Sync</span> <span class="dt">Control.Exception</span>

<span class="fu">:</span>{
<span class="kw">let</span><span class="ot"> uncaughtExceptionHandler ::</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
    uncaughtExceptionHandler e <span class="fu">=</span> <span class="kw">do</span>
        putStrLn <span class="fu">$</span> <span class="st">&quot;Unhandled exception: &quot;</span> <span class="fu">++</span> show e
<span class="fu">:</span>}

setUncaughtExceptionHandler uncaughtExceptionHandler

<span class="fu">:</span>m <span class="fu">-</span><span class="dt">GHC.Conc.Sync</span> <span class="dt">Control.Exception</span></code></pre></div>
<p>And load it with <code>ghci -ghci-script script.hs</code>.</p>
<pre><code>qnikst@localhost ~ $ ghci -ghci-script script.hs 
GHCi, version 7.8.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude&gt; :m +Control.Exception Control.Concurrent
Prelude Control.Exception Control.Concurrent&gt; forkIO $ threadDelay 10000 &gt;&gt; error &quot;yo!&quot;
ThreadId 28
Prelude Control.Exception Control.Concurrent&gt; Unhandled exception: yo!</code></pre>]]></summary>
</entry>
<entry>
    <title>Approaches to carry a proof for typelevel natural</title>
    <link href="https://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" />
    <id>https://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html</id>
    <published>2014-12-16T00:00:00Z</published>
    <updated>2014-12-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>For time ago Bas van Dijk asked a question on glasgow-haskell-users mailing list about <a href="https://www.haskell.org/pipermail/glasgow-haskell-users/2014-November/025451.html">proving the properties of type-level natural numbers obtained by user</a>. That lead to an interesting discussion, that you can read in the list archives.</p>
<p>The problem was that we want to impose a constraint on some typelevel natural and then read value from user and guarantee that we have that constraint. For such constraint we took (&lt;=255).</p>
<p>Here is a file that describe few approaches to solve this problem.</p>
<p>At first we need to use a HUGE list of pragmas.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ViewPatterns #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ConstraintKinds #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></code></pre></div>
<p>And relax compiler options a bit.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# OPTIONS_GHC -ftype-function-depth=1024 #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# OPTIONS_GHC -fcontext-stack=1024 #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">GHC.TypeLits</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">GHC.Exts</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Proxy</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Constraint</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Type.Bool</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Type.Equality</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Environment</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Unsafe.Coerce</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Singletons</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad</span></code></pre></div>
<h2 id="attempt-1-tagged-value">Attempt-1: Tagged value</h2>
<p>We can keep a proof together with value, so we can introduce a new type:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Proof</span> n  (<span class="ot">c ::</span> <span class="dt">Constraint</span>) <span class="kw">where</span> <span class="dt">Proof</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof</span> n c</code></pre></div>
<p>In mailing list I provide following code:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fromSomeError ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof</span> n (n <span class="fu">&lt;=</span> <span class="dv">255</span>))
<span class="ot">&gt;</span> fromSomeError (<span class="dt">SomeNat</span> p)
<span class="ot">&gt;</span>    <span class="fu">|</span> natVal p <span class="fu">&lt;=</span> <span class="dv">255</span> <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Proof</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n))
<span class="ot">&gt;</span>    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>This is obviously a bug as we check natVal p, but return Proxy n. And correct version fails, as there is no way to simply inject a constraint.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-</span>
<span class="co">&gt; fromSome :: SomeNat -&gt; Maybe (Proof n (n &lt;= 255))</span>
<span class="co">&gt; fromSome (SomeNat p)</span>
<span class="co">&gt;   | natVal p &lt;= 255 = Just (Proof p)</span>
<span class="co">&gt;   | otherwise = Nothing</span>
<span class="co">&gt; -}</span></code></pre></div>
<pre><code> Proof.lhs:53:37:
    Could not deduce (n1 ~ n)
    from the context (KnownNat n1)
    bound by a pattern with constructor
        SomeNat :: forall (n :: Nat). KnownNat n =&gt; Proxy n -&gt; SomeNat,
	in an equation for ‘fromSome’
	at Proof.lhs:52:13-21</code></pre>
<h2 id="attempt-2-type-carrier">Attempt-2: Type carrier</h2>
<p>Now we want to have the following constraint on out Nat</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Proof2</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="dt">Proof2</span><span class="ot"> ::</span> c n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c</code></pre></div>
<p>In order to have a ‘curried’ version of our constaint we can introduce a type family</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> family <span class="dt">LessThan255</span><span class="ot"> n ::</span> <span class="dt">Constraint</span> <span class="kw">where</span>
<span class="ot">&gt;</span>     <span class="dt">LessThan255</span> f <span class="fu">=</span> (f <span class="fu">&lt;=</span> <span class="dv">255</span>)</code></pre></div>
<p>Now lets try to create a proof from known natural:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-</span>
<span class="co">&gt; strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255</span>
<span class="co">&gt; strange = Proof2</span>
<span class="co">&gt; -}</span></code></pre></div>
<p><sub><sub><sub><sub><sub><sub><sub>~</sub></sub></sub></sub></sub></sub></sub> Proof.lhs:89:13: Could not deduce (LessThan255 n) arising from a use of ‘Proof2’ from the context (LessThan255 n) bound by the type signature for strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255 <sub><sub><sub><sub><sub><sub>~</sub></sub></sub></sub></sub></sub>~</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; strange ::</span> (<span class="dt">LessThan255</span> <span class="fu">~</span> c, c n) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c
<span class="ot">&gt;</span> strange <span class="fu">=</span> <span class="dt">Proof2</span></code></pre></div>
<p>Previous attempt to build function failed, but this one works. I don’t know if it’s related to non-injectivity or a bug.. I can report it :)</p>
<p>When I realized this problem, I have stopped.</p>
<p>Update. As Richard Eisenberg says:</p>
<pre><code>By the way, the bug in the Proof2 version is a bug in GHC 7.8.3
(only in .3 -- not in .2 or in the soon-to-be .4) that allows you
to write unsaturated type families that don&#39;t work.
Saying `LessThan255` without a parameter should be a syntax error,
but that check was accidentally turned off for 7.8.3, leading to a bogus type error.</code></pre>
<h2 id="attempt-3-carry-a-contraint-in-a-datatype">Attempt-3: carry a contraint in a datatype</h2>
<p>Now let’s keep our ‘constraint’ in a datatype, here we have 2 proxy, one for datatype, and one for value, also a KnownNat constraint that we want to use later:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Proof3</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="dt">Proof3</span><span class="ot"> ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c</code></pre></div>
<p>We can introduce a Show instance</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Proof3</span> c) <span class="kw">where</span>
<span class="ot">&gt;</span>   show (<span class="dt">Proof3</span> _ k) <span class="fu">=</span> show <span class="fu">$</span> natVal k</code></pre></div>
<p>And now we can introduce a LessThen constraint as a datatype:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">LessThan255D</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="kw">where</span> <span class="dt">LessThan255D</span><span class="ot"> ::</span> (n <span class="fu">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">LessThan255D</span> n</code></pre></div>
<p>We can convert type level constrant to data easily:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; c2d ::</span> <span class="dt">LessThan255</span> n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">LessThan255D</span> n
<span class="ot">&gt;</span> c2d _ <span class="fu">=</span> <span class="dt">LessThan255D</span></code></pre></div>
<p>But what about a proof, ideally we want to have following code:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-</span>
<span class="co">&gt; fromSome3 :: SomeNat -&gt; Maybe (Proof3 LessThan255D)</span>
<span class="co">&gt; fromSome3 (SomeNat p)</span>
<span class="co">&gt;    | natVal p &lt; natVal t255 = Just (Proof3 LessThan255D p)</span>
<span class="co">&gt;    | otherwise = Nothing</span>
<span class="co">&gt;    where t255 = Proxy :: Proxy 255</span>
<span class="co">&gt; -}</span></code></pre></div>
<pre><code>Proof.lhs:138:46:
  Could not deduce ((n &lt;=? 255) ~ &#39;True)
  from the context (KnownNat n)</code></pre>
<p>It doesn’t work simply because value level check doesn’t guarantee typelevel properties.</p>
<p>One way to solve it is to use unsafeCoerce: the idea is to use a proof for the value we know, and then coerce a type of a proof to the type of the proof related to the users value:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fromSome3 ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)
<span class="ot">&gt;</span> fromSome3 (<span class="dt">SomeNat</span> p)
<span class="ot">&gt;</span>    <span class="fu">|</span> natVal p <span class="fu">&lt;</span> natVal t255 <span class="fu">=</span> <span class="dt">Just</span> (fake (c2d t255) p)
<span class="ot">&gt;</span>    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>    <span class="kw">where</span> t255 <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span>
<span class="ot">&gt;          fake ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c p <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c
<span class="ot">&gt;</span>          fake k p <span class="fu">=</span> <span class="dt">Proof3</span> (unsafeCoerce<span class="ot"> k ::</span> c n) p</code></pre></div>
<p>It’s a nice solution, it’s unsafe as typechecker does not check that our predicate <code>(natVal (p::Proxy n) &lt; natVal (t255::Proxy 255))</code> implies the safety of a coerce from <code>LessThan255 ~ 255 -&gt; LessThan255 ~ p</code>.</p>
<p>There is one more solution that is really typesafe, but has a big complexity, and require a bounded set of values:</p>
<p>We can try to check is equal to one specific value from the set.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; guessProof ::</span> (<span class="dt">KnownNat</span> n, n <span class="fu">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)
<span class="ot">&gt;</span> guessProof (<span class="dt">SomeNat</span> p) n <span class="fu">=</span> <span class="kw">case</span> sameNat p n <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="dt">Just</span> _  <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> n
<span class="ot">&gt;</span>     <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></code></pre></div>
<p>Now we can build all set of values that are good:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> family <span class="dt">Guesses</span> (<span class="ot">n::</span><span class="dt">Nat</span>)<span class="ot"> ::</span> [<span class="dt">Nat</span>] <span class="kw">where</span>
<span class="ot">&gt;</span>    <span class="dt">Guesses</span> <span class="dv">0</span> <span class="fu">=</span> <span class="ch">&#39;[0]</span>
<span class="ot">&gt;</span>    <span class="dt">Guesses</span> n <span class="fu">=</span> n <span class="ch">&#39;: Guesses (n-1)</span></code></pre></div>
<p>And write a code that will check all possible values:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">class</span> <span class="dt">GuessProof</span> (<span class="ot">n ::</span> [<span class="dt">Nat</span>]) <span class="kw">where</span>
<span class="ot">&gt;   proof ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">GuessProof</span> <span class="ch">&#39;[] where</span>
<span class="ot">&gt;</span>   proof _ _ <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> (<span class="dt">KnownNat</span> n, n <span class="fu">&lt;=</span> <span class="dv">255</span>, <span class="dt">GuessProof</span> ns) <span class="ot">=&gt;</span> <span class="dt">GuessProof</span> (n <span class="ch">&#39;: ns) where</span>
<span class="ot">&gt;</span>   proof s p <span class="fu">=</span> guessProof s (inner p) <span class="ot">`mplus`</span> proof s (next p)
<span class="ot">&gt;</span>    <span class="kw">where</span><span class="ot"> inner ::</span> <span class="dt">Proxy</span> (n <span class="ch">&#39;: ns) -&gt; Proxy (n::Nat)</span>
<span class="ot">&gt;</span>          inner _ <span class="fu">=</span> <span class="dt">Proxy</span>
<span class="ot">&gt;          next ::</span> <span class="dt">Proxy</span> (n <span class="ch">&#39;: ns) -&gt; Proxy (ns::[Nat])</span>
<span class="ot">&gt;</span>          next _ <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>It’s not very usable, have a bad complexity and require to change ghc options but it works and it’s safe.</p>
<p>Now let’s test our code:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; f2 ::</span> (c <span class="fu">~</span> (n <span class="fu">&lt;=</span> <span class="dv">255</span>)) <span class="ot">=&gt;</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> f2 (<span class="dt">Proof3</span> n p) <span class="fu">=</span> print <span class="fu">$</span> natVal p</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; test1 ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> test1 <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="kw">case</span> someNatVal n <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Input is not a natural number!&quot;</span>
<span class="ot">&gt;</span>       <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> fromSome3 sn <span class="kw">of</span>
<span class="ot">&gt;</span>                    <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p
<span class="ot">&gt;</span>                    _ <span class="ot">-&gt;</span> error <span class="st">&quot;Input if larger than 255&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; test2 ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> test2 <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span>   <span class="kw">case</span> someNatVal n <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Input is not a natural number!&quot;</span>
<span class="ot">&gt;</span>       <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> proof sn (g (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span>)) <span class="kw">of</span>
<span class="ot">&gt;</span>                    <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p
<span class="ot">&gt;</span>                    _ <span class="ot">-&gt;</span> error <span class="st">&quot;Input if larger than 255&quot;</span>
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     g ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="dt">Guesses</span> n)
<span class="ot">&gt;</span>     g _ <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<h2 id="attempt-5-singletons">Attempt 5: Singletons</h2>
<p>This is not the only solution, one more solution was provided by Richard Eisenberg I have not found it in mailing list archives so including it here.</p>
<p>The idea is that we may use less effective representation for typelevel naturals, i.e. unary naturals we can build a proof using singletons:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-# LANGUAGE TemplateHaskell, DataKinds, PolyKinds, TypeFamilies,</span>
<span class="co">&gt;              ScopedTypeVariables, TypeOperators, UndecidableInstances,</span>
<span class="co">&gt;              GADTs, RankNTypes #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# OPTIONS_GHC -ftype-function-depth=300 -fcontext-stack=300 #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Singletons.TH</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">GHC.TypeLits</span> <span class="kw">hiding</span> ( <span class="dt">Nat</span> )
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="fu">$</span>(singletons [d<span class="fu">|</span>
<span class="ot">&gt;</span>   <span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;   leNat ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span>   leNat <span class="dt">Zero</span>     _        <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span>   leNat (<span class="dt">Succ</span> _) <span class="dt">Zero</span>     <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span>   leNat (<span class="dt">Succ</span> a) (<span class="dt">Succ</span> b) <span class="fu">=</span> a <span class="ot">`leNat`</span> b
<span class="ot">&gt;</span>   <span class="fu">|</span>])
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | Singletons&#39;s &#39;withSomeSing&#39; is what we want, but a bug in 7.8.3 doesn&#39;t</span>
<span class="ot">&gt;</span> <span class="co">-- let it work without a specialized type for &#39;Nat&#39;s</span>
<span class="ot">&gt; withSomeNat ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> (forall (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="fu">.</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r
<span class="ot">&gt;</span> withSomeNat <span class="fu">=</span> withSomeSing
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | Conveniently generate unary naturals</span>
<span class="ot">&gt;</span> <span class="kw">type</span> family <span class="dt">U</span> n <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="dt">U</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Zero</span>
<span class="ot">&gt;</span>   <span class="dt">U</span> n <span class="fu">=</span> <span class="dt">Succ</span> (<span class="dt">U</span> (n<span class="fu">-</span><span class="dv">1</span>))
<span class="ot">&gt;</span> 
<span class="ot">&gt; toNat ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Nat</span>
<span class="ot">&gt;</span> toNat n <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">0</span>      <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>         <span class="fu">|</span> otherwise  <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> go n
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     go <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Zero</span>
<span class="ot">&gt;</span>     go n <span class="fu">=</span> <span class="dt">Succ</span> (go (n<span class="fu">-</span><span class="dv">1</span>))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Bound</span> <span class="fu">=</span> <span class="dt">U</span> <span class="dv">255</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- easier to test in GHCi than a proper &#39;main&#39;</span>
<span class="ot">&gt; go ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> go n <span class="fu">=</span>
<span class="ot">&gt;</span>    <span class="kw">case</span> toNat n <span class="kw">of</span>
<span class="ot">&gt;</span>      <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Input is not a natural number!&quot;</span>
<span class="ot">&gt;</span>      <span class="dt">Just</span> nat <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> withSomeNat nat <span class="fu">$</span> \ snat <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>        <span class="kw">case</span> snat <span class="ot">`sLeNat`</span> (<span class="ot">sing ::</span> <span class="dt">Sing</span> <span class="dt">Bound</span>) <span class="kw">of</span>
<span class="ot">&gt;</span>          <span class="dt">STrue</span>  <span class="ot">-&gt;</span> f snat
<span class="ot">&gt;</span>          <span class="dt">SFalse</span> <span class="ot">-&gt;</span> <span class="st">&quot;Didn&#39;t work&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; f ::</span> forall proxy (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="fu">.</span> (n <span class="ot">`LeNat`</span> <span class="dt">Bound</span>) <span class="fu">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> proxy n <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">&gt;</span> f _ <span class="fu">=</span> <span class="st">&quot;It worked!&quot;</span></code></pre></div>
<h2 id="attempt-6-using-luquid-haskell">Attempt 6: Using Luquid haskell</h2>
<p>Ranjit Jhala, provided a great solution for liquid haskell, that could be found either by <a href="http://goto.ucsd.edu:8090/index.html#?demo=permalink%2F1418064183.hs">url</a> or here:</p>
<hr />
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ LIQUID &quot;--no-termination&quot; @-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Nat255</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | Define a predicate for valid integers</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ predicate IsValid X = 0 &lt;= X &amp;&amp; X &lt; 255 @-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | Use the predicate to define a refinement type (subset) of valid integers</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ type Valid = {v:Int | IsValid v}        @-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | A function that checks whether a given Int is indeed valid</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ isValid   :: n:Int -&gt; {v:Bool | Prop v &lt;=&gt; IsValid n} @-}</span>
<span class="ot">&gt;</span> isValid n     <span class="fu">=</span> <span class="dv">0</span> <span class="fu">&lt;=</span> n <span class="fu">&amp;&amp;</span> n <span class="fu">&lt;</span> (<span class="dv">255</span><span class="ot"> ::</span> <span class="dt">Int</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | A function that can only be called with Valid Ints.</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ workWithValidNumber :: Valid -&gt; IO () @-}</span> 
<span class="ot">&gt;</span> workWithValidNumber n <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;This is a valid number&quot;</span> <span class="fu">++</span> show (<span class="ot">n ::</span> <span class="dt">Int</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | This is fine...</span>
<span class="ot">&gt;</span> ok    <span class="fu">=</span> workWithValidNumber <span class="dv">12</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | ... But this is not.        </span>
<span class="ot">&gt;</span> notOk <span class="fu">=</span> workWithValidNumber <span class="dv">257</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | Finally the top level loop that inputs a number, tests it </span>
<span class="ot">&gt;</span> <span class="co">--   and calls `workWithValidNumber` if the number is valid.</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> loop <span class="fu">=</span> <span class="kw">do</span> putStrLn <span class="st">&quot;Enter Number between 0 and 255&quot;</span>
<span class="ot">&gt;</span>           n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>           <span class="kw">if</span> isValid n
<span class="ot">&gt;</span>              <span class="kw">then</span> workWithValidNumber n
<span class="ot">&gt;</span>              <span class="kw">else</span> putStrLn <span class="st">&quot;Humph, bad input, try again!&quot;</span> <span class="fu">&gt;&gt;</span> loop</code></pre></div>
<p>I hope you have enjoyed reading this.</p>]]></summary>
</entry>
<entry>
    <title>Compositional methods for numerical ODE integrators</title>
    <link href="https://qnikst.github.io/posts/2014-08-18-compositional-methods.html" />
    <id>https://qnikst.github.io/posts/2014-08-18-compositional-methods.html</id>
    <published>2014-08-18T00:00:00Z</published>
    <updated>2014-08-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>We show a way to improve properties of a ODE integrators, by introducing a composition of the methods with a different steps.</p>
<!--more-->
<p>This post is based on the work of the Ernst Harrier [<a href="http://www.springer.com/mathematics/computational+science+%26+engineering/book/978-3-540-30663-4">1</a>] and doesn’t contain any additional research work.</p>
<p>Here we want to solve a system of equations that can we written as:</p>
<p><span class="math display">\[ \dot{y} = f(y). \]</span></p>
<p>In order to solve it we are introducing a mapping from an old state at <span class="math inline">\(t0\)</span> to a new one at <span class="math inline">\(t_1 = t_0 + dt\)</span>:</p>
<p><span class="math display">\[\Phi_h: y_{n} \rightarrow  y_{n+1}\]</span></p>
<p>In order to increase the order of the solution while preserving some desirable properties of the base method we may prepare a compositional method:</p>
<p><span class="math display">\[\Psi_h = \Phi_{\gamma_1h} \circ \ldots \circ \Phi_{\gamma_nh},\]</span></p>
<p>where <span class="math inline">\(\gamma_i\)</span> is a coefficient from <span class="math inline">\(\mathbb R\)</span>. This approach was studied by Suzuki, Yoshina, McLackcan in 1990th. Here we compose a base method at a different points in time.</p>
<p>We have a theorem about this approach to compositional methods.</p>
<p><em>Theorem</em></p>
<blockquote>
<p>Let <span class="math inline">\(\Phi_h\)</span> be a one-step method of order <span class="math inline">\(p\)</span>. If</p>
<p><span class="math display">\[
\begin{eqnarray}
\gamma_1 + \ldots + \gamma_s = 1 \\
\gamma_1^{p+1} + \ldots + \gamma_s^{p+1} = 0 \\
\end{eqnarray}
\]</span> then the compositional method <span class="math inline">\(\Psi_h\)</span> is at least of the order <span class="math inline">\(p+1\)</span>.</p>
</blockquote>
<p>This gives theorem gives us a nice way to improve properties of the existing method. The question now is how to find a good coefficients <span class="math inline">\(\gamma_i\)</span>.</p>
<p>The first notice is that equations does not have a real solution for the odd <span class="math inline">\(p\)</span>, so we can improve only solutions with even <span class="math inline">\(p\)</span>.</p>
<p>The smallest number <span class="math inline">\(s\)</span> where a solution in reals exists is <span class="math inline">\(3\)</span>. And coefficients are defined as:</p>
<p><span class="math display">\[ \gamma_1 = \gamma_3 = \frac{1}{2 - 2^{\frac{1}{p+1}}} \]</span></p>
<p><span class="math display">\[ \gamma_2 = - \frac{2^{\frac{1}{p+1}}}{2 - 2^{\frac{1}{p+1}}} \]</span></p>
<p>This method is called tripple jump. Lets check how does it work.</p>
<p>At first we will introduce a coefficients</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">g1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
g1 p <span class="fu">=</span>  <span class="dv">1</span> <span class="fu">/</span> (<span class="dv">2</span> <span class="fu">-</span> <span class="dv">2</span><span class="fu">**</span>(<span class="dv">1</span><span class="fu">/</span>(fromIntegral p<span class="fu">+</span><span class="dv">1</span>)))

<span class="ot">g2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
g2 p <span class="fu">=</span> <span class="fu">-</span> <span class="dv">2</span><span class="fu">**</span>(<span class="dv">1</span><span class="fu">/</span>(fromIntegral p<span class="fu">+</span><span class="dv">1</span>)) <span class="fu">/</span> ( <span class="dv">2</span> <span class="fu">-</span> <span class="dv">2</span><span class="fu">**</span>(<span class="dv">1</span><span class="fu">/</span>(fromIntegral p<span class="fu">+</span><span class="dv">1</span>)))

<span class="ot">g3 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
g3 <span class="fu">=</span> g1</code></pre></div>
<p>Having a method of an order 2 (for example standard Runge-Kutta method) we may use a composition a points defined by <span class="math inline">\(\gamma_i\)</span> with <span class="math inline">\(p=2\)</span>. Let step be a <span class="math inline">\(dt = 1\)</span> for simplicity.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> t ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>]
<span class="fu">&gt;</span> t p dt <span class="fu">=</span> map (<span class="fu">*</span>dt) [g1 p, g2 p, g3 p]

<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> t <span class="dv">2</span> <span class="dv">1</span>
[<span class="fl">1.3512071919596578</span>,<span class="fu">-</span><span class="fl">1.7024143839193153</span>,<span class="fl">1.3512071919596578</span>]</code></pre></div>
<p>We have 3 points. If we will take a compositional method <span class="math inline">\(\Psi\)</span> in the points we got then we will have a method of order <span class="math inline">\(3\)</span>. However if you method is symmetric then it’s order is <span class="math inline">\(4\)</span> and we can apply a tripple jump once again to our composed method.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> ut ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>]
<span class="fu">&gt;</span> ut p xs <span class="fu">=</span> xs <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> t (p<span class="fu">+</span><span class="dv">2</span>) x)

<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> ut <span class="dv">4</span> (t <span class="dv">2</span> <span class="dv">1</span>)
[<span class="fl">1.5081944151591316</span>,<span class="fu">-</span><span class="fl">1.665181638358605</span>,<span class="fl">1.5081944151591316</span>,<span class="fu">-</span><span class="fl">1.900205890992877</span>
,<span class="fl">2.097997398066439</span>,<span class="fu">-</span><span class="fl">1.900205890992877</span>,<span class="fl">1.5081944151591316</span>,<span class="fu">-</span><span class="fl">1.665181638358605</span>,<span class="fl">1.5081944151591316</span>]</code></pre></div>
<p>This is a coefficients for a compositional method of order <span class="math inline">\(5\)</span>, (<span class="math inline">\(6\)</span> due to symmetry. Applying tripple jump nce again:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> ut <span class="dv">6</span> \<span class="fu">$</span> ut <span class="dv">4</span> (t <span class="dv">2</span> <span class="dv">1</span>)
[<span class="fl">1.639448210847001</span>,<span class="fu">-</span><span class="fl">1.77070200653487</span>,<span class="fl">1.639448210847001</span>,<span class="fu">-</span><span class="fl">1.8100975778074668</span>
,<span class="fl">1.955013517256328</span>,<span class="fu">-</span><span class="fl">1.8100975778074668</span>,<span class="fl">1.639448210847001</span>,<span class="fu">-</span><span class="fl">1.77070200653487</span>
,<span class="fl">1.639448210847001</span>,<span class="fu">-</span><span class="fl">2.0655753110586246</span>,<span class="fl">2.2309447311243717</span>,<span class="fu">-</span><span class="fl">2.0655753110586246</span>
,<span class="fl">2.2805800406433505</span>,<span class="fu">-</span><span class="fl">2.4631626832202618</span>,<span class="fl">2.2805800406433505</span>,<span class="fu">-</span><span class="fl">2.0655753110586246</span>
,<span class="fl">2.2309447311243717</span>,<span class="fu">-</span><span class="fl">2.0655753110586246</span>,<span class="fl">1.639448210847001</span>,<span class="fu">-</span><span class="fl">1.77070200653487</span>
,<span class="fl">1.639448210847001</span>,<span class="fu">-</span><span class="fl">1.8100975778074668</span>,<span class="fl">1.955013517256328</span>,<span class="fu">-</span><span class="fl">1.8100975778074668</span>
,<span class="fl">1.639448210847001</span>,<span class="fu">-</span><span class="fl">1.77070200653487</span>,<span class="fl">1.639448210847001</span>]</code></pre></div>
<p>this is a compositional method of order 8.</p>
<p>To see a places where function will be evaluated we can use:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> scanl (<span class="fu">+</span>) <span class="dv">0</span> <span class="fu">$</span> ut <span class="dv">6</span> <span class="fu">$</span> ut <span class="dv">4</span> (t <span class="dv">2</span> <span class="dv">1</span>)
[<span class="fl">0.0</span>,<span class="fl">1.639448210847001</span>,<span class="fu">-</span><span class="fl">0.131253795687869</span>,<span class="fl">1.508194415159132</span>,<span class="fu">-</span><span class="fl">0.30190316264833483</span>
,<span class="fl">1.6531103546079933</span>,<span class="fu">-</span><span class="fl">0.15698722319947356</span>,<span class="fl">1.4824609876475274</span>,<span class="fu">-</span><span class="fl">0.28824101888734255</span>
,<span class="fl">1.3512071919596584</span>,<span class="fu">-</span><span class="fl">0.7143681190989661</span>,<span class="fl">1.5165766120254056</span>,<span class="fu">-</span><span class="fl">0.548998699033219</span>
,<span class="fl">1.7315813416101316</span>,<span class="fu">-</span><span class="fl">0.7315813416101302</span>,<span class="fl">1.5489986990332203</span>,<span class="fu">-</span><span class="fl">0.5165766120254043</span>
,<span class="fl">1.7143681190989675</span>,<span class="fu">-</span><span class="fl">0.3512071919596571</span>,<span class="fl">1.2882410188873439</span>,<span class="fu">-</span><span class="fl">0.4824609876475261</span>
,<span class="fl">1.156987223199475</span>,<span class="fu">-</span><span class="fl">0.6531103546079919</span>,<span class="fl">1.3019031626483362</span>,<span class="fu">-</span><span class="fl">0.5081944151591307</span>
,<span class="fl">1.1312537956878703</span>,<span class="fu">-</span><span class="fl">0.6394482108469997</span>,<span class="fl">1.0000000000000013</span>]</code></pre></div>
<p>This way we may obtain a method of any order by the price of a terrible zig-zag of the step points.</p>
<p>Another approach to a compositional method is using Suzuki`s Fractals.</p>
<p>The same schema exists for Suzuki`s Fractals, however how we have a diffierent coefficients:</p>
<p><span class="math display">\[
\begin{eqnarray}
  \gamma_1 = \gamma_2 = \gamma_4 = \gamma_5 = \frac{1}{4-4^{\frac{1}{p+1}}} \\
  \gamma_3 = - \frac{4^{\frac{1}{p+1}}}{4-4^{\frac{1}{p+1}}}
\end{eqnarray}
\]</span></p>
<p>However <span class="math inline">\(t\)</span> and <span class="math inline">\(ut\)</span> methods looks quite ugly and we may want to improve this situation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE ConstraintKinds #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span>
<span class="kw">import </span><span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)
<span class="kw">import </span><span class="dt">Data.Proxy</span>

<span class="co">-- Coefficients</span>
<span class="ot">g1 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
g1 p <span class="fu">=</span>  <span class="dv">1</span> <span class="fu">/</span> (<span class="dv">2</span> <span class="fu">-</span> <span class="dv">2</span><span class="fu">**</span>(<span class="dv">1</span><span class="fu">/</span>(fromIntegral p<span class="fu">+</span><span class="dv">1</span>)))

<span class="ot">g2 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
g2 p <span class="fu">=</span> <span class="fu">-</span> <span class="dv">2</span><span class="fu">**</span>(<span class="dv">1</span><span class="fu">/</span>(fromIntegral p<span class="fu">+</span><span class="dv">1</span>)) <span class="fu">/</span> ( <span class="dv">2</span> <span class="fu">-</span> <span class="dv">2</span><span class="fu">**</span>(<span class="dv">1</span><span class="fu">/</span>(fromIntegral p<span class="fu">+</span><span class="dv">1</span>)))

<span class="ot">g3 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
g3 <span class="fu">=</span> g1

<span class="co">-- Description of the method</span>
<span class="kw">data</span> <span class="dt">RK2</span> <span class="fu">=</span> <span class="dt">RK2</span>

<span class="co">-- Description of the method order</span>
<span class="kw">type</span> family <span class="dt">Order</span><span class="ot"> a ::</span> <span class="dt">Nat</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Order</span> <span class="dt">RK2</span> <span class="fu">=</span> <span class="dv">2</span>

<span class="co">-- Description of symmetric properties of the method</span>
<span class="kw">type</span> family <span class="dt">IsSymmetric</span><span class="ot"> a ::</span> <span class="dt">Constraint</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">IsSymmetric</span> <span class="dt">RK2</span> <span class="fu">=</span> ()

<span class="co">-- One level composition</span>
<span class="ot">buildComposePoints ::</span> forall p <span class="fu">.</span> <span class="dt">KnownNat</span> (<span class="dt">Order</span> p)
                   <span class="ot">=&gt;</span> p <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>]
buildComposePoints p dt <span class="fu">=</span> map (<span class="fu">*</span>dt) [g1 o, g2 o, g3 o]
  <span class="kw">where</span>
    o <span class="fu">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Order</span> p))

<span class="co">-- Composition for the symmetric method</span>
<span class="ot">buildComposePointsSym ::</span> forall p n <span class="fu">.</span> (<span class="dt">UpdateCompose</span> (<span class="dt">Order</span> p <span class="fu">+</span> <span class="dv">2</span>) n, <span class="dt">IsSymmetric</span> p, <span class="dt">KnownNat</span> (<span class="dt">Order</span> p), <span class="dt">KnownNat</span> n)
                      <span class="ot">=&gt;</span> p <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>]
buildComposePointsSym p pn dt <span class="fu">=</span> update (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> ((<span class="dt">Order</span> p) <span class="fu">+</span> <span class="dv">2</span>)) pn (buildComposePoints p dt)

<span class="kw">class</span> <span class="dt">UpdateCompose</span> (<span class="ot">k ::</span> <span class="dt">Nat</span>) (<span class="ot">v::</span><span class="dt">Nat</span>) <span class="kw">where</span>
<span class="ot">  update ::</span> <span class="dt">Proxy</span> k <span class="ot">-&gt;</span> <span class="dt">Proxy</span> v <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>]

<span class="kw">class</span> <span class="dt">UpdateComposeCase</span> (<span class="ot">leq ::</span> <span class="dt">Bool</span>) (<span class="ot">k ::</span> <span class="dt">Nat</span>) (<span class="ot">v ::</span> <span class="dt">Nat</span>) <span class="kw">where</span>
<span class="ot">  updateCase ::</span> <span class="dt">Proxy</span> leq <span class="ot">-&gt;</span> <span class="dt">Proxy</span> k <span class="ot">-&gt;</span> <span class="dt">Proxy</span> v <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>]

<span class="kw">instance</span> <span class="dt">UpdateComposeCase</span> (k <span class="fu">&lt;=?</span> v) k v <span class="ot">=&gt;</span> <span class="dt">UpdateCompose</span> k v <span class="kw">where</span>
  update <span class="fu">=</span> updateCase (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (k <span class="fu">&lt;=?</span> v))

<span class="kw">instance</span> <span class="dt">UpdateComposeCase</span> <span class="dt">False</span> k v <span class="kw">where</span>
  updateCase _ _ _ <span class="fu">=</span> id
  
<span class="kw">instance</span> (<span class="dt">KnownNat</span> k, <span class="dt">UpdateCompose</span> (k<span class="fu">+</span><span class="dv">2</span>) v) <span class="ot">=&gt;</span> <span class="dt">UpdateComposeCase</span> <span class="dt">True</span> k v <span class="kw">where</span>
  updateCase _ k v ds <span class="fu">=</span> update (plus2 k) v (ds <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> map (<span class="fu">*</span>x) [g1 o, g2 o, g3 o])
    <span class="kw">where</span>
      o <span class="fu">=</span> natVal k
<span class="ot">      plus2 ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (n<span class="fu">+</span><span class="dv">2</span>)
      plus2 _ <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>]]></summary>
</entry>
<entry>
    <title>Formal Power series in haskell</title>
    <link href="https://qnikst.github.io/posts/2014-08-11-series.markdown.html" />
    <id>https://qnikst.github.io/posts/2014-08-11-series.markdown.html</id>
    <published>2014-08-12T00:00:00Z</published>
    <updated>2014-08-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Code and math in this post is done with the great help of Korolyov V. This post is written as a literate haskell file so it’s possible to copy it in a text file and run it in ghci. All sources can be found in <a href="https://github.com/qnikst/haskell-fun/tree/master/series">haskell-fun</a> repository.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE BangPatterns #-}</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.Fix</span></code></pre></div>
<p>We want to implement a with formal series expansion using haskell. Formal series can be expressed as follows:</p>
<p><span class="math display">\[ f(x) = \sum\limits_{i=0}^\infty a_ix^i \]</span></p>
<p>And also address a Taylor series as an example. For a function <span class="math inline">\(f\)</span> we can expand it an any given point <span class="math inline">\(x_0\)</span>, then:</p>
<p><span class="math display">\[ f(x) = f(x_0) + \sum_{k=1}\frac{f^{(k)}}{k!}(x-x_0)^k \]</span></p>
<p>Here we wanto to introduce a data structure that is capable for representation of such series. For such datastructure we have 2 main candidates:</p>
<ol style="list-style-type: decimal">
<li><p>List - a datastructure with two constructors that represent a possibly infinite single-linked list.</p></li>
<li><p>Stream - a datastructure with one constructor that represent an infinite stream of values.</p></li>
</ol>
<p>We may want to select a list because this way we may represent a finite series (as some functions have all coefficients equal to <span class="math inline">\(0\)</span> starting at some point, or if function diverge than all element will be represented as machine zero starting at some point). But we decide to use ‘Stream’ data type in order not to have a branching in functions.</p>
<p>It’s possible to use an existing library for <code>Stream</code> – <a href="https://hackage.haskell.org/package/Stream">Stream package</a>. However here we decide to implement our own data type for educational purposes. However if this module will grow to a real library the implementation likely will be changed to the one from the common package.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">S</span> a <span class="fu">=</span> <span class="dt">S</span> <span class="fu">!</span>a (<span class="dt">S</span> a)</code></pre></div>
<p>## Instances</p>
<p>Having a data structure we may define a set of instances.</p>
<p>### Functor</p>
<p>Series is a Functor:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">S</span> <span class="kw">where</span>
<span class="ot">&gt;</span>    fmap f (<span class="dt">S</span> a x) <span class="fu">=</span> <span class="dt">S</span> (f a) (fmap f x)</code></pre></div>
<p>An interesting note that <span class="math inline">\(fmap ~ (f :: a \to b)\)</span> moves a function that is represented by a serie from <span class="math inline">\(a \to a\)</span> to <span class="math inline">\(b \to b\)</span> that may not be a desired behaviour when <span class="math inline">\(a \neq b\)</span>.</p>
<p>### Num</p>
<p>In order to use series in calculations we need to define a <code>Num</code> instance. But befor we will introduce few helpers:</p>
<p>A product of scalar and series:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; (^*) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> (<span class="fu">^*</span>) a <span class="fu">=</span> fmap (<span class="fu">*</span>a)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; (*^) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> (<span class="fu">*^</span>) <span class="fu">=</span> flip (<span class="fu">^*</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; (/^) ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> (<span class="fu">/^</span>) s a <span class="fu">=</span> fmap (<span class="fu">/</span> a) s</code></pre></div>
<p>And pointwise product for future (see Library section for szipWith implementation):</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; (^*^) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> (<span class="fu">^*^</span>) <span class="fu">=</span> szipWith (<span class="fu">*</span>)</code></pre></div>
<p>Now we may give a ‘Num’ instance:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Num</span> (<span class="dt">S</span> a) <span class="kw">where</span>
<span class="ot">&gt;</span>   (<span class="dt">S</span> a x) <span class="fu">+</span> (<span class="dt">S</span> b y) <span class="fu">=</span> <span class="dt">S</span> (a <span class="fu">+</span> b) (x <span class="fu">+</span> y)
<span class="ot">&gt;</span>   abs s <span class="fu">=</span> fmap abs s
<span class="ot">&gt;</span>   negate s <span class="fu">=</span> fmap negate s
<span class="ot">&gt;</span>   signum s <span class="fu">=</span> fmap signum s
<span class="ot">&gt;</span>   (<span class="dt">S</span> a x) <span class="fu">*</span> (<span class="dt">S</span> b y) <span class="fu">=</span> <span class="dt">S</span> (a <span class="fu">*</span> b) (a <span class="fu">^*</span> y <span class="fu">+</span>  b <span class="fu">^*</span> x <span class="fu">+</span> <span class="dt">S</span> <span class="dv">0</span> (x <span class="fu">*</span> y))
<span class="ot">&gt;</span>   fromInteger x <span class="fu">=</span> <span class="dt">S</span> (fromInteger x) <span class="dv">0</span></code></pre></div>
<p>Here are 2 tricky parts, first one is implementation of <code>*</code> second one is implementation of <code>fromInteger</code>. For <code>*</code> we need to think of an expansion like of polymonial, i.e. <span class="math inline">\(S a b = a + b \cdot p\)</span>. Then we can write the following:</p>
<p><span class="math display">\[
\begin{aligned}
 (S~a~x) \cdot (S~b~y) &amp;= (a + x p) \cdot (b + y p) = \\
  &amp;= (a b + a y p + b x p + x y p^2) = \\
  &amp;= S~(a b)~(a y + b x + x y p)     = \\
  &amp;= S~(a b)~(fmap~(*a)~y + fmap~(*b)~x + S~0~(x * y))
\end{aligned}
\]</span></p>
<p>There are 2 possible implementations for fromInteger:</p>
<ol style="list-style-type: decimal">
<li><p><code>fromInteger x = S (fromInteger x) (fromInteger x)</code></p></li>
<li><p><code>fromInteger x = S (fromInteger x) 0</code></p></li>
</ol>
<p>For <code>fromInteger</code> we need to select an implemention such that <span class="math inline">\(fromInteger 1 * a == a\)</span> <span class="math inline">\(fromInteger 0 + a = a\)</span> <span class="math inline">\(fromInteger 0 * a == 0\)</span> for any <span class="math inline">\(a\)</span>. So then we see that we can select only the second one, otherwise properties for <span class="math inline">\(1\)</span> will not hold.</p>
<p>### Fractional</p>
<p>Now we can add a simple Fractional instance.</p>
<p>We say that <span class="math inline">\((S\,b\,y) = \cfrac{1}{(S\, a\, x)}\)</span> iff <span class="math inline">\((S\, b\, y)\)</span> is the solution of equation <span class="math inline">\((S\,b\,y)\,\cdot\,(S\,a\,x) = 1\)</span>. So the following intance is the result of this system of equations:</p>
<p><span class="math display">\[
\begin{aligned}
  b_0 a_0 &amp; = 1,\\
  b_0 a_1 + b_1 a_0 &amp; = 0,\\
  b_0 a_2 + b_1 a_1 + a_2 a_0 &amp; = 0,\\
  \ldots
\end{aligned}
\]</span></p>
<p>These equations can be resursively solved by moving the last term from left-side convolutions to the right side, and dividing by <span class="math inline">\((-a_0)\)</span>. Moreover the rest of terms on the left are convolutions too, then as now series <span class="math inline">\(a\)</span> convolve with the tail of series <span class="math inline">\(b\)</span>. That fact may be used for compact of definition of recursive equations:</p>
<p><span class="math display">\[
\begin{aligned}
  b_0 &amp; = \cfrac{1}{a_0},\\
  b_i &amp; = \cfrac{-1}{a_0} \sum\limits_{j = 0}^{i - 1} b_{j} a_{j + 1}.
\end{aligned}
\]</span></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Fractional</span> (<span class="dt">S</span> a) <span class="kw">where</span>
<span class="ot">&gt;</span>   recip (<span class="dt">S</span> a x) <span class="fu">=</span> fix <span class="fu">$</span> fmap (<span class="fu">/</span> (<span class="fu">-</span>a)) <span class="fu">.</span> <span class="dt">S</span> (<span class="fu">-</span><span class="dv">1</span>) <span class="fu">.</span> (<span class="fu">*</span> x)
<span class="ot">&gt;</span>   fromRational x <span class="fu">=</span> <span class="dt">S</span> (fromRational x) <span class="dv">0</span></code></pre></div>
<p>Formulas for composition and inversion. Only series with zeroed head can be composed or reversed. Composition is handled according to Horner’s method:</p>
<p><span class="math display">\[
\begin{aligned}
  f(x) &amp;= \sum\limits_{i=0}^{\infty} a_i x^i =
           a_0 + x \sum\limits_{i=0}^{\infty} a_{i+1} x^i,\\
  g(x) &amp;= \sum\limits_{j=1}^{\infty} b_j x^j =
           x \sum\limits_{j=0}^{\infty} b_{j+1} x^j, \\
  f(g(x)) &amp;= a_0 + g(x) \sum\limits_{i=0}^{\infty} a_{i+1} g(x)^i = \\
          &amp;= a_0 + x \left(\sum\limits_{j=0}^{\infty} b_{j+1} x^j\right)
              \left(\sum\limits_{i=0}^{\infty} a_{i+1} g(x)^i\right).
\end{aligned}
\]</span></p>
<p>The product of two series can be treated recursively, so:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; compose ::</span> (<span class="dt">Num</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> compose (<span class="dt">S</span> a x) (<span class="dt">S</span> <span class="dv">0</span> y) <span class="fu">=</span> <span class="dt">S</span> a (y <span class="fu">*</span> compose x (<span class="dt">S</span> <span class="dv">0</span> y))
<span class="ot">&gt;</span> compose _ _ <span class="fu">=</span> error <span class="st">&quot;compose: Non-zero head&quot;</span></code></pre></div>
<p>Inversion can be done by the following formula:</p>
<p><span class="math display">\[
\begin{eqnarray}
  f(g(x)) &amp; = x, \\
  a_1 g(x) + a_2 g^2(x) + \ldots &amp; = x, \\
  g(x) (a_1 + a_2 g(x) + \ldots) &amp; = x, \\
  b_1 x + b_2 x^2 + \ldots &amp; = \cfrac{x}{a_1 + a_2 g(x) + \ldots}, \\
  b_1 + b_2 x + \ldots &amp; = \cfrac{1}{a_1 + a_2 g(x) + \ldots}.
\end{eqnarray}
\]</span></p>
<p>The last equality gives the recursive rule:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; inverse ::</span> (<span class="dt">Fractional</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> inverse (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> <span class="kw">let</span> y <span class="fu">=</span> <span class="dt">S</span> <span class="dv">0</span> (recip <span class="fu">$</span> compose x y) <span class="kw">in</span> y
<span class="ot">&gt;</span> inverse _ <span class="fu">=</span> error <span class="st">&quot;inverse: Non-zero head&quot;</span></code></pre></div>
<p>According to general theory elementary special functions cannot be evaluated on the non-zero headed series. We try to handle this situaton by breaking the series into two parts: the head and the zero-headed tail.</p>
<p>The head is treated by classic functions, the tail is treated by composing argument series with classical series of elementary functions, and the combination is done by ad-hoc formulas. The first example of the ad-hoc formula:</p>
<p><span class="math display">\[
\begin{eqnarray}
  \sin \sum\limits_{i = 0}^{\infty} a_i x^i =
       \sin (a_0 + \sum\limits_{i = 1}^{\infty} a_i x^i) =
  \sin a_0 \cdot \cos \sum\limits_{i = 1}^{\infty} a_i x^i +
       \cos a_0 \cdot \sin \sum\limits_{i = 1}^{\infty} a_i x^i.
\end{eqnarray}
\]</span></p>
<p>Here <span class="math inline">\(\cos a_0\)</span> and <span class="math inline">\(\sin a_0\)</span> are sine and cosine of scalar. And the sine/cosine of zero-headed series can be calculated by composition of the argument with well-known series of sine/cosine.</p>
<p>The second example. Let’s look at the <span class="math inline">\(\arcsin\)</span>, definitions:</p>
<p><span class="math display">\[
\begin{eqnarray}
  \sum\limits_{i = 0}^{\infty} b_i x^i = \arcsin \sum\limits_{i = 0}^{\infty} a_i x^i,\\
  \sin\sum\limits_{i = 0}^{\infty} b_i x^i = \sum\limits_{i = 0}^{\infty} a_i x^i.
\end{eqnarray}
\]</span></p>
<p>And solution for an ad-hoc formula is obtained as follows (using the fact <span class="math inline">\(b_0 = \arcsin a_0\)</span>):</p>
<p><span class="math display">\[
\begin{eqnarray}
  \sin\sum\limits_{i = 1}^{\infty} b_i x^i =
    \sin\left(\sum\limits_{i = 0}^{\infty} b_i x^i - b_0 \right) = \\
  = \cos b_0 \cdot \sin\sum\limits_{i = 0}^{\infty} b_i x^i -
    \sin b_0 \cdot \cos\sum\limits_{i = 0}^{\infty} b_i x^i = \\
  = \sqrt{1 - a_0^2} \cdot \sum\limits_{i = 0}^{\infty} a_i x^i -
    a_0 \cdot \sqrt{1 - \left(\sum\limits_{i = 0}^{\infty} a_i x^i\right)^2}.
\end{eqnarray}
\]</span></p>
<p>The full formula is done by adding <span class="math inline">\(b_0\)</span>:</p>
<p><span class="math display">\[
\begin{equation}
  \sum\limits_{i = 0}^{\infty} b_i x^i =
    \arcsin a_0 + \arcsin
       \left[
       \sqrt{1 - a_0^2} \cdot
       \sum\limits_{i = 0}^{\infty} a_i x^i -
       a_0 \cdot \sqrt{1 - \left(\sum\limits_{i = 0}^{\infty} a_i x^i\right)^2}
       \right].
\end{equation}
\]</span></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> (<span class="dt">Floating</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Floating</span> (<span class="dt">S</span> a) <span class="kw">where</span>
<span class="ot">&gt;</span>   pi <span class="fu">=</span> <span class="dt">S</span> pi <span class="dv">0</span>
<span class="ot">&gt;</span>   exp (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> texp <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   exp (<span class="dt">S</span> a x) <span class="fu">=</span> exp a <span class="fu">^*</span> exp (<span class="dt">S</span> <span class="dv">0</span> x)
<span class="ot">&gt;</span>   log (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> tlog <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   log (<span class="dt">S</span> a x) <span class="fu">=</span> <span class="dt">S</span> (log a) <span class="dv">0</span> <span class="fu">+</span> log (<span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> fmap (<span class="fu">/</span> a) x)
<span class="ot">&gt;</span>   sin (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> tsin <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   sin (<span class="dt">S</span> a x) <span class="fu">=</span> sin a <span class="fu">^*</span> cos (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">+</span> cos a <span class="fu">^*</span> sin (<span class="dt">S</span> <span class="dv">0</span> x)
<span class="ot">&gt;</span>   cos (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> tcos <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   cos (<span class="dt">S</span> a x) <span class="fu">=</span> cos a <span class="fu">^*</span> cos (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">-</span> sin a <span class="fu">^*</span> sin (<span class="dt">S</span> <span class="dv">0</span> x)</code></pre></div>
<p>An interesting example is sqrt, as usual we want to find <span class="math inline">\(b_n\)</span> such that:</p>
<p><span class="math display">\[ \sum\limits_{n=0}^\infty b_nx^n \cdot \sum\limits_{n=0}^\infty b_nx^n = \sum\limits_{n=0}^n a_i x^n \]</span></p>
<p>Rewrite the formula in a head-tail form, where <span class="math inline">\(y\)</span> – is a tail of b, and <span class="math inline">\(p\)</span> – is a tail of incomming series:</p>
<p><span class="math display">\[ (b_0 + x * y) (b_ 0 + x * y) = a0 + x p\]</span></p>
<p><span class="math display">\[ b_0^2 + 2 x y + x^2 y = a0 + x p\]</span></p>
<p>by grouping elements with 0 and 1 power of <span class="math inline">\(x\)</span>, we find:</p>
<p><span class="math display">\[
\begin{equation}
  \left\lbrace
  \begin{matrix}
     b_0 &amp; = \sqrt{a_0} \\
     y &amp; = \frac{p-y^2}{2 \sqrt{a_0}}
  \end{matrix}
  \right.
\end{equation}
\]</span></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>   sqrt (<span class="dt">S</span> <span class="dv">0</span> (<span class="dt">S</span> <span class="dv">0</span> x)) <span class="fu">=</span> <span class="dt">S</span> <span class="dv">0</span> (sqrt x)
<span class="ot">&gt;</span>   sqrt (<span class="dt">S</span> <span class="dv">0</span> _) <span class="fu">=</span> <span class="kw">let</span> sq <span class="fu">=</span> <span class="dt">S</span> (<span class="dv">0</span> <span class="fu">/</span> <span class="dv">0</span>) sq <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> sq
<span class="ot">&gt;</span>   sqrt (<span class="dt">S</span> a x) <span class="fu">=</span> <span class="kw">let</span> sqa <span class="fu">=</span> sqrt a
<span class="ot">&gt;</span>                      sqx <span class="fu">=</span> (x <span class="fu">-</span> <span class="dt">S</span> <span class="dv">0</span> (sqx <span class="fu">*</span> sqx)) <span class="fu">/^</span> (<span class="dv">2</span> <span class="fu">*</span> sqrt a)
<span class="ot">&gt;</span>                  <span class="kw">in</span> <span class="dt">S</span> sqa sqx
<span class="ot">&gt;</span>   asin (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> tasin <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   asin (<span class="dt">S</span> a x) <span class="fu">=</span> <span class="kw">let</span> <span class="dt">S</span> _ y <span class="fu">=</span> sqrt (<span class="dv">1</span> <span class="fu">-</span> a <span class="fu">*</span> a) <span class="fu">^*</span> (<span class="dt">S</span> a x) <span class="fu">-</span>
<span class="ot">&gt;</span>                              a <span class="fu">^*</span> sqrt (<span class="dv">1</span> <span class="fu">-</span> (<span class="dt">S</span> a x) <span class="fu">*</span> (<span class="dt">S</span> a x))
<span class="ot">&gt;</span>                  <span class="kw">in</span> <span class="dt">S</span> (asin a) <span class="dv">0</span> <span class="fu">+</span> asin (<span class="dt">S</span> <span class="dv">0</span> y)
<span class="ot">&gt;</span>   acos (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> tacos <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   acos (<span class="dt">S</span> a x) <span class="fu">=</span> <span class="kw">let</span> <span class="dt">S</span> _ y <span class="fu">=</span> a <span class="fu">^*</span> (<span class="dt">S</span> a x) <span class="fu">-</span>
<span class="ot">&gt;</span>                              sqrt (<span class="dv">1</span> <span class="fu">-</span> a <span class="fu">*</span> a) <span class="fu">^*</span> sqrt (<span class="dv">1</span> <span class="fu">-</span> (<span class="dt">S</span> a x) <span class="fu">*</span> (<span class="dt">S</span> a x))
<span class="ot">&gt;</span>                  <span class="kw">in</span> <span class="dt">S</span> (acos a) <span class="dv">0</span> <span class="fu">+</span> acos (<span class="dt">S</span> <span class="dv">0</span> y)
<span class="ot">&gt;</span>   atan (<span class="dt">S</span> <span class="dv">0</span> x) <span class="fu">=</span> tatan <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x
<span class="ot">&gt;</span>   atan (<span class="dt">S</span> a x) <span class="fu">=</span> <span class="kw">let</span> <span class="dt">S</span> _ y <span class="fu">=</span> <span class="dt">S</span> <span class="dv">0</span> x <span class="fu">/</span> (<span class="dv">1</span> <span class="fu">+</span> a <span class="fu">^*</span> (<span class="dt">S</span> a x))
<span class="ot">&gt;</span>                  <span class="kw">in</span> <span class="dt">S</span> (atan a) <span class="dv">0</span> <span class="fu">+</span> atan (<span class="dt">S</span> <span class="dv">0</span> y)
<span class="ot">&gt;</span>   sinh x <span class="fu">=</span> (exp x <span class="fu">-</span> exp (<span class="fu">-</span>x)) <span class="fu">/^</span> <span class="dv">2</span>
<span class="ot">&gt;</span>   cosh x <span class="fu">=</span> (exp x <span class="fu">+</span> exp (<span class="fu">-</span>x)) <span class="fu">/^</span> <span class="dv">2</span>
<span class="ot">&gt;</span>   asinh x <span class="fu">=</span> log (x <span class="fu">+</span> sqrt (x <span class="fu">*</span> x <span class="fu">+</span> <span class="dv">1</span>))
<span class="ot">&gt;</span>   acosh x <span class="fu">=</span> undefined <span class="co">-- log (x + sqrt (x * x - 1))</span>
<span class="ot">&gt;</span>   atanh x <span class="fu">=</span> log ((<span class="dv">1</span> <span class="fu">+</span> x) <span class="fu">/</span> (<span class="dv">1</span> <span class="fu">-</span> x)) <span class="fu">/^</span> <span class="dv">2</span></code></pre></div>
<p>## Library</p>
<p>Now we can define mathematic functions on the power series. The derivative:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; diff ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> diff s <span class="fu">=</span> fmap fromInteger (fromList [<span class="dv">1</span><span class="fu">..</span>]) <span class="fu">^*^</span> stail s</code></pre></div>
<p>And the integral:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; integral ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> integral c  s <span class="fu">=</span> <span class="dt">S</span> c (s <span class="fu">^*^</span> fmap (recip<span class="fu">.</span>fromInteger) (fromList [<span class="dv">1</span><span class="fu">..</span>]) )</code></pre></div>
<p>### Generic functions:</p>
<p>In order to inspect a stream we can introduce a helper function:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; stake ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> stake <span class="dv">0</span> _       <span class="fu">=</span> []
<span class="ot">&gt;</span> stake n (<span class="dt">S</span> a s) <span class="fu">=</span> a<span class="fu">:</span>stake (n<span class="fu">-</span><span class="dv">1</span>) s</code></pre></div>
<p>Here all functions will be prefixed with <code>s</code> however if you write a module for working with streams you may prefer to not add it and ask user to import module qualified.</p>
<p>Here is a function that builds a stream from the list (and the other way):</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fromList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> fromList (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">S</span> x (fromList xs) <span class="co">-- works only on infinite list</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; fromListNum ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> fromListNum [] <span class="fu">=</span> <span class="dv">0</span>
<span class="ot">&gt;</span> fromListNum (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">S</span> x (fromListNum xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt; toList ::</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> toList (<span class="dt">S</span> x xs) <span class="fu">=</span> x <span class="fu">:</span> toList xs</code></pre></div>
<p>In order to write an usefull functions and series we will introduce a folding:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sscan ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> b <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> sscan f i (<span class="dt">S</span> x s) <span class="fu">=</span>
<span class="ot">&gt;</span>  <span class="kw">let</span> k <span class="fu">=</span> f i x
<span class="ot">&gt;</span>  <span class="kw">in</span> <span class="dt">S</span> k (sscan f k s)</code></pre></div>
<p>Now lets introduce few functions using <code>sfold</code>. A function that will generate a sum of the Stream, i.e. having a stream <code>ssum &lt;a0:a1:a2:..&gt; = &lt;a0:a0+a1:a0+a1+a2:...&gt;</code></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ssum ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> ssum <span class="fu">=</span> sscan (<span class="fu">+</span>) <span class="dv">0</span></code></pre></div>
<p>Build a stream by iterating a function</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; siterate ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> siterate f x <span class="fu">=</span> <span class="dt">S</span> x (siterate f (f x))</code></pre></div>
<p>Build a serie of powers: <span class="math inline">\(&lt;x,x^2,x^3,...&gt;\)</span></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> spower x <span class="fu">=</span> <span class="dt">S</span> <span class="dv">1</span> (siterate (<span class="fu">*</span>x) x)</code></pre></div>
<p>Unfold</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sunfold ::</span> (c <span class="ot">-&gt;</span> (c,a)) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> sunfold f k <span class="fu">=</span> <span class="kw">let</span> (k&#39;,a) <span class="fu">=</span> f k <span class="kw">in</span> <span class="dt">S</span> a (sunfold f k&#39;)</code></pre></div>
<p>Because we want to implement a teylor serie we want to have a serie of factorials</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sfac ::</span> (<span class="dt">Enum</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> sfac <span class="fu">=</span> sscan (<span class="fu">*</span>) <span class="dv">1</span> (fromList [<span class="dv">1</span><span class="fu">..</span>]) </code></pre></div>
<p>And now 1/factorials</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sdfac ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> sdfac <span class="fu">=</span> fmap (\x <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">/</span> (fromIntegral x)) sfac</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; szipWith ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> b <span class="ot">-&gt;</span> <span class="dt">S</span> c
<span class="ot">&gt;</span> szipWith f (<span class="dt">S</span> a x) (<span class="dt">S</span> b y) <span class="fu">=</span> <span class="dt">S</span> (f a b) (szipWith f x y)</code></pre></div>
<p>This is an actual building of the Taylor serie:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; build ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> build t s <span class="fu">=</span> ssum <span class="fu">$</span> spower t <span class="fu">^*^</span> s</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; shead ::</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> shead (<span class="dt">S</span> a s) <span class="fu">=</span> a</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; stail ::</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> stail (<span class="dt">S</span> a s) <span class="fu">=</span> s</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sdropWhile ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> sdropWhile p s<span class="fu">@</span>(<span class="dt">S</span> a xs)
<span class="ot">&gt;</span>   <span class="fu">|</span> p a <span class="fu">=</span> sdropWhile p xs
<span class="ot">&gt;</span>   <span class="fu">|</span> otherwise <span class="fu">=</span> s</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; eps ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> eps e s <span class="fu">=</span> snd <span class="fu">.</span> shead <span class="fu">.</span> sdropWhile (\(x,y) <span class="ot">-&gt;</span> abs (x <span class="fu">-</span> y) <span class="fu">&gt;=</span> e)
<span class="ot">&gt;</span>         <span class="fu">$</span> szipWith (,) s (stail s)</code></pre></div>
<p>## Taylor series for some analytic functions</p>
<p>Here we defined examples for the functions with analytically known series at 0.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; texp ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> texp <span class="fu">=</span> <span class="dt">S</span> <span class="dv">1</span> sdfac</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tlog ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tlog <span class="fu">=</span> <span class="kw">let</span> go n s <span class="fu">=</span> <span class="dt">S</span> (s <span class="fu">/</span> n) (go (n <span class="fu">+</span> <span class="dv">1</span>) (<span class="fu">-</span>s))
<span class="ot">&gt;</span>        <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span> <span class="dv">1</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tsin ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tsin <span class="fu">=</span> <span class="kw">let</span> s <span class="fu">=</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">.</span> <span class="dt">S</span> (<span class="fu">-</span><span class="dv">1</span>) <span class="fu">$</span> s
<span class="ot">&gt;</span>        <span class="kw">in</span> s <span class="fu">^*^</span> texp</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tcos ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tcos <span class="fu">=</span> <span class="kw">let</span> s <span class="fu">=</span> <span class="dt">S</span> <span class="dv">1</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">.</span> <span class="dt">S</span> (<span class="fu">-</span><span class="dv">1</span>) <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> s
<span class="ot">&gt;</span>        <span class="kw">in</span> s <span class="fu">^*^</span> texp</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tasin ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tasin <span class="fu">=</span> <span class="kw">let</span> go n <span class="fu">=</span> <span class="dt">S</span> (<span class="dv">1</span> <span class="fu">/</span> n) (fmap (<span class="fu">*</span> (n <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>))) <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> go (n <span class="fu">+</span> <span class="dv">2</span>))
<span class="ot">&gt;</span>         <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tacos ::</span> (<span class="dt">Eq</span> a, <span class="dt">Floating</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tacos <span class="fu">=</span> pi <span class="fu">/</span> <span class="dv">2</span> <span class="fu">-</span> tasin</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tatan ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tatan <span class="fu">=</span> <span class="kw">let</span> go s n <span class="fu">=</span> <span class="dt">S</span> (s <span class="fu">/</span> n) <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> go (<span class="fu">-</span>s) (n <span class="fu">+</span> <span class="dv">2</span>)
<span class="ot">&gt;</span>         <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> go <span class="dv">1</span> <span class="dv">1</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tsinh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tsinh <span class="fu">=</span> <span class="kw">let</span> s <span class="fu">=</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="fu">$</span> s
<span class="ot">&gt;</span>         <span class="kw">in</span> s <span class="fu">^*^</span> texp</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tcosh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tcosh <span class="fu">=</span> <span class="kw">let</span> s <span class="fu">=</span> <span class="dt">S</span> <span class="dv">1</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> s
<span class="ot">&gt;</span>         <span class="kw">in</span> s <span class="fu">^*^</span> texp</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tasinh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tasinh <span class="fu">=</span> <span class="kw">let</span> go s n <span class="fu">=</span> <span class="dt">S</span> (s <span class="fu">/</span> n) (fmap (<span class="fu">*</span> (n <span class="fu">/</span> (n <span class="fu">+</span> <span class="dv">1</span>))) <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> go (<span class="fu">-</span>s) (n <span class="fu">+</span> <span class="dv">2</span>))
<span class="ot">&gt;</span>          <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span> <span class="dv">1</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tacosh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tacosh <span class="fu">=</span> undefined</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tatanh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a
<span class="ot">&gt;</span> tatanh <span class="fu">=</span> <span class="kw">let</span> go n <span class="fu">=</span> <span class="dt">S</span> (recip n) <span class="fu">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="fu">$</span> go (n <span class="fu">+</span> <span class="dv">2</span>)
<span class="ot">&gt;</span>          <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span>)</code></pre></div>
<p>## TODO</p>
<p>Some things were not covered in this file, taylor series were not statically protected agains calling actions on the series build at the different points, so we assume that every Taylor serie is built at <span class="math inline">\(0\)</span>.</p>
<p>Not all functions from the Floating instance were implemented.</p>
<p>It’s possible to generalize <span class="math inline">\(asin/sin\)</span> approach for a wider class of functions, but it was not done yet.</p>]]></summary>
</entry>
<entry>
    <title>Playing with types: type level numbers</title>
    <link href="https://qnikst.github.io/posts/2014-08-07-playing-with-types.html" />
    <id>https://qnikst.github.io/posts/2014-08-07-playing-with-types.html</id>
    <published>2013-12-30T00:00:00Z</published>
    <updated>2013-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>As always I’m terribly sorry for my bad english, but writing the posts and having a feedback is the only reasonable way to improve it.</p>
</blockquote>
<p>This post describes an easy exercise that gives a feeling of use typelevel numbers. This post is a part of another work that hopefully will be covered in following posts.</p>
<p>If you want to know more about typelevel literals and friends you can take a look at the <a href="http://ponies.io/posts/2014-07-30-typelits.html">following post</a> it describes the theory much better than I can.</p>
<p>Intead of using type level Strings we will address numbers. In this post I want to create a datatype that will contain a number that is known <em>statically</em> (at compilation time) and which can be extracted from type at <em>runtime</em>.</p>
<p>The first part of the problem (having a number) in a type may be interesting if you want to distiguish types assosiated with different numbers.</p>
<p>For simplicity we will take <a href="https://hackage.haskell.org/package/tagged-0.7.2/docs/Data-Tagged.html">Data.Tagged.Tagged</a> type from <code>tagged</code> package. However it’s possible to create our own type as I did at the beggining (just I did a first time).</p>
<p>We add helper methods that allow us to extract infomation about the type-parameter from the value:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toProxy ::</span> <span class="dt">Tagged</span> n a  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n
toProxy _ <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>And add a constrictor helper that allow to create a type with information about number that is provided by us.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkT ::</span> proxy n <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tagged</span> n a
mkT _ a <span class="fu">=</span> <span class="dt">Tagged</span> a</code></pre></div>
<p>Just check that we can create a fancy values:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Nothing</span>) <span class="dv">8</span>
mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Nothing</span>) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> <span class="ch">&#39;Nothing a</span></code></pre></div>
<h1 id="naturals">Naturals</h1>
<p>From this point we can start real fun. At first lest create a value with natural type parameter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span>
mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> <span class="dv">3</span> a</code></pre></div>
<p>Now we want to be able to use this information at runtime. Let’s introduce a new method that will use <code>natVal</code> function:</p>
<pre class="haskel"><code>natVal :: forall n proxy. KnownNat n =&gt; proxy n -&gt; Integer` </code></pre>
<p>take a type that acts as a type proxy and returns the integer assosiated with a type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">useT ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Tagged</span> n a <span class="ot">-&gt;</span> a
useT t<span class="fu">@</span>(<span class="dt">Tagged</span> a) <span class="fu">=</span> fromIntegral (natVal (toProxy t)) <span class="fu">+</span> a</code></pre></div>
<p>Here we are:</p>
<ol style="list-style-type: decimal">
<li><p>extracting type information by calling <code>toProxy</code></p></li>
<li><p>extracting natural number from a proxy by calling <code>natVal</code></p></li>
<li><p>returning a calculated results</p></li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> useT <span class="fu">$</span> mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span>
<span class="dv">11</span></code></pre></div>
<h1 id="positive-rational">Positive rational</h1>
<p>On the next step we will introduce a code that works for natural numbers, by definition rational number is <code>a % b</code>, where <code>a \in Z</code> and <code>b \in N</code>. Lets lift this information to a type level by introducing a typelevel rational:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> (<span class="fu">:%%</span>) a b</code></pre></div>
<p>And introduce type extraction mechanisms</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | extract numerator type</span>
numerator<span class="ot"> ::</span> proxy (n <span class="fu">:%%</span> m) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n
numerator _ <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="co">-- | Extract denomenator type </span>
<span class="ot">denomenator ::</span> proxy (n <span class="fu">:%%</span> m)  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> m
denomenator _ <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>Today we don’t conver math operations over the type-parameters, this may be a topic for another post. So now we may be quite happy as we can create values tagged by something that looks like a rational number.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span>
mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>) a</code></pre></div>
<p>Now we can write a function that will use information about the type at runtime:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">useTF ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (n <span class="fu">:%%</span> m) a <span class="ot">-&gt;</span> a
useTF t<span class="fu">@</span>(<span class="dt">Tagged</span> a) <span class="fu">=</span> v <span class="fu">+</span> a
  <span class="kw">where</span> v <span class="fu">=</span> fromRational <span class="fu">$</span>
               natVal (numerator <span class="fu">$</span> toProxy t) <span class="fu">:%</span> natVal (denomenator <span class="fu">$</span> toProxy t)</code></pre></div>
<p>Lets check:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> useTF <span class="fu">$</span> mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span>
<span class="fl">8.375</span></code></pre></div>
<h1 id="positive-real.">Positive real.</h1>
<p>Now we want to solve the following problem: it’s not easy to write types for ratio, the reason that for a complex cases we need somehow to find the ratio that fits. Also we want to support real numbers. Having in mind the fact that real values are not supported on the typelevel, we may be quite happy with Rational approximation.</p>
<p>In order to solve those 2 problems we need:</p>
<ol style="list-style-type: decimal">
<li><p>real values support</p></li>
<li><p>ability to write code easily</p></li>
</ol>
<p>We will introduce a TH function that will find a good approximation and create required type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkFloatProxy ::</span> <span class="dt">RealFrac</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span>
mkFloatProxy x <span class="fu">=</span> [<span class="fu">|</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="fu">$</span>(nk a) <span class="fu">:%%</span> <span class="fu">$</span>(nk b)) <span class="fu">|</span>]
  <span class="kw">where</span> (a <span class="fu">:%</span> b) <span class="fu">=</span> toRational x
          nk x <span class="fu">=</span> sigT (litT (numTyLit x)) (<span class="dt">ConT</span> <span class="fu">$</span> mkName <span class="st">&quot;Nat&quot;</span>)</code></pre></div>
<p>the magic that we have in <code>nk x</code> we need to create a type parameter of kind <code>Nat</code>. Now we can write a code like:</p>
<blockquote>
<p>test = mkT $(mkFloatProxy pi) 7.0</p>
</blockquote>
<p>This is quite nice, next steps may be support of negative values, using SomeNat and operations on values.</p>]]></summary>
</entry>

</feed>
