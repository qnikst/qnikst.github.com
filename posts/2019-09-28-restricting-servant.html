<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Qnikst blog - Resticting servant query parameters</title>
    <!-- Bootstrap -->
    <link href="../style.css" rel="stylesheet" media="screen">
    <script src="https://code.jquery.com/jquery-latest.js"></script> 
    <script src="../js/bootstrap.min.js"></script>
    
    
</head>

<body>
  <div id="header">
      <div id="caption"><a href="../">Qnikst's blog</a></div>
      <div id="navigation">
      <a href="../posts.html">Archive</a>
      <a href="../projects.html">Projects</a>
      <a href="../contact.html">Contacts</a>
      <a href="../rss.xml">RSS</a>
      </div>
  </div>

  <div id="content">
    <div class="page-header">
    <div class="right">
      <strong>December 28, 2019</strong>
    </div>
    <h1>Resticting servant query parameters</h1>
    <div class="post-author">by <em>Alexander Vershilov</em>  </div>
    <div class="keywords"><strong>Keywords:</strong> <a title="All pages tagged 'haskell'." href="../tags/haskell.html">haskell</a></div>
</div>

<p>In this post, I’d like to share one solution to the problem I had at work. It is split into three parts: <a href="#problem">the definition of the problem</a>, <a href="#boring">boring part</a> (how we can achieve the goal), and then something <a href="#fancy">fancy</a> we can have if we go further with the solution.</p>
<h2 id="the-problem-definition"><a name="problem">The problem definition</a></h2>
<p>TLDR we want to make our servant service to reply <code>404</code> whenever we see a particular query part in some endpoint subtree. If you are not interested in why do I need that you can proceed to the <a href="#boring">solution</a> directly.</p>
<p>I’m working on building a few web services. One of them provides a service to run contests. In such contests lots of people come at once to solve some tasks. Thus we have a severe load in a bounded amount of time (It’s not entirely true as those contests are running all the time but the most of them are quite small). However, we have a numer of significant events with up to 20k unique visitors in just 3 hours, generating a load a bit higher than 500rps. This is not a high value but the main problem here is that any issue with availability or responsiveness hits our reputation a lot. Additionally in the past we had experienced DDOS attacks during such events. Currently our services can handle in the worst case a load at least three times higher than that but still, we are interested in reducing the surface of possible attacks. Even if we can handle many requests the network bandwidth in the cluster is not very wide, as a result it’s possible to introduce a denial of service by requesting many large files.</p>
<p>External CDN service (pic.1) is just a 3rd party service that provides API for uploading and removing files. Such a service takes all responsibilities for distributing data and providing the required quality of service. All you need to do in your user-facing service is to give links to this third-party service. The cost of that is that you need to upload and control files on that service explicitly.</p>
<p><img src="../images/posts/servant/external.png" /></p>
<p>Transparent CDN service (pic.2) is a service that acts as a distributed proxy for your service. In addition to proxying requests it stores and propagates files on its nodes based on response headers it sees. With hepl of that you can control all the data on CDN. Besides, such a service often provides a firewall and anti-DDOS services.</p>
<p><img src="../images/posts/servant/transparent.png" /></p>
<p>We chose a transparent CDN service because our patterns of working with contests are quite intricate: until frozen files are not expected to be cached and may mutate, but once frozen a file can never mutate and should be persisted. Additionally, we get DDOS protection and a firewall for free.</p>
<p>But just plugging a transparent CDN service in front of yours will not work. CDN is very simple: it does not and can’t analyse actual traffic, so if a malicious user asks for <code>https://our.service/content/big_image</code>, and then <code>https://our.service/content/big_image?foobar</code> both requests will pass through CDN and will need to be served by our service. This way attacker can generate infinite amount of URLs and be able to attack the service no matter if there is a CDN or not.</p>
<p>But what to do? One option is to forbid access to content if there is a query part in an URL. It looks like a sane option as “valid” clients never access content while adding query parameters. For some parts of the service it’s done by NGINX rules. But for other parts of it the service itself is responsible for generating contents and setting proper headers and we want it to be able to reply with 404 for such queries.</p>
<h2 id="the-solution."><a name="boring">The solution</a>.</h2>
<p>We use <a href="https://hackage.haskell.org/package/servant">servant</a> as a framework to write our server. It allows writing a declarative description of the service structure on the type level. More details on that may be found in the servant <a href="http://docs.servant.dev/en/stable/tutorial/index.html">tutorial</a>, or the very basic <a href="https://qnikst.github.io/posts/2018-10-09-starting-webapp.html">howto</a>.</p>
<p>We want to restrict query parameters on some part of the endpoints tree. It may look like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> <span class="dt">MyService</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="ot">=</span> <span class="st">&quot;content&quot;</span> <span class="op">:&gt;</span> <span class="dt">RestrictQueryParams</span> <span class="op">:&gt;</span> <span class="dt">ContentEndpoint</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>  <span class="op">&lt;|&gt;</span> other<span class="op">..</span>end<span class="op">..</span>points</span></code></pre></div>
<p>This way, <code>ContentEndpoint</code> doesn’t know that it was restricted and can implement its logic without knowing how is it called. It is a crucial point that provides the necessary abstraction level.</p>
<p>We are going to implement <code>RestrictQueryParam</code> now. To achieve this we need to introduce a new servant combinator: something like Capture, QueryParam or other from the <a href="https://hackage.haskell.org/package/servant-0.16.2/docs/Servant-API.html">Servant.API</a> hierarchy. It’s not particularly well documented but there are enough examples in the servant itself.</p>
<p>The first thing we need is to introduce a type for</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- | Forbid passing any query parameter.</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">-- If the parameter is given, then we throw 404</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">data</span> <span class="dt">RestrictQueryParams</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="kw">deriving</span> <span class="dt">Typeable</span></span></code></pre></div>
<p>Note that it doesn’t have a type constructor - this construction may live on the type level only.</p>
<p>The next step is implementing a <a href="https://hackage.haskell.org/package/servant-server-0.16.2/docs/Servant-Server.html#t:HasServer"><code>HasServer</code></a> instance. This instance describes how we parse a request and how we work with a response.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">instance</span></span>
<span id="cb3-2"><a href="#cb3-2"></a> (<span class="dt">HasServer</span> api context) <span class="co">{-1-}</span></span>
<span id="cb3-3"><a href="#cb3-3"></a> <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (<span class="dt">RestrictQueryParams</span> <span class="op">:&gt;</span> api) context <span class="kw">where</span> <span class="co">{-2-}</span></span>
<span id="cb3-4"><a href="#cb3-4"></a> <span class="kw">type</span> <span class="dt">ServerT</span> (<span class="dt">RestrictQueryParams</span> <span class="op">:&gt;</span> api) m <span class="ot">=</span> <span class="dt">ServerT</span> api m <span class="co">{-3-}</span></span>
<span id="cb3-5"><a href="#cb3-5"></a> hoistServerWithContext <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb3-6"><a href="#cb3-6"></a> route <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>The instance is very straighforward: it tells that the internal server (<code>{-1-}</code>) wrapped in the <code>RestrictQueryParams</code> (<code>{-2-}</code>) is also a server. Type <code>ServerT</code> tells the resulting server type. In our case it’s the same as for the internal server: RestrictQueryParams doesn’t change it. <code>hoistServerWithContext</code> tells how to change underlying monad if needed, you skip it and see how it’s implemented in the other combinators:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>  hoistServerWithContext _ pc nt s</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="ot">=</span> hoistServerWithContext (<span class="dt">Proxy</span><span class="ot">::</span> <span class="dt">Proxy</span> api) pc nt s</span></code></pre></div>
<p>And the last but not the least method is <code>route</code> that describes the routing itself.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a>  route <span class="dt">Proxy</span> context subserver <span class="ot">=</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>     route (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api) context <span class="op">$</span> add subserver</span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="kw">where</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>      add <span class="dt">Delayed</span>{<span class="op">..</span>} <span class="ot">=</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>        <span class="dt">Delayed</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>          { paramsD <span class="ot">=</span> withRequest check <span class="op">*&gt;</span> paramsD</span>
<span id="cb5-7"><a href="#cb5-7"></a>          , <span class="op">..</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>          }</span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="ot">      check ::</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">DelayedIO</span> ()</span>
<span id="cb5-10"><a href="#cb5-10"></a>      check req</span>
<span id="cb5-11"><a href="#cb5-11"></a>        <span class="op">|</span> <span class="fu">not</span> <span class="op">$</span> B.null <span class="op">$</span> rawQueryString req <span class="ot">=</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>          delayedFailFatal err404</span>
<span id="cb5-13"><a href="#cb5-13"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">pure</span> ()</span></code></pre></div>
<p>Here we add a parameters check to the internal server checks (<code>add subserver</code>). It checks the <code>Wai.Request</code> (<code>withRequest check</code>) in addition to the checks added by internal server (<code>*&gt; paramsD</code>), keeping other checks untouched. In the <code>check</code> function we check <code>rawQueryString</code> and reply with a 404 if it’s not empty. Description of the request checks is given in the <a href="https://hackage.haskell.org/package/servant-server-0.16.2/docs/Servant-Server-Internal-Delayed.html#t:Delayed">docs</a>.</p>
<p>Instances for client and swagger are trivial; they pass all the work to the internal API.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">instance</span> (<span class="dt">HasSwagger</span> api) <span class="ot">=&gt;</span> <span class="dt">HasSwagger</span> (<span class="dt">RestrictQueryParams</span> <span class="op">:&gt;</span> <span class="dt">API</span>) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>  toSwagger _ <span class="ot">=</span> toSwagger (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api)</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">instance</span> <span class="dt">HasClient</span> m api <span class="ot">=&gt;</span> <span class="dt">HasClient</span> m (<span class="dt">RestrictQueryParams</span> <span class="op">:&gt;</span> api) <span class="kw">where</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>  <span class="kw">type</span> <span class="dt">Client</span> m (<span class="dt">RestrictQueryParams</span> <span class="op">:&gt;</span> api) <span class="ot">=</span> <span class="dt">Client</span> m api</span>
<span id="cb6-6"><a href="#cb6-6"></a>  clientWithRoute pm <span class="dt">Proxy</span> req <span class="ot">=</span> clientWithRoute pm (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api) req</span>
<span id="cb6-7"><a href="#cb6-7"></a>  hoistClientMonad pm _ f cl <span class="ot">=</span> hoistClientMonad pm (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api) f cl</span></code></pre></div>
<p>This way, it has landed in our codebase because it just solves the problem. Adding this check solves our problem and can be reused in other projects.</p>
<h2 id="more-checks"><a name="fancy">More checks</a></h2>
<p>But there is a problem. Sub server doesn’t know about that it runs in the restricted context but the server itself should know if this restriction can be safely applied. It can’t be used if the server uses query parameters. So we want to prove that we don’t have such a problem. It can be achieved using <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html#t:TypeError">custom type erros</a>, see more on docs on the <a href="https://gitlab.haskell.org/ghc/ghc/wikis/proposal/custom-type-errors">ghc wiki</a>.</p>
<p>To use them we need to introduce an additional type family. You may think of a type family as a function on types, that can perform pattern matching on types and return some result. In our case this function should either return a error or the same type. We need to traverse servant endpoint structure and return a type error when required.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">CheckNoParams</span> e <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="dt">CheckNoParams</span> (f <span class="op">:&gt;</span> g) <span class="ot">=</span> f <span class="op">:&gt;</span> (<span class="dt">CheckNoParams</span> g)</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="dt">CheckNoParams</span> (f <span class="op">:&lt;|&gt;</span> g) <span class="ot">=</span> <span class="dt">CheckNoParams</span> f <span class="op">:&lt;|&gt;</span> <span class="dt">CheckNoParams</span> g</span>
<span id="cb7-4"><a href="#cb7-4"></a>  <span class="dt">CheckNoParams</span> (<span class="dt">QueryParam</span> sym x <span class="op">:&gt;</span> y) <span class="ot">=</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="dt">TypeError</span> (<span class="dt">'Text</span> <span class="st">&quot;can't use QueryParam under RestrictQueryParams&quot;</span>)</span>
<span id="cb7-6"><a href="#cb7-6"></a>  <span class="dt">CheckNoParams</span> a <span class="ot">=</span> a</span></code></pre></div>
<p>With this code we recursively go through all endpoints (lines 1 and 2), return an error if we see a query param (line 3), and type as it was if it’s not a QueryParam (line 5)</p>
<p>If you’ll use <code>RestrictQueryParam</code> on the endpoint that uses a query you’ll get the following error message:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a>src<span class="op">/</span>Server.hs<span class="op">:</span><span class="dv">124</span><span class="op">:</span><span class="dv">9</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>    • can't use <span class="dt">QueryParam</span> under <span class="dt">RestrictQueryParams</span></span></code></pre></div>
<p>I think after the post it will land in the codebase as well.</p>
<p>But it’s possible to go even further and allow the headers that are used in the internal site. Unfortunately this problem is much more complex and I’m not sure if checks will not be too expensive, but if anyone has a solution I’ll be happy to check it out.</p>

<hr />
<div id="sociallinks" class="pull-left">
    <strong>Share on:</strong>
  <a href="https://twitter.com/home?status=http://qnikst.github.io/posts/2019-09-28-restricting-servant.html" target="_blank" class="social" title="twit it">t</a>  
  <a href="http://www.facebook.com/sharer/sharer.php?u=http://qnikst.github.io/posts/2019-09-28-restricting-servant.html" target="_blank" class="social" title="share on facebook">F</a> 
  <a href="https://plus.google.com/share?url=http://qnikst.github.io/posts/2019-09-28-restricting-servant.html" target="_blank" class="social" title="share on g+">g</a>
</div>

<br class="clearfix" />
<hr />


<div id="disqus_thread"></div>
  <script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'qnikst'; // required: replace example with your forum shortname

  (function() {
     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                                                                                                           

  </div>

  <footer>
    powered by <a href="http://jaspervdj.be/hakyll">Hakyll</a> &amp; <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a>
  </footer>

<script type="text/javascript">
    //      <noscript> я очень хочу вас посчитать, напишите комментарий хотя бы, пожааалуйста </noscript>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-38941774-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>
