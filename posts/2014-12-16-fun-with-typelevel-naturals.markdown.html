<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Qnikst blog - Approaches to carry a proof for typelevel natural</title>
    <!-- Bootstrap -->
    <link href="../style.css" rel="stylesheet" media="screen">
    <script src="https://code.jquery.com/jquery-latest.js"></script> 
    <script src="../js/bootstrap.min.js"></script>
    
    
</head>

<body>
  <div id="header">
      <div id="caption"><a href="../">Qnikst's blog</a></div>
      <div id="navigation">
      <a href="../posts.html">Archive</a>
      <a href="../projects.html">Projects</a>
      <a href="../contact.html">Contacts</a>
      <a href="../rss.xml">RSS</a>
      </div>
  </div>

  <div id="content">
    <div class="page-header">
    <div class="right">
      <strong>December 16, 2014</strong>
    </div>
    <h1>Approaches to carry a proof for typelevel natural</h1>
    <div class="post-author">by <em>Vershilov A.V.</em> <a href="https://creativecommons.org/licenses/by/3.0"><img src="https://i.creativecommons.org/l/by/3.0/88x31.png" /></a> </div>
    <div class="keywords"><strong>Keywords:</strong> <a href="../tags/haskell.html">haskell</a>, <a href="../tags/typenats.html">typenats</a></div>
</div>

<p>For time ago Bas van Dijk asked a question on glasgow-haskell-users mailing list about <a href="https://www.haskell.org/pipermail/glasgow-haskell-users/2014-November/025451.html">proving the properties of type-level natural numbers obtained by user</a>. That lead to an interesting discussion, that you can read in the list archives.</p>
<p>The problem was that we want to impose a constraint on some typelevel natural and then read value from user and guarantee that we have that constraint. For such constraint we took (&lt;=255).</p>
<p>Here is a file that describe few approaches to solve this problem.</p>
<p>At first we need to use a HUGE list of pragmas.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE GADTs #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE KindSignatures #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">{-# LANGUAGE ViewPatterns #-}</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">{-# LANGUAGE PolyKinds #-}</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="ot">{-# LANGUAGE RankNTypes #-}</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a></code></pre></div>
<p>And relax compiler options a bit.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# OPTIONS_GHC -ftype-function-depth=1024 #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">{-# OPTIONS_GHC -fcontext-stack=1024 #-}</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">import</span> <span class="dt">GHC.Exts</span> </a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Constraint</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Type.Bool</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="kw">import</span> <span class="dt">System.Environment</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Unsafe.Coerce</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Data.Singletons</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Control.Monad</span></a></code></pre></div>
<h3 id="attempt-1-tagged-value">Attempt-1: Tagged value</h3>
<p>We can keep a proof together with value, so we can introduce a new type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Proof</span> n  (<span class="ot">c ::</span> <span class="dt">Constraint</span>) <span class="kw">where</span> <span class="dt">Proof</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof</span> n c</a></code></pre></div>
<p>In mailing list I provide following code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">fromSomeError ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof</span> n (n <span class="fu">&lt;=</span> <span class="dv">255</span>))</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">fromSomeError (<span class="dt">SomeNat</span> p)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">   <span class="fu">|</span> natVal p <span class="fu">&lt;=</span> <span class="dv">255</span> <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Proof</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n))</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">   <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>This is obviously a bug as we check natVal p, but return Proxy n. And correct version fails, as there is no way to simply inject a constraint.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">{-</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co">fromSome :: SomeNat -&gt; Maybe (Proof n (n &lt;= 255))</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="co">fromSome (SomeNat p)</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="co">  | natVal p &lt;= 255 = Just (Proof p)</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="co">  | otherwise = Nothing</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="co">-}</span></a></code></pre></div>
<pre><code> Proof.lhs:53:37:
    Could not deduce (n1 ~ n)
    from the context (KnownNat n1)
    bound by a pattern with constructor
        SomeNat :: forall (n :: Nat). KnownNat n =&gt; Proxy n -&gt; SomeNat,
	in an equation for ‘fromSome’
	at Proof.lhs:52:13-21</code></pre>
<h3 id="attempt-2-type-carrier">Attempt-2: Type carrier</h3>
<p>Now we want to have the following constraint on out Nat</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Proof2</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="dt">Proof2</span><span class="ot"> ::</span> c n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c</a></code></pre></div>
<p>In order to have a ‘curried’ version of our constaint we can introduce a type family</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">LessThan255</span><span class="ot"> n ::</span> <span class="dt">Constraint</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="dt">LessThan255</span> f <span class="fu">=</span> (f <span class="fu">&lt;=</span> <span class="dv">255</span>)</a></code></pre></div>
<p>Now lets try to create a proof from known natural:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">{-</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co">strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="co">strange = Proof2</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="co">-}</span></a></code></pre></div>
<p>~~~~~~~~~~~~~~~ Proof.lhs:89:13: Could not deduce (LessThan255 n) arising from a use of ‘Proof2’ from the context (LessThan255 n) bound by the type signature for strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255 ~~~~~~~~~~~~~~</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">strange ::</span> (<span class="dt">LessThan255</span> <span class="fu">~</span> c, c n) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">strange <span class="fu">=</span> <span class="dt">Proof2</span></a></code></pre></div>
<p>Previous attempt to build function failed, but this one works. I don’t know if it’s related to non-injectivity or a bug.. I can report it :)</p>
<p>When I realized this problem, I have stopped.</p>
<p>Update. As Richard Eisenberg says:</p>
<pre><code>By the way, the bug in the Proof2 version is a bug in GHC 7.8.3
(only in .3 -- not in .2 or in the soon-to-be .4) that allows you
to write unsaturated type families that don't work.
Saying `LessThan255` without a parameter should be a syntax error,
but that check was accidentally turned off for 7.8.3, leading to a bogus type error.</code></pre>
<h3 id="attempt-3-carry-a-contraint-in-a-datatype">Attempt-3: carry a contraint in a datatype</h3>
<p>Now let’s keep our ‘constraint’ in a datatype, here we have 2 proxy, one for datatype, and one for value, also a KnownNat constraint that we want to use later:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Proof3</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="dt">Proof3</span><span class="ot"> ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c</a></code></pre></div>
<p>We can introduce a Show instance</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Proof3</span> c) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  show (<span class="dt">Proof3</span> _ k) <span class="fu">=</span> show <span class="fu">$</span> natVal k</a></code></pre></div>
<p>And now we can introduce a LessThen constraint as a datatype:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">data</span> <span class="dt">LessThan255D</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="kw">where</span> <span class="dt">LessThan255D</span><span class="ot"> ::</span> (n <span class="fu">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">LessThan255D</span> n</a></code></pre></div>
<p>We can convert type level constrant to data easily:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">c2d ::</span> <span class="dt">LessThan255</span> n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">LessThan255D</span> n</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">c2d _ <span class="fu">=</span> <span class="dt">LessThan255D</span></a></code></pre></div>
<p>But what about a proof, ideally we want to have following code:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">{-</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="co">fromSome3 :: SomeNat -&gt; Maybe (Proof3 LessThan255D)</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="co">fromSome3 (SomeNat p)</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="co">   | natVal p &lt; natVal t255 = Just (Proof3 LessThan255D p)</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="co">   | otherwise = Nothing</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="co">   where t255 = Proxy :: Proxy 255</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="co">-}</span></a></code></pre></div>
<pre><code>Proof.lhs:138:46:
  Could not deduce ((n &lt;=? 255) ~ 'True)
  from the context (KnownNat n)</code></pre>
<p>It doesn’t work simply because value level check doesn’t guarantee typelevel properties.</p>
<p>One way to solve it is to use unsafeCoerce: the idea is to use a proof for the value we know, and then coerce a type of a proof to the type of the proof related to the users value:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">fromSome3 ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">fromSome3 (<span class="dt">SomeNat</span> p)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">   <span class="fu">|</span> natVal p <span class="fu">&lt;</span> natVal t255 <span class="fu">=</span> <span class="dt">Just</span> (fake (c2d t255) p)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">   <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">   <span class="kw">where</span> t255 <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="ot">         fake ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c p <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">         fake k p <span class="fu">=</span> <span class="dt">Proof3</span> (unsafeCoerce<span class="ot"> k ::</span> c n) p</a></code></pre></div>
<p>It’s a nice solution, it’s unsafe as typechecker does not check that our predicate <code>(natVal (p::Proxy n) &lt; natVal (t255::Proxy 255))</code> implies the safety of a coerce from <code>LessThan255 ~ 255 -&gt; LessThan255 ~ p</code>.</p>
<p>There is one more solution that is really typesafe, but has a big complexity, and require a bounded set of values:</p>
<p>We can try to check is equal to one specific value from the set.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">guessProof ::</span> (<span class="dt">KnownNat</span> n, n <span class="fu">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">guessProof (<span class="dt">SomeNat</span> p) n <span class="fu">=</span> <span class="kw">case</span> sameNat p n <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    <span class="dt">Just</span> _  <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> n</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>Now we can build all set of values that are good:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Guesses</span> (<span class="ot">n::</span><span class="dt">Nat</span>)<span class="ot"> ::</span> [<span class="dt">Nat</span>] <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">   <span class="dt">Guesses</span> <span class="dv">0</span> <span class="fu">=</span> <span class="ch">'[0]</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">   <span class="dt">Guesses</span> n <span class="fu">=</span> n <span class="ch">': Guesses (n-1)</span></a></code></pre></div>
<p>And write a code that will check all possible values:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">class</span> <span class="dt">GuessProof</span> (<span class="ot">n ::</span> [<span class="dt">Nat</span>]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="ot">  proof ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">GuessProof</span> <span class="ch">'[] where</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  proof _ _ <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"><span class="kw">instance</span> (<span class="dt">KnownNat</span> n, n <span class="fu">&lt;=</span> <span class="dv">255</span>, <span class="dt">GuessProof</span> ns) <span class="ot">=&gt;</span> <span class="dt">GuessProof</span> (n <span class="ch">': ns) where</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">  proof s p <span class="fu">=</span> guessProof s (inner p) <span class="ot">`mplus`</span> proof s (next p)</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">   <span class="kw">where</span><span class="ot"> inner ::</span> <span class="dt">Proxy</span> (n <span class="ch">': ns) -&gt; Proxy (n::Nat)</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10">         inner _ <span class="fu">=</span> <span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"><span class="ot">         next ::</span> <span class="dt">Proxy</span> (n <span class="ch">': ns) -&gt; Proxy (ns::[Nat])</span></a>
<a class="sourceLine" id="cb21-12" data-line-number="12">         next _ <span class="fu">=</span> <span class="dt">Proxy</span></a></code></pre></div>
<p>It’s not very usable, have a bad complexity and require to change ghc options but it works and it’s safe.</p>
<p>Now let’s test our code:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">f2 ::</span> (c <span class="fu">~</span> (n <span class="fu">&lt;=</span> <span class="dv">255</span>)) <span class="ot">=&gt;</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">f2 (<span class="dt">Proof3</span> n p) <span class="fu">=</span> print <span class="fu">$</span> natVal p</a></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">test1 ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">test1 <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">    <span class="kw">case</span> someNatVal n <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Input is not a natural number!&quot;</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">      <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> fromSome3 sn <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8">                   <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">                   _ <span class="ot">-&gt;</span> error <span class="st">&quot;Input if larger than 255&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="ot">test2 ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">test2 <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  <span class="kw">case</span> someNatVal n <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Input is not a natural number!&quot;</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">      <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> proof sn (g (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span>)) <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">                   <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">                   _ <span class="ot">-&gt;</span> error <span class="st">&quot;Input if larger than 255&quot;</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10"><span class="ot">    g ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="dt">Guesses</span> n)</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">    g _ <span class="fu">=</span> <span class="dt">Proxy</span></a></code></pre></div>
<h3 id="attempt-5-singletons">Attempt 5: Singletons</h3>
<p>This is not the only solution, one more solution was provided by Richard Eisenberg I have not found it in mailing list archives so including it here.</p>
<p>The idea is that we may use less effective representation for typelevel naturals, i.e. unary naturals we can build a proof using singletons:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">{-# LANGUAGE TemplateHaskell, DataKinds, PolyKinds, TypeFamilies,</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">             ScopedTypeVariables, TypeOperators, UndecidableInstances,</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3"><span class="ot">             GADTs, RankNTypes #-}</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4"><span class="ot">{-# OPTIONS_GHC -ftype-function-depth=300 -fcontext-stack=300 #-}</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Singletons.TH</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7"><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> <span class="kw">hiding</span> ( <span class="dt">Nat</span> )</a>
<a class="sourceLine" id="cb25-8" data-line-number="8"></a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">  data Nat = Zero | Succ Nat</a>
<a class="sourceLine" id="cb25-11" data-line-number="11"></a>
<a class="sourceLine" id="cb25-12" data-line-number="12">  leNat :: Nat -&gt; Nat -&gt; Bool</a>
<a class="sourceLine" id="cb25-13" data-line-number="13">  leNat Zero     _        = True</a>
<a class="sourceLine" id="cb25-14" data-line-number="14">  leNat (Succ _) Zero     = False</a>
<a class="sourceLine" id="cb25-15" data-line-number="15">  leNat (Succ a) (Succ b) = a `leNat` b</a>
<a class="sourceLine" id="cb25-16" data-line-number="16">  |])</a>
<a class="sourceLine" id="cb25-17" data-line-number="17"></a>
<a class="sourceLine" id="cb25-18" data-line-number="18"><span class="co">-- | Singletons's 'withSomeSing' is what we want, but a bug in 7.8.3 doesn't</span></a>
<a class="sourceLine" id="cb25-19" data-line-number="19"><span class="co">-- let it work without a specialized type for 'Nat's</span></a>
<a class="sourceLine" id="cb25-20" data-line-number="20"><span class="ot">withSomeNat ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> (forall (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="fu">.</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb25-21" data-line-number="21">withSomeNat <span class="fu">=</span> withSomeSing</a>
<a class="sourceLine" id="cb25-22" data-line-number="22"></a>
<a class="sourceLine" id="cb25-23" data-line-number="23"><span class="co">-- | Conveniently generate unary naturals</span></a>
<a class="sourceLine" id="cb25-24" data-line-number="24"><span class="kw">type</span> family <span class="dt">U</span> n <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-25" data-line-number="25">  <span class="dt">U</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb25-26" data-line-number="26">  <span class="dt">U</span> n <span class="fu">=</span> <span class="dt">Succ</span> (<span class="dt">U</span> (n<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb25-27" data-line-number="27"></a>
<a class="sourceLine" id="cb25-28" data-line-number="28"><span class="ot">toNat ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb25-29" data-line-number="29">toNat n <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">0</span>      <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb25-30" data-line-number="30">        <span class="fu">|</span> otherwise  <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> go n</a>
<a class="sourceLine" id="cb25-31" data-line-number="31">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-32" data-line-number="32">    go <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Zero</span></a>
<a class="sourceLine" id="cb25-33" data-line-number="33">    go n <span class="fu">=</span> <span class="dt">Succ</span> (go (n<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb25-34" data-line-number="34"></a>
<a class="sourceLine" id="cb25-35" data-line-number="35"><span class="kw">type</span> <span class="dt">Bound</span> <span class="fu">=</span> <span class="dt">U</span> <span class="dv">255</span></a>
<a class="sourceLine" id="cb25-36" data-line-number="36"></a>
<a class="sourceLine" id="cb25-37" data-line-number="37"><span class="co">-- easier to test in GHCi than a proper 'main'</span></a>
<a class="sourceLine" id="cb25-38" data-line-number="38"><span class="ot">go ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb25-39" data-line-number="39">go n <span class="fu">=</span></a>
<a class="sourceLine" id="cb25-40" data-line-number="40">   <span class="kw">case</span> toNat n <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-41" data-line-number="41">     <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Input is not a natural number!&quot;</span></a>
<a class="sourceLine" id="cb25-42" data-line-number="42">     <span class="dt">Just</span> nat <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> withSomeNat nat <span class="fu">$</span> \ snat <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-43" data-line-number="43">       <span class="kw">case</span> snat <span class="ot">`sLeNat`</span> (<span class="ot">sing ::</span> <span class="dt">Sing</span> <span class="dt">Bound</span>) <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-44" data-line-number="44">         <span class="dt">STrue</span>  <span class="ot">-&gt;</span> f snat</a>
<a class="sourceLine" id="cb25-45" data-line-number="45">         <span class="dt">SFalse</span> <span class="ot">-&gt;</span> <span class="st">&quot;Didn't work&quot;</span></a>
<a class="sourceLine" id="cb25-46" data-line-number="46"></a>
<a class="sourceLine" id="cb25-47" data-line-number="47"><span class="ot">f ::</span> forall proxy (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="fu">.</span> (n <span class="ot">`LeNat`</span> <span class="dt">Bound</span>) <span class="fu">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> proxy n <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb25-48" data-line-number="48">f _ <span class="fu">=</span> <span class="st">&quot;It worked!&quot;</span></a></code></pre></div>
<h3 id="attempt-6-using-luquid-haskell">Attempt 6: Using Luquid haskell</h3>
<p>Ranjit Jhala, provided a great solution for liquid haskell, that could be found either by <a href="http://goto.ucsd.edu:8090/index.html#?demo=permalink%2F1418064183.hs">url</a> or here:</p>
<hr />
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="co">{-@ LIQUID &quot;--no-termination&quot; @-}</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="kw">module</span> <span class="dt">Nat255</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5"></a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="co">-- | Define a predicate for valid integers</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7"></a>
<a class="sourceLine" id="cb26-8" data-line-number="8"><span class="co">{-@ predicate IsValid X = 0 &lt;= X &amp;&amp; X &lt; 255 @-}</span></a>
<a class="sourceLine" id="cb26-9" data-line-number="9"></a>
<a class="sourceLine" id="cb26-10" data-line-number="10"><span class="co">-- | Use the predicate to define a refinement type (subset) of valid integers</span></a>
<a class="sourceLine" id="cb26-11" data-line-number="11"></a>
<a class="sourceLine" id="cb26-12" data-line-number="12"><span class="co">{-@ type Valid = {v:Int | IsValid v}        @-}</span></a>
<a class="sourceLine" id="cb26-13" data-line-number="13"></a>
<a class="sourceLine" id="cb26-14" data-line-number="14"><span class="co">-- | A function that checks whether a given Int is indeed valid</span></a>
<a class="sourceLine" id="cb26-15" data-line-number="15"></a>
<a class="sourceLine" id="cb26-16" data-line-number="16"><span class="co">{-@ isValid   :: n:Int -&gt; {v:Bool | Prop v &lt;=&gt; IsValid n} @-}</span></a>
<a class="sourceLine" id="cb26-17" data-line-number="17">isValid n     <span class="fu">=</span> <span class="dv">0</span> <span class="fu">&lt;=</span> n <span class="fu">&amp;&amp;</span> n <span class="fu">&lt;</span> (<span class="dv">255</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb26-18" data-line-number="18"></a>
<a class="sourceLine" id="cb26-19" data-line-number="19"><span class="co">-- | A function that can only be called with Valid Ints.</span></a>
<a class="sourceLine" id="cb26-20" data-line-number="20"></a>
<a class="sourceLine" id="cb26-21" data-line-number="21"><span class="co">{-@ workWithValidNumber :: Valid -&gt; IO () @-}</span> </a>
<a class="sourceLine" id="cb26-22" data-line-number="22">workWithValidNumber n <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;This is a valid number&quot;</span> <span class="fu">++</span> show (<span class="ot">n ::</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb26-23" data-line-number="23"></a>
<a class="sourceLine" id="cb26-24" data-line-number="24"><span class="co">-- | This is fine...</span></a>
<a class="sourceLine" id="cb26-25" data-line-number="25">ok    <span class="fu">=</span> workWithValidNumber <span class="dv">12</span></a>
<a class="sourceLine" id="cb26-26" data-line-number="26"></a>
<a class="sourceLine" id="cb26-27" data-line-number="27"><span class="co">-- | ... But this is not.        </span></a>
<a class="sourceLine" id="cb26-28" data-line-number="28">notOk <span class="fu">=</span> workWithValidNumber <span class="dv">257</span></a>
<a class="sourceLine" id="cb26-29" data-line-number="29"></a>
<a class="sourceLine" id="cb26-30" data-line-number="30"><span class="co">-- | Finally the top level loop that inputs a number, tests it </span></a>
<a class="sourceLine" id="cb26-31" data-line-number="31"><span class="co">--   and calls `workWithValidNumber` if the number is valid.</span></a>
<a class="sourceLine" id="cb26-32" data-line-number="32"></a>
<a class="sourceLine" id="cb26-33" data-line-number="33">loop <span class="fu">=</span> <span class="kw">do</span> putStrLn <span class="st">&quot;Enter Number between 0 and 255&quot;</span></a>
<a class="sourceLine" id="cb26-34" data-line-number="34">          n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb26-35" data-line-number="35">          <span class="kw">if</span> isValid n</a>
<a class="sourceLine" id="cb26-36" data-line-number="36">             <span class="kw">then</span> workWithValidNumber n</a>
<a class="sourceLine" id="cb26-37" data-line-number="37">             <span class="kw">else</span> putStrLn <span class="st">&quot;Humph, bad input, try again!&quot;</span> <span class="fu">&gt;&gt;</span> loop</a></code></pre></div>
<p>I hope you have enjoyed reading this.</p>

<hr />
<div id="sociallinks" class="pull-left">
    <strong>Share on:</strong>
  <a href="https://twitter.com/home?status=http://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" target="_blank" class="social" title="twit it">t</a>  
  <a href="http://www.facebook.com/sharer/sharer.php?u=http://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" target="_blank" class="social" title="share on facebook">F</a> 
  <a href="https://plus.google.com/share?url=http://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" target="_blank" class="social" title="share on g+">g</a>
</div>

<br class="clearfix" />
<hr />


<div id="disqus_thread"></div>
  <script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'qnikst'; // required: replace example with your forum shortname

  (function() {
     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                                                                                                           

  </div>

  <footer>
    powered by <a href="http://jaspervdj.be/hakyll">Hakyll</a> &amp; <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a>
  </footer>

<script type="text/javascript">
    //      <noscript> я очень хочу вас посчитать, напишите комментарий хотя бы, пожааалуйста </noscript>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-38941774-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>
