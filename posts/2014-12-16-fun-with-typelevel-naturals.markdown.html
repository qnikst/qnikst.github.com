<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Qnikst blog - Approaches to carry a proof for typelevel natural</title>
    <!-- Bootstrap -->
    <link href="../css/additional.css" rel="stylesheet" media="screen">
    <link href="../css/hscolour.css" rel="stylesheet" media="screen">
    <link href="../css/hakyll.css" rel="stylesheet" media="screen">
    <script src="https://code.jquery.com/jquery-latest.js"></script> 
    <script src="../js/bootstrap.min.js"></script>
    
    
</head>

<body>
  <div id="header">
      <div id="caption">
      <font color="green">module</font> <a href="../">QnikstBlog</a>
      </div>
      <div id="navigaion">
      <font color="cyan">(</font> <a href="../posts.html">Archive</a>
      <font color="cyan">,</font> <a href="../projects.html">Projects</a>
      <font color="cyan">,</font> <a href="../rss.xml">RSS</a>
      <font color="cyan">)</font> <font color="green">where</font>
      </div>
  </div>

  <div id="content">
    <div class="page-header">
    <div class="right">
      <strong>December 16, 2014</strong>
    </div>
    <h1>Approaches to carry a proof for typelevel natural</h1>
    <div class="post-author">by <em>Vershilov A.V.</em> <a href="https://creativecommons.org/licenses/by/3.0"><img src="https://i.creativecommons.org/l/by/3.0/88x31.png" /></a> </div>
    <div class="keywords"><strong>Keywords:</strong> <a href="../tags/haskell.html">haskell</a>, <a href="../tags/typenats.html">typenats</a></div>
</div>

<p>For time ago Bas van Dijk asked a question on glasgow-haskell-users mailing list about <a href="https://www.haskell.org/pipermail/glasgow-haskell-users/2014-November/025451.html">proving the properties of type-level natural numbers obtained by user</a>. That lead to an interesting discussion, that you can read in the list archives.</p>
<p>The problem was that we want to impose a constraint on some typelevel natural and then read value from user and guarantee that we have that constraint. For such constraint we took (&lt;=255).</p>
<p>Here is a file that describe few approaches to solve this problem.</p>
<p>At first we need to use a HUGE list of pragmas.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ViewPatterns #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ConstraintKinds #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></code></pre></div>
<p>And relax compiler options a bit.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# OPTIONS_GHC -ftype-function-depth=1024 #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# OPTIONS_GHC -fcontext-stack=1024 #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">GHC.TypeLits</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">GHC.Exts</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Proxy</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Constraint</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Type.Bool</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Type.Equality</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Environment</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Unsafe.Coerce</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Singletons</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad</span></code></pre></div>
<h3 id="attempt-1-tagged-value">Attempt-1: Tagged value</h3>
<p>We can keep a proof together with value, so we can introduce a new type:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Proof</span> n  (<span class="ot">c ::</span> <span class="dt">Constraint</span>) <span class="kw">where</span> <span class="dt">Proof</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof</span> n c</code></pre></div>
<p>In mailing list I provide following code:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fromSomeError ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof</span> n (n <span class="fu">&lt;=</span> <span class="dv">255</span>))
<span class="ot">&gt;</span> fromSomeError (<span class="dt">SomeNat</span> p)
<span class="ot">&gt;</span>    <span class="fu">|</span> natVal p <span class="fu">&lt;=</span> <span class="dv">255</span> <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Proof</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n))
<span class="ot">&gt;</span>    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>This is obviously a bug as we check natVal p, but return Proxy n. And correct version fails, as there is no way to simply inject a constraint.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-</span>
<span class="co">&gt; fromSome :: SomeNat -&gt; Maybe (Proof n (n &lt;= 255))</span>
<span class="co">&gt; fromSome (SomeNat p)</span>
<span class="co">&gt;   | natVal p &lt;= 255 = Just (Proof p)</span>
<span class="co">&gt;   | otherwise = Nothing</span>
<span class="co">&gt; -}</span></code></pre></div>
<pre><code> Proof.lhs:53:37:
    Could not deduce (n1 ~ n)
    from the context (KnownNat n1)
    bound by a pattern with constructor
        SomeNat :: forall (n :: Nat). KnownNat n =&gt; Proxy n -&gt; SomeNat,
	in an equation for ‘fromSome’
	at Proof.lhs:52:13-21</code></pre>
<h3 id="attempt-2-type-carrier">Attempt-2: Type carrier</h3>
<p>Now we want to have the following constraint on out Nat</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Proof2</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="dt">Proof2</span><span class="ot"> ::</span> c n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c</code></pre></div>
<p>In order to have a ‘curried’ version of our constaint we can introduce a type family</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> family <span class="dt">LessThan255</span><span class="ot"> n ::</span> <span class="dt">Constraint</span> <span class="kw">where</span>
<span class="ot">&gt;</span>     <span class="dt">LessThan255</span> f <span class="fu">=</span> (f <span class="fu">&lt;=</span> <span class="dv">255</span>)</code></pre></div>
<p>Now lets try to create a proof from known natural:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-</span>
<span class="co">&gt; strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255</span>
<span class="co">&gt; strange = Proof2</span>
<span class="co">&gt; -}</span></code></pre></div>
<p><sub><sub><sub><sub><sub><sub><sub>~</sub></sub></sub></sub></sub></sub></sub> Proof.lhs:89:13: Could not deduce (LessThan255 n) arising from a use of ‘Proof2’ from the context (LessThan255 n) bound by the type signature for strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255 <sub><sub><sub><sub><sub><sub>~</sub></sub></sub></sub></sub></sub>~</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; strange ::</span> (<span class="dt">LessThan255</span> <span class="fu">~</span> c, c n) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c
<span class="ot">&gt;</span> strange <span class="fu">=</span> <span class="dt">Proof2</span></code></pre></div>
<p>Previous attempt to build function failed, but this one works. I don’t know if it’s related to non-injectivity or a bug.. I can report it :)</p>
<p>When I realized this problem, I have stopped.</p>
<p>Update. As Richard Eisenberg says:</p>
<pre><code>By the way, the bug in the Proof2 version is a bug in GHC 7.8.3
(only in .3 -- not in .2 or in the soon-to-be .4) that allows you
to write unsaturated type families that don't work.
Saying `LessThan255` without a parameter should be a syntax error,
but that check was accidentally turned off for 7.8.3, leading to a bogus type error.</code></pre>
<h3 id="attempt-3-carry-a-contraint-in-a-datatype">Attempt-3: carry a contraint in a datatype</h3>
<p>Now let’s keep our ‘constraint’ in a datatype, here we have 2 proxy, one for datatype, and one for value, also a KnownNat constraint that we want to use later:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Proof3</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="dt">Proof3</span><span class="ot"> ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c</code></pre></div>
<p>We can introduce a Show instance</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Proof3</span> c) <span class="kw">where</span>
<span class="ot">&gt;</span>   show (<span class="dt">Proof3</span> _ k) <span class="fu">=</span> show <span class="fu">$</span> natVal k</code></pre></div>
<p>And now we can introduce a LessThen constraint as a datatype:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">LessThan255D</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="kw">where</span> <span class="dt">LessThan255D</span><span class="ot"> ::</span> (n <span class="fu">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">LessThan255D</span> n</code></pre></div>
<p>We can convert type level constrant to data easily:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; c2d ::</span> <span class="dt">LessThan255</span> n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">LessThan255D</span> n
<span class="ot">&gt;</span> c2d _ <span class="fu">=</span> <span class="dt">LessThan255D</span></code></pre></div>
<p>But what about a proof, ideally we want to have following code:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-</span>
<span class="co">&gt; fromSome3 :: SomeNat -&gt; Maybe (Proof3 LessThan255D)</span>
<span class="co">&gt; fromSome3 (SomeNat p)</span>
<span class="co">&gt;    | natVal p &lt; natVal t255 = Just (Proof3 LessThan255D p)</span>
<span class="co">&gt;    | otherwise = Nothing</span>
<span class="co">&gt;    where t255 = Proxy :: Proxy 255</span>
<span class="co">&gt; -}</span></code></pre></div>
<pre><code>Proof.lhs:138:46:
  Could not deduce ((n &lt;=? 255) ~ 'True)
  from the context (KnownNat n)</code></pre>
<p>It doesn’t work simply because value level check doesn’t guarantee typelevel properties.</p>
<p>One way to solve it is to use unsafeCoerce: the idea is to use a proof for the value we know, and then coerce a type of a proof to the type of the proof related to the users value:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fromSome3 ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)
<span class="ot">&gt;</span> fromSome3 (<span class="dt">SomeNat</span> p)
<span class="ot">&gt;</span>    <span class="fu">|</span> natVal p <span class="fu">&lt;</span> natVal t255 <span class="fu">=</span> <span class="dt">Just</span> (fake (c2d t255) p)
<span class="ot">&gt;</span>    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>    <span class="kw">where</span> t255 <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span>
<span class="ot">&gt;          fake ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c p <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c
<span class="ot">&gt;</span>          fake k p <span class="fu">=</span> <span class="dt">Proof3</span> (unsafeCoerce<span class="ot"> k ::</span> c n) p</code></pre></div>
<p>It’s a nice solution, it’s unsafe as typechecker does not check that our predicate <code>(natVal (p::Proxy n) &lt; natVal (t255::Proxy 255))</code> implies the safety of a coerce from <code>LessThan255 ~ 255 -&gt; LessThan255 ~ p</code>.</p>
<p>There is one more solution that is really typesafe, but has a big complexity, and require a bounded set of values:</p>
<p>We can try to check is equal to one specific value from the set.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; guessProof ::</span> (<span class="dt">KnownNat</span> n, n <span class="fu">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)
<span class="ot">&gt;</span> guessProof (<span class="dt">SomeNat</span> p) n <span class="fu">=</span> <span class="kw">case</span> sameNat p n <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="dt">Just</span> _  <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> n
<span class="ot">&gt;</span>     <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></code></pre></div>
<p>Now we can build all set of values that are good:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> family <span class="dt">Guesses</span> (<span class="ot">n::</span><span class="dt">Nat</span>)<span class="ot"> ::</span> [<span class="dt">Nat</span>] <span class="kw">where</span>
<span class="ot">&gt;</span>    <span class="dt">Guesses</span> <span class="dv">0</span> <span class="fu">=</span> <span class="ch">'[0]</span>
<span class="ot">&gt;</span>    <span class="dt">Guesses</span> n <span class="fu">=</span> n <span class="ch">': Guesses (n-1)</span></code></pre></div>
<p>And write a code that will check all possible values:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">class</span> <span class="dt">GuessProof</span> (<span class="ot">n ::</span> [<span class="dt">Nat</span>]) <span class="kw">where</span>
<span class="ot">&gt;   proof ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">GuessProof</span> <span class="ch">'[] where</span>
<span class="ot">&gt;</span>   proof _ _ <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> (<span class="dt">KnownNat</span> n, n <span class="fu">&lt;=</span> <span class="dv">255</span>, <span class="dt">GuessProof</span> ns) <span class="ot">=&gt;</span> <span class="dt">GuessProof</span> (n <span class="ch">': ns) where</span>
<span class="ot">&gt;</span>   proof s p <span class="fu">=</span> guessProof s (inner p) <span class="ot">`mplus`</span> proof s (next p)
<span class="ot">&gt;</span>    <span class="kw">where</span><span class="ot"> inner ::</span> <span class="dt">Proxy</span> (n <span class="ch">': ns) -&gt; Proxy (n::Nat)</span>
<span class="ot">&gt;</span>          inner _ <span class="fu">=</span> <span class="dt">Proxy</span>
<span class="ot">&gt;          next ::</span> <span class="dt">Proxy</span> (n <span class="ch">': ns) -&gt; Proxy (ns::[Nat])</span>
<span class="ot">&gt;</span>          next _ <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>It’s not very usable, have a bad complexity and require to change ghc options but it works and it’s safe.</p>
<p>Now let’s test our code:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; f2 ::</span> (c <span class="fu">~</span> (n <span class="fu">&lt;=</span> <span class="dv">255</span>)) <span class="ot">=&gt;</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> f2 (<span class="dt">Proof3</span> n p) <span class="fu">=</span> print <span class="fu">$</span> natVal p</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; test1 ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> test1 <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     <span class="kw">case</span> someNatVal n <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Input is not a natural number!&quot;</span>
<span class="ot">&gt;</span>       <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> fromSome3 sn <span class="kw">of</span>
<span class="ot">&gt;</span>                    <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p
<span class="ot">&gt;</span>                    _ <span class="ot">-&gt;</span> error <span class="st">&quot;Input if larger than 255&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; test2 ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> test2 <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span>   <span class="kw">case</span> someNatVal n <span class="kw">of</span>
<span class="ot">&gt;</span>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Input is not a natural number!&quot;</span>
<span class="ot">&gt;</span>       <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> proof sn (g (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span>)) <span class="kw">of</span>
<span class="ot">&gt;</span>                    <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p
<span class="ot">&gt;</span>                    _ <span class="ot">-&gt;</span> error <span class="st">&quot;Input if larger than 255&quot;</span>
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     g ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="dt">Guesses</span> n)
<span class="ot">&gt;</span>     g _ <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<h3 id="attempt-5-singletons">Attempt 5: Singletons</h3>
<p>This is not the only solution, one more solution was provided by Richard Eisenberg I have not found it in mailing list archives so including it here.</p>
<p>The idea is that we may use less effective representation for typelevel naturals, i.e. unary naturals we can build a proof using singletons:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-# LANGUAGE TemplateHaskell, DataKinds, PolyKinds, TypeFamilies,</span>
<span class="co">&gt;              ScopedTypeVariables, TypeOperators, UndecidableInstances,</span>
<span class="co">&gt;              GADTs, RankNTypes #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# OPTIONS_GHC -ftype-function-depth=300 -fcontext-stack=300 #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Singletons.TH</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">GHC.TypeLits</span> <span class="kw">hiding</span> ( <span class="dt">Nat</span> )
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="fu">$</span>(singletons [d<span class="fu">|</span>
<span class="ot">&gt;</span>   <span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;   leNat ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span>   leNat <span class="dt">Zero</span>     _        <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span>   leNat (<span class="dt">Succ</span> _) <span class="dt">Zero</span>     <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span>   leNat (<span class="dt">Succ</span> a) (<span class="dt">Succ</span> b) <span class="fu">=</span> a <span class="ot">`leNat`</span> b
<span class="ot">&gt;</span>   <span class="fu">|</span>])
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | Singletons's 'withSomeSing' is what we want, but a bug in 7.8.3 doesn't</span>
<span class="ot">&gt;</span> <span class="co">-- let it work without a specialized type for 'Nat's</span>
<span class="ot">&gt; withSomeNat ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> (forall (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="fu">.</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r
<span class="ot">&gt;</span> withSomeNat <span class="fu">=</span> withSomeSing
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | Conveniently generate unary naturals</span>
<span class="ot">&gt;</span> <span class="kw">type</span> family <span class="dt">U</span> n <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="dt">U</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Zero</span>
<span class="ot">&gt;</span>   <span class="dt">U</span> n <span class="fu">=</span> <span class="dt">Succ</span> (<span class="dt">U</span> (n<span class="fu">-</span><span class="dv">1</span>))
<span class="ot">&gt;</span> 
<span class="ot">&gt; toNat ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Nat</span>
<span class="ot">&gt;</span> toNat n <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">0</span>      <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>         <span class="fu">|</span> otherwise  <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> go n
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     go <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Zero</span>
<span class="ot">&gt;</span>     go n <span class="fu">=</span> <span class="dt">Succ</span> (go (n<span class="fu">-</span><span class="dv">1</span>))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Bound</span> <span class="fu">=</span> <span class="dt">U</span> <span class="dv">255</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- easier to test in GHCi than a proper 'main'</span>
<span class="ot">&gt; go ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> go n <span class="fu">=</span>
<span class="ot">&gt;</span>    <span class="kw">case</span> toNat n <span class="kw">of</span>
<span class="ot">&gt;</span>      <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Input is not a natural number!&quot;</span>
<span class="ot">&gt;</span>      <span class="dt">Just</span> nat <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> withSomeNat nat <span class="fu">$</span> \ snat <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>        <span class="kw">case</span> snat <span class="ot">`sLeNat`</span> (<span class="ot">sing ::</span> <span class="dt">Sing</span> <span class="dt">Bound</span>) <span class="kw">of</span>
<span class="ot">&gt;</span>          <span class="dt">STrue</span>  <span class="ot">-&gt;</span> f snat
<span class="ot">&gt;</span>          <span class="dt">SFalse</span> <span class="ot">-&gt;</span> <span class="st">&quot;Didn't work&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; f ::</span> forall proxy (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="fu">.</span> (n <span class="ot">`LeNat`</span> <span class="dt">Bound</span>) <span class="fu">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> proxy n <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">&gt;</span> f _ <span class="fu">=</span> <span class="st">&quot;It worked!&quot;</span></code></pre></div>
<h3 id="attempt-6-using-luquid-haskell">Attempt 6: Using Luquid haskell</h3>
<p>Ranjit Jhala, provided a great solution for liquid haskell, that could be found either by <a href="http://goto.ucsd.edu:8090/index.html#?demo=permalink%2F1418064183.hs">url</a> or here:</p>
<hr />
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ LIQUID &quot;--no-termination&quot; @-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Nat255</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | Define a predicate for valid integers</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ predicate IsValid X = 0 &lt;= X &amp;&amp; X &lt; 255 @-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | Use the predicate to define a refinement type (subset) of valid integers</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ type Valid = {v:Int | IsValid v}        @-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | A function that checks whether a given Int is indeed valid</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ isValid   :: n:Int -&gt; {v:Bool | Prop v &lt;=&gt; IsValid n} @-}</span>
<span class="ot">&gt;</span> isValid n     <span class="fu">=</span> <span class="dv">0</span> <span class="fu">&lt;=</span> n <span class="fu">&amp;&amp;</span> n <span class="fu">&lt;</span> (<span class="dv">255</span><span class="ot"> ::</span> <span class="dt">Int</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | A function that can only be called with Valid Ints.</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ workWithValidNumber :: Valid -&gt; IO () @-}</span> 
<span class="ot">&gt;</span> workWithValidNumber n <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;This is a valid number&quot;</span> <span class="fu">++</span> show (<span class="ot">n ::</span> <span class="dt">Int</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | This is fine...</span>
<span class="ot">&gt;</span> ok    <span class="fu">=</span> workWithValidNumber <span class="dv">12</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | ... But this is not.        </span>
<span class="ot">&gt;</span> notOk <span class="fu">=</span> workWithValidNumber <span class="dv">257</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | Finally the top level loop that inputs a number, tests it </span>
<span class="ot">&gt;</span> <span class="co">--   and calls `workWithValidNumber` if the number is valid.</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> loop <span class="fu">=</span> <span class="kw">do</span> putStrLn <span class="st">&quot;Enter Number between 0 and 255&quot;</span>
<span class="ot">&gt;</span>           n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>           <span class="kw">if</span> isValid n
<span class="ot">&gt;</span>              <span class="kw">then</span> workWithValidNumber n
<span class="ot">&gt;</span>              <span class="kw">else</span> putStrLn <span class="st">&quot;Humph, bad input, try again!&quot;</span> <span class="fu">&gt;&gt;</span> loop</code></pre></div>
<p>I hope you have enjoyed reading this.</p>

<hr />
<div id="sociallinks" class="pull-left">
    <strong>Share on:</strong>
  <a href="https://twitter.com/home?status=http://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" target="_blank" class="social" title="twit it">t</a>  
  <a href="http://www.facebook.com/sharer/sharer.php?u=http://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" target="_blank" class="social" title="share on facebook">F</a> 
  <a href="https://plus.google.com/share?url=http://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" target="_blank" class="social" title="share on g+">g</a>
</div>

<br class="clearfix" />
<hr />


<div id="disqus_thread"></div>
  <script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'qnikst'; // required: replace example with your forum shortname

  (function() {
     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                                                                                                           

  </div>

  <footer>
    powered by <a href="http://jaspervdj.be/hakyll">Hakyll</a> &amp; <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a>
  </footer>

<script type="text/javascript">
    //      <noscript> я очень хочу вас посчитать, напишите комментарий хотя бы, пожааалуйста </noscript>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-38941774-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>
