<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Qnikst blog - Approaches to carry a proof for typelevel natural</title>
    <!-- Bootstrap -->
    <link href="../style.css" rel="stylesheet" media="screen">
    <script src="https://code.jquery.com/jquery-latest.js"></script> 
    <script src="../js/bootstrap.min.js"></script>
    
    
</head>

<body>
  <div id="header">
      <div id="caption"><a href="../">Qnikst's blog</a></div>
      <div id="navigation">
      <a href="../posts.html">Archive</a>
      <a href="../projects.html">Projects</a>
      <a href="../contact.html">Contacts</a>
      <a href="../rss.xml">RSS</a>
      </div>
  </div>

  <div id="content">
    <div class="page-header">
    <div class="right">
      <strong>December 16, 2014</strong>
    </div>
    <h1>Approaches to carry a proof for typelevel natural</h1>
    <div class="post-author">by <em>Vershilov A.V.</em> <a href="https://creativecommons.org/licenses/by/3.0"><img src="https://i.creativecommons.org/l/by/3.0/88x31.png" /></a> </div>
    <div class="keywords"><strong>Keywords:</strong> <a href="../tags/haskell.html">haskell</a>, <a href="../tags/typenats.html">typenats</a></div>
</div>

<p>For time ago Bas van Dijk asked a question on glasgow-haskell-users mailing list about <a href="https://www.haskell.org/pipermail/glasgow-haskell-users/2014-November/025451.html">proving the properties of type-level natural numbers obtained by user</a>. That lead to an interesting discussion, that you can read in the list archives.</p>
<p>The problem was that we want to impose a constraint on some typelevel natural and then read value from user and guarantee that we have that constraint. For such constraint we took (&lt;=255).</p>
<p>Here is a file that describe few approaches to solve this problem.</p>
<p>At first we need to use a HUGE list of pragmas.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="ot">{-# LANGUAGE ViewPatterns #-}</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span></code></pre></div>
<p>And relax compiler options a bit.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">{-# OPTIONS_GHC -ftype-function-depth=1024 #-}</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="ot">{-# OPTIONS_GHC -fcontext-stack=1024 #-}</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span> </span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">import</span> <span class="dt">Data.Constraint</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="kw">import</span> <span class="dt">Data.Type.Bool</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">import</span> <span class="dt">System.Environment</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="kw">import</span> <span class="dt">Unsafe.Coerce</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="kw">import</span> <span class="dt">Data.Singletons</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span></code></pre></div>
<h3 id="attempt-1-tagged-value">Attempt-1: Tagged value</h3>
<p>We can keep a proof together with value, so we can introduce a new type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">Proof</span> n  (<span class="ot">c ::</span> <span class="dt">Constraint</span>) <span class="kw">where</span> <span class="dt">Proof</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof</span> n c</span></code></pre></div>
<p>In mailing list I provide following code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">fromSomeError ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof</span> n (n <span class="op">&lt;=</span> <span class="dv">255</span>))</span>
<span id="cb4-2"><a href="#cb4-2"></a>fromSomeError (<span class="dt">SomeNat</span> p)</span>
<span id="cb4-3"><a href="#cb4-3"></a>   <span class="op">|</span> natVal p <span class="op">&lt;=</span> <span class="dv">255</span> <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Proof</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n))</span>
<span id="cb4-4"><a href="#cb4-4"></a>   <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>This is obviously a bug as we check natVal p, but return Proxy n. And correct version fails, as there is no way to simply inject a constraint.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">{-</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co">fromSome :: SomeNat -&gt; Maybe (Proof n (n &lt;= 255))</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">fromSome (SomeNat p)</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co">  | natVal p &lt;= 255 = Just (Proof p)</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">  | otherwise = Nothing</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">-}</span></span></code></pre></div>
<pre><code> Proof.lhs:53:37:
    Could not deduce (n1 ~ n)
    from the context (KnownNat n1)
    bound by a pattern with constructor
        SomeNat :: forall (n :: Nat). KnownNat n =&gt; Proxy n -&gt; SomeNat,
	in an equation for ‘fromSome’
	at Proof.lhs:52:13-21</code></pre>
<h3 id="attempt-2-type-carrier">Attempt-2: Type carrier</h3>
<p>Now we want to have the following constraint on out Nat</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">data</span> <span class="dt">Proof2</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="dt">Proof2</span><span class="ot"> ::</span> c n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c</span></code></pre></div>
<p>In order to have a ‘curried’ version of our constaint we can introduce a type family</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">LessThan255</span><span class="ot"> n ::</span> <span class="dt">Constraint</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="dt">LessThan255</span> f <span class="ot">=</span> (f <span class="op">&lt;=</span> <span class="dv">255</span>)</span></code></pre></div>
<p>Now lets try to create a proof from known natural:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">{-</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co">strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co">strange = Proof2</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co">-}</span></span></code></pre></div>
<p>~~~~~~~~~~~~~~~ Proof.lhs:89:13: Could not deduce (LessThan255 n) arising from a use of ‘Proof2’ from the context (LessThan255 n) bound by the type signature for strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255 ~~~~~~~~~~~~~~</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">strange ::</span> (<span class="dt">LessThan255</span> <span class="op">~</span> c, c n) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c</span>
<span id="cb10-2"><a href="#cb10-2"></a>strange <span class="ot">=</span> <span class="dt">Proof2</span></span></code></pre></div>
<p>Previous attempt to build function failed, but this one works. I don’t know if it’s related to non-injectivity or a bug.. I can report it :)</p>
<p>When I realized this problem, I have stopped.</p>
<p>Update. As Richard Eisenberg says:</p>
<pre><code>By the way, the bug in the Proof2 version is a bug in GHC 7.8.3
(only in .3 -- not in .2 or in the soon-to-be .4) that allows you
to write unsaturated type families that don't work.
Saying `LessThan255` without a parameter should be a syntax error,
but that check was accidentally turned off for 7.8.3, leading to a bogus type error.</code></pre>
<h3 id="attempt-3-carry-a-contraint-in-a-datatype">Attempt-3: carry a contraint in a datatype</h3>
<p>Now let’s keep our ‘constraint’ in a datatype, here we have 2 proxy, one for datatype, and one for value, also a KnownNat constraint that we want to use later:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">data</span> <span class="dt">Proof3</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>  <span class="dt">Proof3</span><span class="ot"> ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c</span></code></pre></div>
<p>We can introduce a Show instance</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Proof3</span> c) <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="fu">show</span> (<span class="dt">Proof3</span> _ k) <span class="ot">=</span> <span class="fu">show</span> <span class="op">$</span> natVal k</span></code></pre></div>
<p>And now we can introduce a LessThen constraint as a datatype:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">data</span> <span class="dt">LessThan255D</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="kw">where</span> <span class="dt">LessThan255D</span><span class="ot"> ::</span> (n <span class="op">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">LessThan255D</span> n</span></code></pre></div>
<p>We can convert type level constrant to data easily:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">c2d ::</span> <span class="dt">LessThan255</span> n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">LessThan255D</span> n</span>
<span id="cb15-2"><a href="#cb15-2"></a>c2d _ <span class="ot">=</span> <span class="dt">LessThan255D</span></span></code></pre></div>
<p>But what about a proof, ideally we want to have following code:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="co">{-</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="co">fromSome3 :: SomeNat -&gt; Maybe (Proof3 LessThan255D)</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co">fromSome3 (SomeNat p)</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="co">   | natVal p &lt; natVal t255 = Just (Proof3 LessThan255D p)</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="co">   | otherwise = Nothing</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="co">   where t255 = Proxy :: Proxy 255</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="co">-}</span></span></code></pre></div>
<pre><code>Proof.lhs:138:46:
  Could not deduce ((n &lt;=? 255) ~ 'True)
  from the context (KnownNat n)</code></pre>
<p>It doesn’t work simply because value level check doesn’t guarantee typelevel properties.</p>
<p>One way to solve it is to use unsafeCoerce: the idea is to use a proof for the value we know, and then coerce a type of a proof to the type of the proof related to the users value:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="ot">fromSome3 ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</span>
<span id="cb18-2"><a href="#cb18-2"></a>fromSome3 (<span class="dt">SomeNat</span> p)</span>
<span id="cb18-3"><a href="#cb18-3"></a>   <span class="op">|</span> natVal p <span class="op">&lt;</span> natVal t255 <span class="ot">=</span> <span class="dt">Just</span> (fake (c2d t255) p)</span>
<span id="cb18-4"><a href="#cb18-4"></a>   <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>   <span class="kw">where</span> t255 <span class="ot">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="ot">         fake ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c p <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c</span>
<span id="cb18-7"><a href="#cb18-7"></a>         fake k p <span class="ot">=</span> <span class="dt">Proof3</span> (unsafeCoerce<span class="ot"> k ::</span> c n) p</span></code></pre></div>
<p>It’s a nice solution, it’s unsafe as typechecker does not check that our predicate <code>(natVal (p::Proxy n) &lt; natVal (t255::Proxy 255))</code> implies the safety of a coerce from <code>LessThan255 ~ 255 -&gt; LessThan255 ~ p</code>.</p>
<p>There is one more solution that is really typesafe, but has a big complexity, and require a bounded set of values:</p>
<p>We can try to check is equal to one specific value from the set.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">guessProof ::</span> (<span class="dt">KnownNat</span> n, n <span class="op">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</span>
<span id="cb19-2"><a href="#cb19-2"></a>guessProof (<span class="dt">SomeNat</span> p) n <span class="ot">=</span> <span class="kw">case</span> sameNat p n <span class="kw">of</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="dt">Just</span> _  <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> n</span>
<span id="cb19-4"><a href="#cb19-4"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>Now we can build all set of values that are good:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Guesses</span> (<span class="ot">n::</span><span class="dt">Nat</span>)<span class="ot"> ::</span> [<span class="dt">Nat</span>] <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>   <span class="dt">Guesses</span> <span class="dv">0</span> <span class="ot">=</span> '[<span class="dv">0</span>]</span>
<span id="cb20-3"><a href="#cb20-3"></a>   <span class="dt">Guesses</span> n <span class="ot">=</span> n '<span class="op">:</span> <span class="dt">Guesses</span> (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>And write a code that will check all possible values:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">class</span> <span class="dt">GuessProof</span> (<span class="ot">n ::</span> [<span class="dt">Nat</span>]) <span class="kw">where</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="ot">  proof ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</span>
<span id="cb21-3"><a href="#cb21-3"></a></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="kw">instance</span> <span class="dt">GuessProof</span> '[] <span class="kw">where</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>  proof _ _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb21-6"><a href="#cb21-6"></a></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="kw">instance</span> (<span class="dt">KnownNat</span> n, n <span class="op">&lt;=</span> <span class="dv">255</span>, <span class="dt">GuessProof</span> ns) <span class="ot">=&gt;</span> <span class="dt">GuessProof</span> (n '<span class="op">:</span> ns) <span class="kw">where</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>  proof s p <span class="ot">=</span> guessProof s (inner p) <span class="ot">`mplus`</span> proof s (next p)</span>
<span id="cb21-9"><a href="#cb21-9"></a>   <span class="kw">where</span><span class="ot"> inner ::</span> <span class="dt">Proxy</span> (n '<span class="op">:</span> ns) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="ot">n::</span><span class="dt">Nat</span>)</span>
<span id="cb21-10"><a href="#cb21-10"></a>         inner _ <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="ot">         next ::</span> <span class="dt">Proxy</span> (n '<span class="op">:</span> ns) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="ot">ns::</span>[<span class="dt">Nat</span>])</span>
<span id="cb21-12"><a href="#cb21-12"></a>         next _ <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>It’s not very usable, have a bad complexity and require to change ghc options but it works and it’s safe.</p>
<p>Now let’s test our code:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="ot">f2 ::</span> (c <span class="op">~</span> (n <span class="op">&lt;=</span> <span class="dv">255</span>)) <span class="ot">=&gt;</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb22-2"><a href="#cb22-2"></a>f2 (<span class="dt">Proof3</span> n p) <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> natVal p</span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="ot">test1 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb23-2"><a href="#cb23-2"></a>test1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></span>
<span id="cb23-4"><a href="#cb23-4"></a></span>
<span id="cb23-5"><a href="#cb23-5"></a>    <span class="kw">case</span> someNatVal n <span class="kw">of</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Input is not a natural number!&quot;</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>      <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> fromSome3 sn <span class="kw">of</span></span>
<span id="cb23-8"><a href="#cb23-8"></a>                   <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p</span>
<span id="cb23-9"><a href="#cb23-9"></a>                   _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Input if larger than 255&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="ot">test2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb24-2"><a href="#cb24-2"></a>test2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>  n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>  <span class="kw">case</span> someNatVal n <span class="kw">of</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Input is not a natural number!&quot;</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>      <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> proof sn (g (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span>)) <span class="kw">of</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>                   <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p</span>
<span id="cb24-8"><a href="#cb24-8"></a>                   _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Input if larger than 255&quot;</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>  <span class="kw">where</span></span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="ot">    g ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="dt">Guesses</span> n)</span>
<span id="cb24-11"><a href="#cb24-11"></a>    g _ <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<h3 id="attempt-5-singletons">Attempt 5: Singletons</h3>
<p>This is not the only solution, one more solution was provided by Richard Eisenberg I have not found it in mailing list archives so including it here.</p>
<p>The idea is that we may use less effective representation for typelevel naturals, i.e. unary naturals we can build a proof using singletons:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell, DataKinds, PolyKinds, TypeFamilies,</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="ot">             ScopedTypeVariables, TypeOperators, UndecidableInstances,</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="ot">             GADTs, RankNTypes #-}</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="ot">{-# OPTIONS_GHC -ftype-function-depth=300 -fcontext-stack=300 #-}</span></span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="kw">import</span> <span class="dt">Data.Singletons.TH</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> <span class="kw">hiding</span> ( <span class="dt">Nat</span> )</span>
<span id="cb25-8"><a href="#cb25-8"></a></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="op">$</span>(singletons [d|</span>
<span id="cb25-10"><a href="#cb25-10"></a>  data Nat = Zero | Succ Nat</span>
<span id="cb25-11"><a href="#cb25-11"></a></span>
<span id="cb25-12"><a href="#cb25-12"></a>  leNat :: Nat -&gt; Nat -&gt; Bool</span>
<span id="cb25-13"><a href="#cb25-13"></a>  leNat Zero     _        = True</span>
<span id="cb25-14"><a href="#cb25-14"></a>  leNat (Succ _) Zero     = False</span>
<span id="cb25-15"><a href="#cb25-15"></a>  leNat (Succ a) (Succ b) = a `leNat` b</span>
<span id="cb25-16"><a href="#cb25-16"></a>  |])</span>
<span id="cb25-17"><a href="#cb25-17"></a></span>
<span id="cb25-18"><a href="#cb25-18"></a><span class="co">-- | Singletons's 'withSomeSing' is what we want, but a bug in 7.8.3 doesn't</span></span>
<span id="cb25-19"><a href="#cb25-19"></a><span class="co">-- let it work without a specialized type for 'Nat's</span></span>
<span id="cb25-20"><a href="#cb25-20"></a><span class="ot">withSomeNat ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> (<span class="kw">forall</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="op">.</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb25-21"><a href="#cb25-21"></a>withSomeNat <span class="ot">=</span> withSomeSing</span>
<span id="cb25-22"><a href="#cb25-22"></a></span>
<span id="cb25-23"><a href="#cb25-23"></a><span class="co">-- | Conveniently generate unary naturals</span></span>
<span id="cb25-24"><a href="#cb25-24"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">U</span> n <span class="kw">where</span></span>
<span id="cb25-25"><a href="#cb25-25"></a>  <span class="dt">U</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb25-26"><a href="#cb25-26"></a>  <span class="dt">U</span> n <span class="ot">=</span> <span class="dt">Succ</span> (<span class="dt">U</span> (n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb25-27"><a href="#cb25-27"></a></span>
<span id="cb25-28"><a href="#cb25-28"></a><span class="ot">toNat ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Nat</span></span>
<span id="cb25-29"><a href="#cb25-29"></a>toNat n <span class="op">|</span> n <span class="op">&lt;</span> <span class="dv">0</span>      <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb25-30"><a href="#cb25-30"></a>        <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go n</span>
<span id="cb25-31"><a href="#cb25-31"></a>  <span class="kw">where</span></span>
<span id="cb25-32"><a href="#cb25-32"></a>    go <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb25-33"><a href="#cb25-33"></a>    go n <span class="ot">=</span> <span class="dt">Succ</span> (go (n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb25-34"><a href="#cb25-34"></a></span>
<span id="cb25-35"><a href="#cb25-35"></a><span class="kw">type</span> <span class="dt">Bound</span> <span class="ot">=</span> <span class="dt">U</span> <span class="dv">255</span></span>
<span id="cb25-36"><a href="#cb25-36"></a></span>
<span id="cb25-37"><a href="#cb25-37"></a><span class="co">-- easier to test in GHCi than a proper 'main'</span></span>
<span id="cb25-38"><a href="#cb25-38"></a><span class="ot">go ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb25-39"><a href="#cb25-39"></a>go n <span class="ot">=</span></span>
<span id="cb25-40"><a href="#cb25-40"></a>   <span class="kw">case</span> toNat n <span class="kw">of</span></span>
<span id="cb25-41"><a href="#cb25-41"></a>     <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;Input is not a natural number!&quot;</span></span>
<span id="cb25-42"><a href="#cb25-42"></a>     <span class="dt">Just</span> nat <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="op">$</span> withSomeNat nat <span class="op">$</span> \ snat <span class="ot">-&gt;</span></span>
<span id="cb25-43"><a href="#cb25-43"></a>       <span class="kw">case</span> snat <span class="ot">`sLeNat`</span> (<span class="ot">sing ::</span> <span class="dt">Sing</span> <span class="dt">Bound</span>) <span class="kw">of</span></span>
<span id="cb25-44"><a href="#cb25-44"></a>         <span class="dt">STrue</span>  <span class="ot">-&gt;</span> f snat</span>
<span id="cb25-45"><a href="#cb25-45"></a>         <span class="dt">SFalse</span> <span class="ot">-&gt;</span> <span class="st">&quot;Didn't work&quot;</span></span>
<span id="cb25-46"><a href="#cb25-46"></a></span>
<span id="cb25-47"><a href="#cb25-47"></a><span class="ot">f ::</span> <span class="kw">forall</span> proxy (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="op">.</span> (n <span class="ot">`LeNat`</span> <span class="dt">Bound</span>) <span class="op">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> proxy n <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb25-48"><a href="#cb25-48"></a>f _ <span class="ot">=</span> <span class="st">&quot;It worked!&quot;</span></span></code></pre></div>
<h3 id="attempt-6-using-luquid-haskell">Attempt 6: Using Luquid haskell</h3>
<p>Ranjit Jhala, provided a great solution for liquid haskell, that could be found either by <a href="http://goto.ucsd.edu:8090/index.html#?demo=permalink%2F1418064183.hs">url</a> or here:</p>
<hr />
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="co">{-@ LIQUID &quot;--no-termination&quot; @-}</span></span>
<span id="cb26-3"><a href="#cb26-3"></a></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="kw">module</span> <span class="dt">Nat255</span> <span class="kw">where</span></span>
<span id="cb26-5"><a href="#cb26-5"></a></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="co">-- | Define a predicate for valid integers</span></span>
<span id="cb26-7"><a href="#cb26-7"></a></span>
<span id="cb26-8"><a href="#cb26-8"></a><span class="co">{-@ predicate IsValid X = 0 &lt;= X &amp;&amp; X &lt; 255 @-}</span></span>
<span id="cb26-9"><a href="#cb26-9"></a></span>
<span id="cb26-10"><a href="#cb26-10"></a><span class="co">-- | Use the predicate to define a refinement type (subset) of valid integers</span></span>
<span id="cb26-11"><a href="#cb26-11"></a></span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="co">{-@ type Valid = {v:Int | IsValid v}        @-}</span></span>
<span id="cb26-13"><a href="#cb26-13"></a></span>
<span id="cb26-14"><a href="#cb26-14"></a><span class="co">-- | A function that checks whether a given Int is indeed valid</span></span>
<span id="cb26-15"><a href="#cb26-15"></a></span>
<span id="cb26-16"><a href="#cb26-16"></a><span class="co">{-@ isValid   :: n:Int -&gt; {v:Bool | Prop v &lt;=&gt; IsValid n} @-}</span></span>
<span id="cb26-17"><a href="#cb26-17"></a>isValid n     <span class="ot">=</span> <span class="dv">0</span> <span class="op">&lt;=</span> n <span class="op">&amp;&amp;</span> n <span class="op">&lt;</span> (<span class="dv">255</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb26-18"><a href="#cb26-18"></a></span>
<span id="cb26-19"><a href="#cb26-19"></a><span class="co">-- | A function that can only be called with Valid Ints.</span></span>
<span id="cb26-20"><a href="#cb26-20"></a></span>
<span id="cb26-21"><a href="#cb26-21"></a><span class="co">{-@ workWithValidNumber :: Valid -&gt; IO () @-}</span> </span>
<span id="cb26-22"><a href="#cb26-22"></a>workWithValidNumber n <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;This is a valid number&quot;</span> <span class="op">++</span> <span class="fu">show</span> (<span class="ot">n ::</span> <span class="dt">Int</span>)</span>
<span id="cb26-23"><a href="#cb26-23"></a></span>
<span id="cb26-24"><a href="#cb26-24"></a><span class="co">-- | This is fine...</span></span>
<span id="cb26-25"><a href="#cb26-25"></a>ok    <span class="ot">=</span> workWithValidNumber <span class="dv">12</span></span>
<span id="cb26-26"><a href="#cb26-26"></a></span>
<span id="cb26-27"><a href="#cb26-27"></a><span class="co">-- | ... But this is not.        </span></span>
<span id="cb26-28"><a href="#cb26-28"></a>notOk <span class="ot">=</span> workWithValidNumber <span class="dv">257</span></span>
<span id="cb26-29"><a href="#cb26-29"></a></span>
<span id="cb26-30"><a href="#cb26-30"></a><span class="co">-- | Finally the top level loop that inputs a number, tests it </span></span>
<span id="cb26-31"><a href="#cb26-31"></a><span class="co">--   and calls `workWithValidNumber` if the number is valid.</span></span>
<span id="cb26-32"><a href="#cb26-32"></a></span>
<span id="cb26-33"><a href="#cb26-33"></a>loop <span class="ot">=</span> <span class="kw">do</span> <span class="fu">putStrLn</span> <span class="st">&quot;Enter Number between 0 and 255&quot;</span></span>
<span id="cb26-34"><a href="#cb26-34"></a>          n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb26-35"><a href="#cb26-35"></a>          <span class="kw">if</span> isValid n</span>
<span id="cb26-36"><a href="#cb26-36"></a>             <span class="kw">then</span> workWithValidNumber n</span>
<span id="cb26-37"><a href="#cb26-37"></a>             <span class="kw">else</span> <span class="fu">putStrLn</span> <span class="st">&quot;Humph, bad input, try again!&quot;</span> <span class="op">&gt;&gt;</span> loop</span></code></pre></div>
<p>I hope you have enjoyed reading this.</p>

<hr />
<div id="sociallinks" class="pull-left">
    <strong>Share on:</strong>
  <a href="https://twitter.com/home?status=http://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" target="_blank" class="social" title="twit it">t</a>  
  <a href="http://www.facebook.com/sharer/sharer.php?u=http://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" target="_blank" class="social" title="share on facebook">F</a> 
  <a href="https://plus.google.com/share?url=http://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" target="_blank" class="social" title="share on g+">g</a>
</div>

<br class="clearfix" />
<hr />


<div id="disqus_thread"></div>
  <script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'qnikst'; // required: replace example with your forum shortname

  (function() {
     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                                                                                                           

  </div>

  <footer>
    powered by <a href="http://jaspervdj.be/hakyll">Hakyll</a> &amp; <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a>
  </footer>

<script type="text/javascript">
    //      <noscript> я очень хочу вас посчитать, напишите комментарий хотя бы, пожааалуйста </noscript>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-38941774-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>
