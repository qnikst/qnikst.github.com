<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Qnikst blog - Сериализация структур данных в Haskell.<br /> Часть 1: типы данных</title>
    <!-- Bootstrap -->
    <link href="../css/additional.css" rel="stylesheet" media="screen">
    <link href="../css/hscolour.css" rel="stylesheet" media="screen">
    <link href="../css/hakyll.css" rel="stylesheet" media="screen">
    <script src="https://code.jquery.com/jquery-latest.js"></script> 
    <script src="../js/bootstrap.min.js"></script>
    
</head>
<body>
  <div id="header">
      <div id="caption">
      <font color="green"><u>module</u></font> <a href="../">QnikstBlog</a>
      </div>
      <div id="navigaion">
      <font color="cyan">(</font> <a href="../posts.html">Blog</a>
      <font color="cyan">,</font> <a href="../projects.html">Projects</a>
      <font color="cyan">,</font> <a href="../rss.xml">RSS</a>
      <font color="cyan">)</font> <font color="green"><u>where</u></font>
      </div>
  </div>

  <div id="content">
    <meta name="keywords" content="haskell">


<div class="page-header">
    <div class="right">
      <strong>September  6, 2013</strong>
    </div>
    <h1>Сериализация структур данных в Haskell.<br /> Часть 1: типы данных</h1>
    <div class="keywords"><strong>Keywords:</strong> <a href="../tags/haskell.html">haskell</a></div>
    <div class="abstract"><strong>Abstract</strong><br>
    </div>
</div>

<div style="float:right; width:200px">
<strong>Updates:</strong><br /> 2013-09-06: исправлены ошибки в тексте (спасибо qrilka)
</div>
<p><em>У меня тут в черновиках завалялась старый пост про сериализацию стуктур данных в haskell, доводить её до ума и продолжать мне немного лень, но если будет интересно то могу продолжать. Изначально серия статей предполагалась одновременно с доведением до ума пакета <a href="https://github.com/qnikst/strictput">strictput</a></em></p>
<p>Этим постом я хочу начать небольшую серию статей про сериализацию данных в Haskell. и описание библиотек их реализующих.</p>
<h2 id="типы-данных">Типы данных</h2>
<p>Перед тем как рассматривать непосредственно существующие системы сериализации и сопутсвующие им алгоритмы нужно рассмотреть типы данных, в которые можно сериализовать стуктуры. Это позволит упростить описание самой сериализации, а так же улучшит понимание низкого уровня задачи.</p>
<p>Сама задача сериализации может возникать в двух случаях:</p>
<ol style="list-style-type: decimal">
<li>Взаимодействие с внешним рантаймом, например FFI;</li>
<li>Взаимодействие с внешним миром (IPC, передача в сеть и т.д.)</li>
</ol>
<p>Разница между этими задачами заключается в том, что в первом случае, данные находятся в пространстве одного процесса (группы процессов), а во втором — в разных, и там будет произведено их копирование (существуют варианты, при которых копирование произведено не будет, но их мы оставим в стороне). В связи с этим структуры данных для варинта 1 не должны быть перемещены GC при сборке мусора, поскольку сериализация главным образом интересна нам для второго сценария, то мы не будем посвящать много времени рассмотрению непереносимых (pinned) структур, а будем только отмечать данное свойство.</p>
<h3 id="c-интерфейс">‘C’ интерфейс</h3>
<p>При взаимодействии с файлами или сетью для передачи бинарных данных в C принятно использовать пару “указатель, размер данных”, которая описывает откуда брать данные и сколько. Существуют более интересные варианты для векторной записи (семейство функций read/writev), в этом случае используется массив структур:</p>
<p>struct iovec { void *iov_base; size_t iov_len; }</p>
<p>в некоторых типах данных можно использовать данный подход, что позволит повысить их производительность, но об этом будет сказано отдельно.</p>
<p>Данный интерфейс может быть изображен в haskell как (# Addr#,CSize #) но крайне не рекомендуется так делать, поскольку это сильно усложнит работу с данными, при этом не принося выгоды, поскольку во многих случаях компилятор может преобразовать структуру к виду аналогичному данному.</p>
<p>Для данных, которые являются строковыми в C часто ещё использются null-terminated строки</p>
<h4 id="типы-haskell-соотвествующие-c-интерфейсу">Типы haskell соотвествующие C интерфейсу</h4>
<p>В haskell существуют следующие типы соответсующие указателям в C:</p>
<h5 id="addr">Addr#</h5>
<p>Addr# - unlifted unpacked тип данных являющийся указателем. Стоит напомнить, что данный тип является строгим по построению. С помощью данного типа можно обращаться напрямую к данным внутри примитивных частей программы. Функции для работы с этим типом есть в GHC.Prim (пакет ghc-prim) и Control.Primitive (пакет primitive). Обычно использовние Addr# не нужно, поскольку компилятор умеет приводить приводить работу к данному типу (за это отвечает анализатор строгости).</p>
<h5 id="ptr">Ptr</h5>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Ptr</span> a <span class="fu">=</span> <span class="dt">Ptr</span> (<span class="dt">Addr</span><span class="st">#)</span></code></pre>
<p>Типизированная обертка над Addr (lifted, unpacked по умолчанию (изменится в ghc 7.8)), с помощью данного типа данных можно работать с указателями в “обычном” haskell коде. В подавляющем большинстве случаев ленивость и boxing убираются компилятором. Данный тип не “держит” содержимое на которое указывает и не защищает его от сборки GC.</p>
<p>Функции для работы с указателями предоставляются модулем ‘Foreign.Ptr’</p>
<h5 id="foreignptr">ForeignPtr</h5>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ForeignPtr</span> <span class="fu">=</span> <span class="dt">ForeignPtr</span> <span class="dt">Addr</span><span class="st"># ForeignPtrConents</span></code></pre>
<p>Указатель, к которому можно привязывать финализаторы: действие которое должно быть выполнено как только не осталось ссылок на ForeignPtr из кода.</p>
<h3 id="общее-описание-структур-данных">Общее описание структур данных</h3>
<h4 id="cstringcstring-len">CString/CString Len</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">type</span> <span class="dt">CString</span> <span class="fu">=</span> <span class="dt">Ptr</span> <span class="dt">CChar</span> <span class="co">-- Defined in `Foreign.C.String`</span>
    <span class="kw">type</span> <span class="dt">CStringLen</span> <span class="fu">=</span> (<span class="dt">Ptr</span> <span class="dt">CChar</span>, <span class="dt">Int</span>) <span class="co">-- Defined in `Foreign.C.String`</span></code></pre>
<p>Тип данных соответсвующий null-terminated и length строкам соответсвенно, обычно используется для взаимодействия с C кодом, поскольку данный тип строк является pinned. Данный тип может быть эффективно использован для низкоуровнего взаимодействия с C кодом. Стоит отметить, что существует модификация CString (ACString) в которой выделение происходит на стеке, а не в куче.</p>
<p>Характеристики:</p>
<ul>
<li>строгий</li>
<li>небезопасный</li>
<li>не предоставляет возможности работы с данными</li>
</ul>
<p>Операции над типом:</p>
<ul>
<li>библиотеки haskell не предоставляют операций над данным типом данных</li>
</ul>
<h4 id="string">String</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">type</span> <span class="dt">String</span> <span class="fu">=</span> [<span class="dt">Char</span>]</code></pre>
<p>Очень широко используемый тип данных для внутреннего представления текcтовых строк в виде потока (Stream/Lazy-Cons-List). Данный тип предоставляется базовой библиотекой Prelude и поэтому весьма часто используется не по назначению. Поскольку структура данных является ленивой, то возможно создание бесконечных и цикличеких списков, а так же итеративное построение списка.</p>
<p>Характеристики:</p>
<ul>
<li>ленивый</li>
<li>безопасный</li>
<li>простой в использовании</li>
<li>можно использовать pattern matching без дополнительных расширений</li>
<li>очень низкая локальность данных (не кэш локальный)</li>
<li>высокий overhead по памяти для хранения списка (x+8+2)*n+8</li>
<li>очень низкая скорость работы</li>
<li>внутренний (не pinned тип)</li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.646">build/foldr deforestation</a></li>
<li>IO библиотека существует, но все методы являются ленивыми, что подвергается жесткой критике, рекомендуется использовать не ленивый ввод-вывод, а итеративные библиотеки такие как pipes, conduit, или iteratee.</li>
</ul>
<p>Build/forldr deforestation позволяет не создавать списки в том случае, если это без этого можно обойтись, например, в случаях, если списки играют роль “клея” между операциями,.</p>
<p>Операции над структурой данных:</p>
<ul>
<li>size: O(N) /N прыжков по памяти/ const по памяти</li>
<li>a <code>append</code> b: O(size a), O(size a) выделяется строка O(size a), ‘a’ может быть освобождена.</li>
<li>a +: b -&gt; O(1),</li>
<li>a :+ b -&gt; O(size a)</li>
</ul>
<p>Все операции изменяющие структуру данных пересоздают структуру слева от списка.</p>
<h4 id="word8">[Word8]</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">data</span> [] a <span class="fu">=</span> [] <span class="fu">|</span> a <span class="fu">:</span> [a]</code></pre>
<p>Аналог String для бинарных типов данных, к данному типу применяемы все пункты относящиеся к String, кроме того, что нету возможностей работы с вводом выводом.</p>
<h4 id="text">Text</h4>
<p>Современный внутренний тип для предствления строковых данных. Однако рассмотрение данного типа выходит за рамки поста.</p>
<h4 id="bytestring">ByteString</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">data</span> <span class="dt">ByteString</span> <span class="fu">=</span> <span class="dt">PS</span> 
          <span class="ot">{-# UNPACK #-}</span> (<span class="dt">ForeignPtr</span> <span class="dt">Word8</span>) 
          <span class="ot">{-# UNPACK #-}</span> <span class="dt">Int</span> 
          <span class="ot">{-# UNPACK #-}</span> <span class="dt">Int</span></code></pre>
<p>Данная структура обощает представление данных CStringLen добавляя в него параметр offset, что позволяет сильно расширить круг операций, которые доступны и безопасны. Для данного типа вся работа с памятью скрыта и пользовател предоставляется чистый и безопасный интерфейс для работы.</p>
<p>Размер структуры ~16байт+выделенная память, она является полностью строгой.</p>
<p>Данный тип работает с pinned memory посредством libc вызовов и предоставляет быстрый интерфейс для работы с бинарными данными. Операции не требующие изменения самих данных (take,drop) создают новый заголовок O(1), 8 Byte располагающийся в памяти RTS (relocable). Операции требующие изменения данных создают новую строку. Данная структура данных не поддерживает deforestation, но является самой эффективной структурой данных для хранения строк, которые должны быть прочитаны и не изменяются.</p>
<p>То, что каждый из блоков данных содержит указатель на начало выделенной памяти позволяет обходиться без дополнительного копирования структуры удаляя её в том случае, если на неё никто не ссылается.</p>
<h4 id="lazy-bytestring">Lazy ByteString</h4>
<p>data ByteString = Empty | Chunk !Internal.ByteString ByteString</p>
<p>Как можно увидеть данная структура изоморфна списку байтстрок, однако есть существенное отличие: внутри каждого чанка существует не произвольная строка, а строка определенного размера. (64k)</p>
<h3 id="перевод-типов-данных-друг-в-друга">Перевод типов данных друг в друга</h3>
<p>Для того, чтобы показать как перечисленные типы данных переходят друг в друга, в конце поста я привел абсолютно невоспринимаемую картинку (кто хочет може предложить мне более адекватный вариант).</p>
<p>При переводе типов из одного в другой нужно следить за следующими вещами:</p>
<ol style="list-style-type: decimal">
<li>алгоритмическая сложность операции;</li>
<li>размер выделяемых структур данных;</li>
<li>энергичность/ленивость операции;</li>
<li>безопасность операции.</li>
</ol>
<p>С первым пунктом все важно, второй тоже важен, так как агрессивное использование памяти существенно может изменить поведение программы относительно ожидаемого. То же относится и к ленивости, в этом случае нужно понимать, какие плюсы идут от ленивости, и не может ли произойти каскадное “форсирование” вычислений в тот момент, когда этого допускать нельзя.</p>
<p>С безопасностью операций дело обстоит интереснее, в том случае если мы передаем выделенную память вне рантайма Haskell, мы не можем гарантировать чистоту данной структуры, так как внешнее окружениме может изменять память как хочет. Обычно для сохранения чистоты в рантайм передается не сама структура, а её копия ’useAs*’. В этом случае нужно понимать, что данный подход приводит к увеличению сложности алгоритма и дополнительной нагрузке на память.</p>
<p>Картинка кликабельна: <a href="../images/posts/parser-1/1.png" target="_blank"><img src="../images/posts/parser-1/1.png" /></a></p>

<hr />
<div id="sociallinks" class="pull-left">
    <strong>Share on:</strong>
  <a href="https://twitter.com/home?status=http://qnikst.github.io/posts/2013-09-06-serialization-p1.html" target="_blank" class="social" title="twit it">t</a>  
  <a href="http://www.facebook.com/sharer/sharer.php?u=http://qnikst.github.io/posts/2013-09-06-serialization-p1.html" target="_blank" class="social" title="share on facebook">F</a> 
  <a href="https://plus.google.com/share?url=http://qnikst.github.io/posts/2013-09-06-serialization-p1.html" target="_blank" class="social" title="share on g+">g</a>
</div>

<div class="pull-right">
    <em>Alexander Vershilov</em>
    <a href="https://creativecommons.org/licenses/by-nc-sa/3.0"><img src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
</div>
<br class="clearfix" />
<hr />


<div id="disqus_thread"></div>
  <script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'qnikst'; // required: replace example with your forum shortname

  (function() {
     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                                                                                                           

  </div>

  <footer>
    powered by <a href="http://jaspervdj.be/hakyll">Hakyll</a> &amp; <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a>
  </footer>
<script type="text/javascript">
    //      <noscript> я очень хочу вас посчитать, напишите комментарий хотя бы, пожааалуйста </noscript>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-38941774-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>
