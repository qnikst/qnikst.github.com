<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - Post tagged C</title>
    <link href="https://qnikst.github.io/tags/C.xml" rel="self" />
    <link href="https://qnikst.github.io" />
    <id>https://qnikst.github.io/tags/C.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2018-08-22T00:00:00Z</updated>
    <entry>
    <title>Marrying Haskell and Hyper-Threading (Post Scriptum)</title>
    <link href="https://qnikst.github.io/posts/2018-08-27-ht-no-more2.html" />
    <id>https://qnikst.github.io/posts/2018-08-27-ht-no-more2.html</id>
    <published>2018-08-22T00:00:00Z</published>
    <updated>2018-08-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>After writing of the previous blog <a href="/posts/2018-08-23-ht-no-more.html">post</a>, I got some interesting feedback from the working chat and <a href="https://www.reddit.com/r/haskell/comments/99rihw/qnikst_blog_marrying_haskell_and_hyperthreading/">r/haskell</a>. Some of the input I want to hightlight explicitly. Feedback order is arbitrary.</p>
<p>First thing is a discussion of the explicit pinning capabilities to the cores. It’s possible using <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-concurrent.html#rts-flag--qa">+RTS -qa</a> flag, as it was mentioned by the <a href="https://www.reddit.com/user/nh2_">nh2</a> on Reddit. As I mentioned in the previous blog post, my approach will not work with this option correctly (for some reason I have used <code>-xm</code> instead of <code>-qa</code> in that post, I’m sorry) and I’ll need to redefine more functions. But in general pinning capabilities to cores may work on all possible CPU layouts. I have not looked deep inside that issue as in most of our cases <code>-qa</code> flag gave me worse performance, so your program should have some special properties to make benefit from the hard pinning. I think it’s possible to use <code>/proc/cpuinfo</code> to make the most efforts when pinning capabilities.</p>
<p>The entire thread is very entertaining and if you are interested in the topic then I recommend to check out ther comments as well.</p>
<p>Secondly, there was a question if my reasoning was incorrect and it’s enough to leave one thread off and still have better performance. We used this approach in some projects, however for one particular case the results with <code>N-1</code> threads were very depressing:</p>
<pre><code>        Cumulative quantiles per tag (N7)
        99%       98%     95%    90%    85%      80%   75%    50%
Overall 4600ms   4380ms   3980ms 3540ms 3400ms 3280ms 3210ms 1105ms
get     4600ms   4390ms   3980ms 3550ms 3410ms 3290ms 3210ms 1145ms
put     4600ms   4380ms   3980ms 3540ms 3400ms 3280ms 3210ms 1100ms</code></pre>
<pre><code>        Cumulative quantiles per tag (N4)
        99%       98%     95%      90%    85%     80%   75%    50%
Overall  139ms    105ms     37ms   17ms   12ms    8ms    6ms    2ms
get      139ms    104ms     37ms   18ms   12ms    9ms    7ms    2ms
put      139ms    105ms     37ms   17ms   12ms    8ms    6ms    2ms</code></pre>
<p>There is 1 to 3 orders of magnitude differences in response times, without going deeper I have decided to stick with <code>-N4</code> for now.</p>
<p>The third, @<a href="https://github.com/TerrorJack">TerrorJack</a> adviced me to improve <a href="https://github.com/ghc/ghc/blob/1c2c2d3dfd4c36884b22163872feb87122b4528d/rts/RtsMain.c#L70-L95">teardown</a> procedure in the <code>wrapper.c</code>, as it should check if<code>RTS</code> was stopped and report its status. So I have rechecked the sources and introduced few updates that allow to report status of running haskell command (the same way as RTS does), and which do not require using FFI extension in the Haskell code.</p>]]></summary>
</entry>
<entry>
    <title>Marrying Haskell and Hyper-Threading</title>
    <link href="https://qnikst.github.io/posts/2018-08-23-ht-no-more.html" />
    <id>https://qnikst.github.io/posts/2018-08-23-ht-no-more.html</id>
    <published>2018-08-22T00:00:00Z</published>
    <updated>2018-08-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In this blog post I’d like to tell one story that had happened with one Haskell application. Then I’ll explain how can we start threaded RTS in a way so it is aware of the CPU layout of your system. If you want to skip the story you may proceed to the solution directly.</p>
<p>Some updates to this post can be found in the <a href="./2018-08-27-ht-no-more2.html">next one</a>.</p>
<p>Recently I’ve written a small Haskell application that performs some cryptography routines, query management, and communication with Redis. We wanted to test the capabilities of the application and measure RPS that application can support. We used Yandex Tank for this purpose. <a href="https://yandextank.readthedocs.io/en/latest/index.html">Yandex tank</a> can generate a load for a site and build some <a href="https://overload.yandex.net/1">fantastic reports</a> (it could require GitHub authorization).</p>
<p>Results were quite interesting. At first everything went well: the application was able to process about <code>1k</code> requests per second and that was enough for the expected load. However, when Yandex Tank gave a pressure of about <code>2k</code> RPS the situation became worse. The application stopped being responsive. It was able to process only <code>200</code> requests per second. That was troublesome. On the Yandex tank plots there was a period of reasonable performance and then a period of unresponsiveness.</p>
<img src="../images/posts/ht-no-more/1.plot.jpg" alt="Spikes on the tank terminal report" />
<div>
<img src="../images/posts/ht-no-more/2.tank.report.png" width="399" style="inline"/><img src=" ../images/posts/ht-no-more/3.tank.report.png" width="399" style="inline"/>
</div>
<p>As it happens the first suspect in such cases is the Garbage Collector. You can always hear lots of scary stories about how GC could ruin your life. Keeping that in mind GC was tuned beforehand and I had prepared some metrics. However this time the situation was quite OK: garbage collector pauses were all below 10ms and 99% of the total program time was spent on actual work and not on garbage collection. Memory usage was too big - around 700Mb and I didn’t expect that.</p>
<figure>
<img src="../images/posts/ht-no-more/4.gc-info.jpg" alt="GC Information" /><figcaption>GC Information</figcaption>
</figure>
<p>On the left plot you can see reports of the last GC, they are not very precise as they may miss some GCs or report the same GC twice. However they still tell us the order of magnutude. On the right plot we see the ratio of the time spent in mutator to the total running time.</p>
<p>Other parts of the system were not under a stress and were capable of handling higher loads. So the issue was in my program. Although I didn’t spend much time optimising the program, it should behave better.</p>
<p>Another surprising fact was that the issue didn’t appear on my system which is comparable to the one where stress tests were running, and the one that could handle higher load. Accidentally I realised the difference, and the following dialogue took place:</p>
<blockquote>
<p>Me: What is the CPU on the system?</p>
<p>Admin: I7 4 cores, eight thread!</p>
<p>Me: Ah! Add <code>GHCRTS=-N4</code> to the container’s Environment.</p>
</blockquote>
<p>After that single adjustment the situation changed drastically: the program was now able to process 4.5k RPS (comparable to the maximum load that a single instance of Yandex.Tank can generate), now mutator time got &gt;99%, GC pauses were still ~10ms but very rare and memory usage was about 25Mb.</p>
<img src="../images/posts/ht-no-more/4.gc-info.jpg" alt="GC Information" />
<div>
<img src="../images/posts/ht-no-more/5.tank.report.png" width="399" style="inline"/><img src=" ../images/posts/ht-no-more/6.tank.report.png" width="399" style="inline"/>
</div>
<p>Connect time was still terrible in that case but it was fixed by reconfiguring and improving network which is out of scope here.</p>
<p>So this is just another story about suboptimal defaults for the runtime system. It happens that if you pass <code>+RTS -N</code> option - you tell runtime system to start the same number of capabilities as the number of cores you have. However, <code>RTS</code> makes no difference between real and virtual cores. It appears that <code>RTS</code> could not make enough benefit from virtual cores and performance is not good enough in that case.</p>
<p>While it is pretty impressive that we can optimise a program without any changes in source code, it’s interesting what can we do in general case. It’s problematic that we can not set good options which work on any CPU and have a decent performance. To find an answer I’ve started the project <a href="https://github.com/qnikst/haskell-fun/tree/master/ht-no-more">ht-no-more</a>. It lives in my playground for now but I can extract it to a separate repo. I hope that at some point it will be mature enough to be used as a library or even land to into the RTS source code.</p>
<h2 id="solution">Solution <a name="solution"></a></h2>
<p>The idea is to gather information about the architecture during a program startup and then set up an RTS with a proper configuration. We want:</p>
<ol type="1">
<li>collect information about a CPU (how many real and how many virtual cores do we have);</li>
<li>do not allow RTS to run work on virtual cores;</li>
<li>make it so <code>+RTS -N</code> option still behaves well.</li>
</ol>
<p><em>N.B. From this place and now on we assume that we run on <code>Linux</code> only and that we have <code>procfs</code> mounted and that we can write non-portable code. Now our life is comfortable, and we can proceed with the task.</em></p>
<p>The first question is how can we tie our process to a <code>CPU</code>. There are <a href="https://linux.die.net/man/2/sched_setaffinity">sched_getaffinity()</a> and <a href="https://linux.die.net/man/2/sched_setaffinity">sched_setaffinity()</a> calls. Those methods perform hard wiring of a process and all it’s descendent processes to given CPUs. So we can use them to mask CPUs that we are not interested in.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="dt">int</span> sched_setaffinity(pid_t pid, <span class="dt">size_t</span> cpusetsize,</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">                      cpu_set_t *mask);</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="dt">int</span> sched_getaffinity(pid_t pid, <span class="dt">size_t</span> cpusetsize,</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">                      cpu_set_t *mask);</a></code></pre></div>
<p>First let’s write a simple <code>c</code> program that explains the API.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="pp">#define _GNU_SOURCE          </span><span class="co">// allow to use non-portable functions</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="pp">#include </span><span class="im">&lt;sched.h&gt;</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> * argv[]) {</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  cpu_set_t set;            <span class="co">// define CPU set</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  CPU_ZERO(&amp;set);           <span class="co">// mark all CPUs as unused</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  CPU_SET(<span class="dv">0</span>, &amp;set);         <span class="co">// allow to use first CPU</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  sched_setaffinity(<span class="dv">0</span>, <span class="kw">sizeof</span>(cpu_set_t), &amp;set); <span class="co">// wire process to CPU</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  <span class="dt">int</span> result = system(<span class="st">&quot;bash&quot;</span>); <span class="co">// start bash.</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  <span class="cf">return</span> result;</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">}</a></code></pre></div>
<p>In this first program we allow an application to run only on the first CPU. We need this program later for testing purposes. I’ve used it to check if my program behaves well in the constrained case.</p>
<p>The next question is how to check if a processor is real or virtual. The only way I’ve found it is to parse <code>/proc/cpuinfo</code> file. We are interested in <code>core id</code> entry for each processor: it tells what the index of the real core that CPU is set on is. For example on my machine I have:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">grep</span> <span class="st">&#39;core id&#39;</span> /proc/cpuinfo </a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ex">core</span> id        : 0</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ex">core</span> id        : 1</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ex">core</span> id        : 2</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ex">core</span> id        : 3</a></code></pre></div>
<p>As I have Hyper-Threading disabled - all cores are real ones. On digital ocean host, I have:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">grep</span> <span class="st">&#39;core id&#39;</span> /proc/cpuinfo </a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">core</span> id        : 0</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ex">core</span> id        : 0</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ex">core</span> id        : 0</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ex">core</span> id        : 0</a></code></pre></div>
<p>all CPU are on the same core (at least for the container).</p>
<p>Now we can combine the answers to the questions and write the code. We need to remember that there is an additional case that we want to cover: if the CPU was already disabled for our program – then we don’t want to “unmask” it. As a result, I ended up with the following code:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dt">int</span> setcpus() {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">   cpu_set_t set;</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">   <span class="dt">int</span> ret = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">   ret = sched_getaffinity(<span class="dv">0</span>, <span class="kw">sizeof</span>(cpu_set_t), &amp;set);</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">   <span class="cf">if</span> (ret == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">     fprintf(stderr, <span class="st">&quot;Error: failed to get cpu affinity&quot;</span>);</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">     <span class="cf">return</span> <span class="dv">0</span>; <span class="co">// We instruct code that we have failed and it should fallback to the normal procedure.</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">   }</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">   <span class="dt">int</span> current_cpu = <span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">   <span class="dt">int</span> current_core = <span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">   <span class="dt">FILE</span> *cpuinfo = fopen(<span class="st">&quot;/proc/cpuinfo&quot;</span>, <span class="st">&quot;rb&quot;</span>);</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">   <span class="dt">char</span> *arg = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">   <span class="dt">size_t</span> size = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"></a>
<a class="sourceLine" id="cb5-16" data-line-number="16"></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">   <span class="cf">while</span>(getdelim(&amp;arg, &amp;size, <span class="ch">&#39;\n&#39;</span>, cpuinfo) != <span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">   {</a>
<a class="sourceLine" id="cb5-19" data-line-number="19">      <span class="cf">if</span> (strstr(arg, <span class="st">&quot;core id&quot;</span>) != NULL) {</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">	current_core++;</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">	<span class="dt">char</span> * found = strchr(arg, <span class="ch">&#39;:&#39;</span>);</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">	<span class="cf">if</span> (found) {</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">	   <span class="dt">int</span> cpu = atoi(found+<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">	   <span class="cf">if</span> (current_cpu != cpu) {</a>
<a class="sourceLine" id="cb5-25" data-line-number="25">              current_cpu++;</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">	      <span class="cf">if</span> (CPU_ISSET(current_core, &amp;set)) {</a>
<a class="sourceLine" id="cb5-27" data-line-number="27">	         CPU_SET(current_core, &amp;set);  <span class="co">// XXX: this is noop.</span></a>
<a class="sourceLine" id="cb5-28" data-line-number="28">	         fprintf(stderr, <span class="st">&quot;%i real core - enabling</span><span class="sc">\n</span><span class="st">&quot;</span>, current_core);</a>
<a class="sourceLine" id="cb5-29" data-line-number="29">	      } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb5-30" data-line-number="30">	         fprintf(stderr, <span class="st">&quot;%i was disabled - skipping</span><span class="sc">\n</span><span class="st">&quot;</span>, current_core);</a>
<a class="sourceLine" id="cb5-31" data-line-number="31">	      }</a>
<a class="sourceLine" id="cb5-32" data-line-number="32">           } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb5-33" data-line-number="33">              fprintf(stderr, <span class="st">&quot;%i is virual - skipping</span><span class="sc">\n</span><span class="st">&quot;</span>, current_core);</a>
<a class="sourceLine" id="cb5-34" data-line-number="34">	      CPU_CLR(current_core, &amp;set);</a>
<a class="sourceLine" id="cb5-35" data-line-number="35">           }</a>
<a class="sourceLine" id="cb5-36" data-line-number="36">        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb5-37" data-line-number="37">	   <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb5-38" data-line-number="38">	}</a>
<a class="sourceLine" id="cb5-39" data-line-number="39">      }</a>
<a class="sourceLine" id="cb5-40" data-line-number="40">   }</a>
<a class="sourceLine" id="cb5-41" data-line-number="41">   ret = sched_setaffinity(<span class="dv">0</span>, <span class="kw">sizeof</span>(cpu_set_t), &amp;set);</a>
<a class="sourceLine" id="cb5-42" data-line-number="42">   <span class="cf">if</span> (ret == <span class="dv">-1</span>) {</a>
<a class="sourceLine" id="cb5-43" data-line-number="43">     fprintf(stderr, <span class="st">&quot;Error: failed to set affinities - falling back to default procedure</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb5-44" data-line-number="44">     procno = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-45" data-line-number="45">   } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb5-46" data-line-number="46">     procno = current_cpu;</a>
<a class="sourceLine" id="cb5-47" data-line-number="47">   }</a>
<a class="sourceLine" id="cb5-48" data-line-number="48">   free(arg);</a>
<a class="sourceLine" id="cb5-49" data-line-number="49">   fclose(cpuinfo);</a>
<a class="sourceLine" id="cb5-50" data-line-number="50">   <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-51" data-line-number="51">}</a></code></pre></div>
<p>Now we are ready to build a cabal project. I’m skipping all irrelevant things that are generated by <code>cabal init</code></p>
<pre class="cabal"><code>executable ht-no-more
  main-is:             wrapper.c
  other-modules:       Entry 
  build-depends:       base &gt;=4.10 &amp;&amp; &lt;4.11
  default-language:    Haskell2010
  ghc-options:         -no-hs-main</code></pre>
<p>To highlight the important things: first of all, our main module is a <code>C</code> file. It does not work with old <code>cabal</code>’s that allowed only Haskell modules to be the main one. Then we add <code>-no-hs-main</code> – an option that tells GHC not to create its own “main” and use the “main” function that we define. We define <code>Entry.hs</code> Haskell module that provides an entry function because we no longer have one. In that module we create a single function that tells how many capabilities RTS have created.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Entry</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Control.Concurrent</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">foreign export ccall<span class="ot"> entry ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="ot">entry ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">entry <span class="fu">=</span> print <span class="fu">=&lt;&lt;</span> getNumCapabilities</a></code></pre></div>
<p>The only non-trivial thing we need is to export a foreign function. Compiler generates a <code>C</code> complatible object called <code>entry</code> that we can call from <code>C</code>.</p>
<p>We follow <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#using-your-own-main">GHC User’s Guide</a> to define our main function <em>(sidenote, if you haven’t read GHC User’s Guide, please do, it’s the most authoritative and precise source of information about GHC features and extensions)</em>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="pp">#include </span><span class="im">&quot;HsFFI.h&quot;</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="pp">#ifdef __GLASGOW_HASKELL__</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="pp">#include </span><span class="im">&quot;Entry_stub.h&quot;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="pp">#include </span><span class="im">&quot;Rts.h&quot;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> * argv[]) {</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  setcpus();</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  <span class="pp">#if __GLASGOW_HASKELL__ &gt;= 703</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  {</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">     RtsConfig conf = defaultRtsConfig;</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">     conf.rts_opts_enabled = RtsOptsAll;</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">     hs_init_ghc(&amp;argc, &amp;argv, conf);</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">  }</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">  <span class="pp">#else</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">     hs_init(&amp;argc, &amp;argv);</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  <span class="pp">#endif</span></a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  hs_init(&amp;argc, &amp;argv);</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">  entry();</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">  hs_exit();</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">}</a></code></pre></div>
<p>However, we have not done everything. If you try to compile this program and run it with <code>RTS +N</code> you’ll see expected logs but the program reports that you are using the number of capabilities equal to the number of virtual cores. It happens because with <code>RTS +N</code> GHC asks the number of configured processors and creates that number of capabilities. Instead of this we want the count of capabilities to be equal to the number of real cores. Furthermore, we don’t want to patch GHC just yet because our code is too hacky.</p>
<p><code>GHC RTS</code> is linked statically with each Haskell project. It means that we can use a linker to make RTS use our method instead of the one provided with <code>GHC</code>, we are interested in redefining <code>uint32_t getNumberOfProcessors(void)</code>. For that reason we use linker’s <a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_3.html">wrap feature</a>. If you tell linker <code>-Wl,-wrap, function</code> then for each call to the <code>function</code> it calls <code>__wrap_function</code> instead and generates <code>__real_function</code> that you can call to call the original function.</p>
<p>So we write</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="dt">static</span> <span class="dt">uint32_t</span> procno = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="dt">uint32_t</span> __real_getNumberOfProcessors(<span class="dt">void</span>);</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="dt">uint32_t</span> __wrap_getNumberOfProcessors(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">{</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">   <span class="cf">if</span> (procno==<span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      <span class="cf">return</span> __real_getNumberOfProcessors();</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">   } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">     <span class="cf">return</span> procno;</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">   }</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">}</a></code></pre></div>
<p>to get the desired result. We change cabal to provide required options to the build:</p>
<pre class="cabal"><code>  ghc-options:         -no-hs-main
                       -threaded
                       -optl-Wl,-wrap,getNumberOfProcessors</code></pre>
<p>You can find the full code on <a href="https://github.com/qnikst/haskell-fun/tree/master/ht-no-more">GitHub</a>. There is still much work for this project before you can use it for your application.</p>
<p>There is some further work which could be done:</p>
<ol type="1">
<li>The code could be cleaned and prettified;</li>
<li>The code could be made portable and be able to run on all OSes GHC can run on;</li>
<li>The current approach may be not sub-optimal, maybe it’s enough to redefine <code>getNumberOfProcessors</code> alone without calling <code>sched_setaffinity</code>.</li>
<li>I didn’t test the interference with other functions; for example, if you run a program with <code>-xm</code> flag (that pins capability to CPU) it may fail.</li>
<li>It’s possible to extend this solution and set better GC options based on CPU info</li>
<li>I’m curious if it is possible to write this program as a library and reuse in other projects.</li>
</ol>
<p>All feedback is welcome.</p>]]></summary>
</entry>

</feed>
