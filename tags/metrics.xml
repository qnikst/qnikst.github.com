<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - Post tagged metrics</title>
    <link href="https://qnikst.github.io/tags/metrics.xml" rel="self" />
    <link href="https://qnikst.github.io" />
    <id>https://qnikst.github.io/tags/metrics.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2018-10-09T00:00:00Z</updated>
    <entry>
    <title>Writing a simple web-application</title>
    <link href="https://qnikst.github.io/posts/2018-10-09-starting-webapp.html" />
    <id>https://qnikst.github.io/posts/2018-10-09-starting-webapp.html</id>
    <published>2018-10-09T00:00:00Z</published>
    <updated>2018-10-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the <a href="https://qnikst.github.io/posts/2018-10-29-metrics-haskell.html">last post</a>, I’ve talked about adding metrics to a Haskell application. Unfortunately that post didn’t have a full code example and contained only minor pieces of the code. So it could be hard to write your own application based on that post. So I decided to prepare a full example that can be looked at and reused in later posts and projects. You can find the source code on <a href="https://github.com/qnikst/sample-site">GitHub</a>. The app is a very simple skeleton so if you have experience with writing those feel free to skip this post.</p>
<p>I’ll take <a href="https://www.techempower.com/benchmarks/">the techempower benchmark</a> as a site specification. The API is simple enough to represent exciting features and doesn’t take much time to write. I’m not going to compete against other implementations of that benchmark (at least I think so at the time of writing this post). Today I’m going to make a skeleton of the site and one endpoint only.</p>
<p>I’ll take servant as a web framework, to my taste it is the best framework you can use unless you have exceptional needs. The main feature of the servant framework is that it allows to generate and test much code for free, without much extra cost.</p>
<p>Servant framework has a very nice tutorial and documentation that can be found at <a href="https://haskell-servant.readthedocs.io/en/stable/">read-the-doc site</a> .</p>
<p>When writing an application using servant you first need to define its API:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Api</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">JsonApi</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">type</span> <span class="dt">JsonApi</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="fu">=</span> <span class="dt">Description</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="st">&quot;Raw JSON output API \</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="st">    \ For each request, an object mapping the key message \</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="st">    \ to \&quot;Hello, World!\&quot; must be instantiated.&quot;</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="fu">:&gt;</span> <span class="st">&quot;json&quot;</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="fu">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Message</span></a></code></pre></div>
<p>I prefer to keep a type synonym for each endpoint (or endpoint structure) as that would allow using that type in the other parts of the program for code generation.</p>
<p>This type explains how a handler does its work and <code>:&gt;</code> splits the type into URL pieces. This type tells that application can handle Get requests to the URL <code>/json</code> if accept type is <code>application/json</code> and when doing that it returns a <code>Message.</code></p>
<p>The additional <code>Description</code> part comes from the <a href="http://hackage.haskell.org/package/servant-swagger">servant-swagger</a> package. A few more extra lines provide additional information about our API:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">apiVersion ::</span> <span class="dt">T.Text</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">apiVersion <span class="fu">=</span> <span class="st">&quot;0.0.1&quot;</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">swagger ::</span> <span class="dt">Swagger</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">swagger <span class="fu">=</span> toSwagger (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="dt">Api</span>)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="fu">&amp;</span> info<span class="fu">.</span>title <span class="fu">.~</span> <span class="st">&quot;Experimental API&quot;</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="fu">&amp;</span> info<span class="fu">.</span>description <span class="fu">?~</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    <span class="st">&quot;This is a benchmark site, and used for general \</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="st">    \ experiments and blog examples.&quot;</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="fu">&amp;</span> info<span class="fu">.</span>version <span class="fu">.~</span> apiVersion</a></code></pre></div>
<p>Now we can run the server. Our sever consists of the swagger UI and our application.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">API</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">SwaggerSchemaUI</span> <span class="st">&quot;swagger-ui&quot;</span> <span class="st">&quot;swagger.json&quot;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="fu">:&lt;|&gt;</span> <span class="dt">Api</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">run ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">run <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  Warp.run configPort</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="fu">$</span> prometheus def {</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        prometheusInstrumentPrometheus <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        }</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    <span class="fu">$</span> serve (<span class="dt">Proxy</span> <span class="fu">@</span><span class="dt">API</span>)</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    <span class="fu">$</span> swaggerSchemaUIServer swagger </a>
<a class="sourceLine" id="cb3-13" data-line-number="13">        <span class="fu">:&lt;|&gt;</span> server</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="ot">    configPort ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">    configPort <span class="fu">=</span> <span class="dv">8080</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17"></a>
<a class="sourceLine" id="cb3-18" data-line-number="18"><span class="ot">server ::</span> <span class="dt">Handler</span> <span class="dt">Message</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">server <span class="fu">=</span> pure <span class="fu">$</span> <span class="dt">Message</span> <span class="st">&quot;Hello World!&quot;</span></a></code></pre></div>
<p>Remember <code>prometheus def</code> lines from the previous post. And the application runner is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Prometheus</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Prometheus.Metric.GHC</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Sample.Server</span> (run)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  _ <span class="ot">&lt;-</span> register ghcMetrics</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  run</a></code></pre></div>
<p>Now we can have an application that returns us <code>{message:&quot;Hello, World!&quot;}</code> on <code>json</code> URL and swagger UI on <code>swagger-ui/</code>. With that interface you can explore site API:</p>
<div>
<img src="../images/posts/web-app-1/0.swagger-ui-1.png" width="80%" style="inline"/>
</div>
<p>Send requests and observe results</p>
<div>
<img src="../images/posts/web-app-1/1.swagger-ui-2.png" width="80%" style="inline"/>
</div>
<p>And all that comes for free.</p>
<p>There are a few more things I’d like to discuss before moving to metrics:</p>
<ol type="1">
<li><p><a href="https://github.com/qnikst/sample-site/blob/2d6bb3b39ce6a6e5afe9de055cda73d6babcce0c/sample-site/src/Data/Aeson/Extended.hs#L11-L21">Naming conventions</a> - it’s worth to define common conventions for converting Haskell data types into their JSON representation and use them across the project.</p></li>
<li><p><a href="https://github.com/qnikst/sample-site/blob/master/sample-site/test/spec/Sample/ApiSpec.hs#L23-L35">Encoding tests</a> with servant and swagger you can automatically test serialisation of values for all the types used in the API. Also tests check that specification is up to date.</p></li>
</ol>
<p>Now we have a simple site with helper interface and specification. There are many missing pieces, for example: a. configuration parsing; b. logging; c. more autogenerated tests; d. nice defaults for RTS options.</p>
<p>All of them will be covered in the following posts.</p>
<p>In order to build everything I prefer to use <code>nix</code> package manager. Both <code>stack</code> and <code>cabal-install</code> are nice tools to do that but with nix you can add more features to the build system. For example building of docker containers, building packages written in other languages and setting up a development environment. Build scripts for the package can be found at <a href="https://github.com/qnikst/sample-site/blob/2d6bb3b39ce6a6e5afe9de055cda73d6babcce0c/nix/overlays.nix#L15-L19">overlays.nix</a>. Build scripts for its docker container are in <a href="https://github.com/qnikst/sample-site/blob/2d6bb3b39ce6a6e5afe9de055cda73d6babcce0c/nix/docker.nix#L8-L28">docker.nix</a>.</p>
<p>At this point we are ready to setup our environment with Grafana and Prometheus. Configs are the same as the ones described earlier or they can be found at <a href="https://github.com/qnikst/sample-site/tree/2d6bb3b39ce6a6e5afe9de055cda73d6babcce0c/deploy/docker">GitHub</a>.</p>
<p>Graphana reports are looking like:</p>
<ol type="1">
<li>Main screen: <br /> main screen lists all instances with Haskell application to filter on. If specific instance is chosen then all the following plots show information for that instance only.
<div style="margin: 10px 0;">
<img src="../images/posts/web-app-1/3.grafana-1.png" width="100%" style="inline"/>
</div></li>
<li>CPU panel:<br /> shows rate of CPU seconds spent by the program. Basically it says whaf fraction of a secod the program worked during 1s of clock time. You can realize how active your application was. <code>Mutator CPU time</code> shows how much CPU time you’ve spent doing actual work. If total CPU time is much higher than Mutator CPU time, then you are likely to have problems with GC.
<div style="margin: 10px 0; ">
<img src="../images/posts/web-app-1/4.grafana-1.png" width="100%" style="inline"/>
</div></li>
<li>Memory panel:<br /> shows the rate of allocations and copying data during GC. This panel is for general information because it’s not easier to use other controller to get information about memory usage of the given instance.
<div style="margin: 10px 0;">
<img src="../images/posts/web-app-1/5.grafana-1.png" width="100%" style="inline"/>
</div></li>
<li>GC information:<br /> data that shows GC information that is provided by the runtime system. It provides total number of GCs and major GCs and their rate. Proportion of time spent in GC to the total running time, if this metric grows higher than 0.1 then it means that you are spending one tenth of your time in GCs and that is not good. Proportion of the time that capabilities spent synchronising to the time they did actual work, if this value grows high then you have problems.
<div style="margin: 10px 0;">
<img src="../images/posts/web-app-1/6.grafana-1.png" width="100%" style="inline"/>
</div>
In addition the structure of the heap is explained and we plot how many values of different types (from GC perspective) we have.
<div style="margin: 10px 0;">
<img src="../images/posts/web-app-1/7.grafana-1.png" width="100%" style="inline"/>
</div></li>
</ol>
<p>Config itself can be taken from <a href="https://raw.githubusercontent.com/qnikst/sample-site/master/deploy/docker/rts.json">GitHub</a>.</p>
<p>Unfortunately GC information tells us information about the last GC only so everything that had happened between scribe intervals will be missing from our data. In the next post I’m going to run some benchmarks of the application (and potentially introduce other endpoints) and discuss if missing information is actually a problem and what can be done about that.</p>]]></summary>
</entry>

</feed>
