<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - Post tagged gentoo</title>
    <link href="https://qnikst.github.io/tags/gentoo.xml" rel="self" />
    <link href="https://qnikst.github.io" />
    <id>https://qnikst.github.io/tags/gentoo.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2013-11-06T00:00:00Z</updated>
    <entry>
    <title>Supervision inside OpenRC</title>
    <link href="https://qnikst.github.io/posts/2013-11-06-openrc-supervision.html" />
    <id>https://qnikst.github.io/posts/2013-11-06-openrc-supervision.html</id>
    <published>2013-11-06T00:00:00Z</published>
    <updated>2013-11-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The role of the supervision in the init systems becomes crucial. And many administrators wants some kind of s-vision support from the scratch. Here are some thoughts about this problem and a way how things will be solved inside OpenRC.</p>
<p><small>(As always I’m sorry for my english and maybe problems in technitial details, so any feedback is apprecated</small></p>
<h1 id="the-problem.">The problem.</h1>
<p>The idea of supervision is to take care about running processes and restart them in the case if they fail. It’s interesting to say that ‘fail’ may mean different things:</p>
<ol style="list-style-type: decimal">
<li>Process exited (with non zero EXIT_CODE);</li>
<li>Process fail to work as expected.</li>
</ol>
<p>In the most systems only first meaning is addressed, however it’s not very carefull and in systems where <em>reliance</em> is required we need to use additional tools to support 2.</p>
<p>Another set of problem is about how we will decide if we want to restart service and run cleanup actions. And this problem is not easy at all, i.e. we may want to stop restarting service if it fails constantly, or increase timeout in restarts and so on.</p>
<p>Also we may want additional features like say, remote access/control to supervised services, additinal notification.</p>
<p>And it’s clear that it’s insane to support all required tools inside one service management package, and there the solution will be: ‘give a user possibility to delegate supervision problem to the standalone application’.</p>
<p>So the solution would be the following:</p>
<ol style="list-style-type: decimal">
<li>Let OpenRC know that user may want s-vision for some services and what module he want to use;</li>
<li>Provide a set of existing modules;</li>
<li>Give an ability to create new modules.</li>
</ol>
<h1 id="monit">Monit</h1>
<p>I’ve started to work on ‘monit’ approach. Monit (http://mmonit.com/monit/) is a monitoring that allowes user to monitor services and give much possibilites for their control. This tool provides a special language that describes how each service should be monitored started and restarted.</p>
<p>Currently it’s possible to run monit as a standalone daemon and then control supervision via monit itself by calling <code>monit foo start</code>/<code>monit foo stop</code>. However having OpenRC as a common point for services control is a good idea.</p>
<p>All the code available on s-vision branch (https://github.com/qnikst/openrc/compare/s-vision) and will be merged to mainline after some discussion with other developers and administrators that have a good experience with running monit.</p>
<p>In order to put service under monit control one need:</p>
<ol style="list-style-type: decimal">
<li><p>Run monit under inittab control (or other low level s-vision subsystem). This can be done by adding:</p>
<pre><code>MO:2345:respawn:/usr/bin/monit -Ic /etc/monitrc</code></pre></li>
</ol>
<p>to inittab</p>
<ol start="2" style="list-style-type: decimal">
<li><p>Add temporary config path under monit control (/etc/monitrc)</p>
<pre><code>INCLUDE /run/openrc-monit/*</code></pre></li>
<li><p>Create control file for service under <code>/etc/conf.d/monit-files/servicename</code></p></li>
<li><p>Add s-vision module to conf.d file, i.e.</p>
<pre><code>rc_supervise_module=&quot;monit&quot;
rc_monit_type=&quot;file&quot;</code></pre></li>
</ol>
<p>When you will trigger service start it will check that it is supervised, copy all related files to the temporary config path, and then call <code>monit start service</code>, that will trigger file once again, but init will understand that it is monitored, and start service as usual.</p>
<p><span class="label label-warning"> Update: </span> the idea is just to hook up into <code>start_post</code> all call <code>monit restart</code> and <code>monit monitor</code> from there.</p>
<h1 id="future-work">Future work</h1>
<p>There are a couple of work to be done before merging:</p>
<ol style="list-style-type: decimal">
<li><p>Introduce other <code>monit_types</code> like:</p>
<ul>
<li>simple - where basic control file generated automatically on the fly</li>
<li>native - where existing configuration can be reused.</li>
</ul></li>
<li><p>Understand if it possible to run runscript only once</p></li>
<li><p>Cleanup code</p></li>
<li><p>Export general API that other s-vision subsystems can use</p></li>
</ol>
<p>All comments are welcome</p>]]></summary>
</entry>
<entry>
    <title>My ghci</title>
    <link href="https://qnikst.github.io/posts/2013-09-04-my-ghci.html" />
    <id>https://qnikst.github.io/posts/2013-09-04-my-ghci.html</id>
    <published>2013-09-04T00:00:00Z</published>
    <updated>2013-09-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div style="float:right;width:200px;font-size:0.7em">
<p><strong>Updates:</strong><br />2013-09-05: add link to dotfile</p>
</div>
<p>Here is small collection of my ghci scripts taken from different places. For complete file see my <a href="http://github.com/qnikst/dotfiles/ghc/ghci">dotfiles</a>.</p>
<h2 id="pointfree">Pointfree</h2>
<p>Convert expression into <a href="http://www.haskell.org/haskellwiki/Pointfree">pointfree</a> style. You need to have <a href="http://hackage.haskell.org/package/pointfree">pointree package</a> installed in order to use this function (in case of Gentoo run <code>emerge dev-haskell/pointfree</code>).</p>
<pre><code>-- pointfree
:def pf \str -&gt; return $ &quot;:! pointfree \&quot;&quot; ++ str ++ &quot;\&quot;&quot;</code></pre>
<h2 id="haskell-docs">Haskell-docs</h2>
<p>Show documentation on given function. In order to use it you need to intall <a href="http://hackage.haskell.org/package/haskell-docs">haskell-doc package</a> and built documentation for packages.</p>
<p>In Gentoo case: 1. echo ‘dev-haskell/* docs’ &gt;&gt; /etc/portage/package.use 2. <code>emerge dev-haskell/haskell-docs</code></p>
<pre><code>-- documentation
:def doc \input -&gt; return (&quot;:!haskell-docs &quot; ++ input)</code></pre>
<p>The format is following: <modulename> <name> [<package name>]</p>
<blockquote>
<p>:doc System.IO getContents base The getContents operation returns all user input as a single string, which is read lazily as it is needed (same as hGetContents stdin).</p>
</blockquote>
<h2 id="ghc-vis">GHC-Vis</h2>
<p>A great tool to show how expressions will be presented in memory. You can use it in order to understand your data structure and laziness/strictness of expressions. As usual you need to install <a href="http://hackage.haskell.org/package/ghc-vis">ghc-vis package</a>. Documentation for package (nice pictures included): http://felsin9.de/nnis/ghc-vis/</p>
<pre><code>-- ghc-vis
:script //usr/share/ghc-vis-0.7.1/ghc-7.6.3/ghci</code></pre>
<h2 id="hoogle">Hoogle</h2>
<p>To enable searching with hoogle (either local or global) you can install <a href="http://hackage.haskell.org/package/hoogle">hoogle package</a>.</p>
<pre><code>:def hoogle \str -&gt; return $ &quot;:! hoogle --count=15 \&quot;&quot; ++ str ++ &quot;\&quot;&quot;</code></pre>
<h2 id="prompt">Prompt</h2>
<p>To hide a big list of imported modules and have a nice look’n’feel you can change you ghci prompt.</p>
<pre><code>:set prompt &quot;λ&gt; &quot;</code></pre>
<p>To see list of imported modules you can type: <code>:show imports</code>.</p>]]></summary>
</entry>
<entry>
    <title>Supervision in pure OpenRC using cgroup subsystem.</title>
    <link href="https://qnikst.github.io/posts/2013-08-08-openrc-supervision-using-cgroups.html" />
    <id>https://qnikst.github.io/posts/2013-08-08-openrc-supervision-using-cgroups.html</id>
    <published>2013-08-08T00:00:00Z</published>
    <updated>2013-08-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div style="float:right;width:200px;font-size:0.5em;">
Updates:
<ul>
<pre><code>  &lt;li&gt; 2008.08.09 - small corrections, acknowledgement section added &lt;/li&gt;
&lt;/ul&gt;</code></pre>
Versions:
<ul>
<pre><code>  &lt;li&gt; Kernel &gt;=2.6.24 &amp;&amp; &lt;=3.10 &lt;/li&gt;
  &lt;li&gt; Openrc 0.12 &lt;/li&gt;
&lt;/ul&gt;</code></pre>
</div>
<h1 id="abstract">Abstract</h1>
<p>This post describes how it’s possible to improve cgroup support in OpenRC to support user hooks, and shows how to create a basic supervision daemon based on cgroups.</p>
<p>This post describes OpenRC-0.11/0.12_beta and some things may change in later versions. Please notify me to post updates here if you find such changes.</p>
<h1 id="introduction">Introduction</h1>
<h2 id="the-problem">The problem</h2>
<p>In a general case, there are many services that should be run and restarted when they fail. There are many other subproblems like when should we restart services and when not. Many existing systems can solve those issues but have different trade-offs. In this post I’ll try to present a simple mechanism that allows to create basic supervision and other nice things.</p>
<h2 id="idea">Idea</h2>
<p>The Linux kernel provides a mechanism to track groups of processes - <code>Cgroups</code>. All process children will put in the process’s cgroup. And it’s easy to track cgroups from user space. If you want to understand cgroups better you may read <a href="https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt">cgroups documentation</a>. Cgroups provide a way of setting limits and controlling groups, that is also useful but at this moment it’s out of the scope.</p>
<p>When all processes in a group die, kernel will call ‘release_notify_agent’ script, proving the path to the cgroup. This may be used to remove empty cgroups and take additional actions.</p>
<p>Idea is that we can check service state to decide if we should restart it.</p>
<h1 id="details">Details</h1>
<h2 id="implementation">Implementation</h2>
<p>Here are improvements and files that should be added to OpenRC to provide the required functionality.</p>
<h3 id="restart-daemon">Restart daemon</h3>
<p>First we need to create a daemon to restart a services, because we can’t start service from agent, as it has <code>PF_NO_SETAFFINITY</code> flag and thus cgroups will not work for any of its children. So let’s have a very simple daemon, it will be extended in the next posts</p>
<pre><code> #!/bin/sh
 if [ $# -lt 1 ] ; then
    echo &quot;usage is $0 &lt;path to fifo&gt;&quot; 
    exit 1
 fi
 
 while [ -p $1 ] ; do 
    while read line ; do
       echo &quot;rc-service $line&quot;;
    done &lt;$1
 done</code></pre>
<h3 id="release-notify-agent-improvement">Release notify agent improvement</h3>
<p>The current release notify agent is very simple; so we extend it to support user hooks. There are some different ways to do it:</p>
<ol style="list-style-type: decimal">
<li>Add it to the service state. (Requires hook in the init script)</li>
<li>Create static structure in a filesystem</li>
</ol>
<p>We will use 2. as it’s simpler and doesn’t lead to a init script hacking. We will have following file structure:</p>
<p>In /etc/conf.d/cgroups there will be hooks, ‘cgroup-release’ for default one ‘service-name.cgroup-release’ for service specific one. Here is my example.</p>
<pre><code>/etc/conf.d/cgroups/
|-- cgroup-release                                            # default release hook
|-- foo.cgroup-release -&gt; service-restart.cgroup-release      # service release hook
`-- service-restart.cgroup-release                            # example script
</code></pre>
<p>This approach doesn’t scale on a multiple hooks but it may be improved after discussion with upstream. Each script can return $RC_CGROUP_CONTINUE exit code, so cgroup will not be deleted after a hook.</p>
<p>Here is a script itself (newer version can be found on <a href="https://github.com/qnikst/openrc/blob/cgroups.release_notification/sh/cgroup-release-agent.sh.in">github</a>):</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="va">PATH=</span>/bin:/usr/bin:/sbin:/usr/sbin
<span class="va">cgroup=</span>/sys/fs/cgroup/openrc
<span class="va">cgroup_rmdir=</span>1
<span class="va">RC_SVCNAME=$1</span>
<span class="va">RC_CGROUP_CONTINUE=</span>3; 
<span class="bu">export</span> <span class="va">RC_CGROUP_CONTINUE</span> <span class="va">RC_SVCNAME</span> <span class="va">PATH</span>;

<span class="kw">if</span><span class="bu"> [</span> <span class="ot">-n</span> <span class="st">&quot;</span><span class="va">${RC_SVCNAME}</span><span class="st">&quot;</span><span class="bu"> ]</span> ; <span class="kw">then</span>
  <span class="va">hook=</span>@SYSCONFDIR@/conf.d/cgroups/<span class="va">${RC_SVCNAME}</span>.cgroup-release
  [ <span class="ex">-x</span> <span class="st">&quot;</span><span class="va">$hook</span><span class="st">&quot;</span> ] <span class="kw">||</span> <span class="va">hook=</span>@SYSCONFDIR@/conf.d/cgroups/cgroup-release;
  <span class="kw">if</span><span class="bu"> [</span> <span class="ot">-x</span> <span class="st">&quot;</span><span class="va">$hook</span><span class="st">&quot;</span><span class="bu"> ]</span>; <span class="kw">then</span>
    <span class="st">&quot;</span><span class="va">$hook</span><span class="st">&quot;</span> <span class="ex">cleanup</span> <span class="st">&quot;</span><span class="va">$RC_SVCNAME</span><span class="st">&quot;</span> <span class="kw">||</span> <span class="kw">case</span> <span class="va">$?</span><span class="kw"> in</span> <span class="va">$RC_CGROUP_CONTINUE</span><span class="kw">)</span> <span class="va">cgroup_rmdir=</span>0<span class="kw">;;</span> <span class="kw">esac</span> ;
  <span class="kw">fi</span>
<span class="kw">fi</span>

<span class="kw">if</span><span class="bu"> [</span> <span class="va">${cgroup_rmdir}</span> <span class="ot">-eq</span> 1<span class="bu"> ]</span> <span class="kw">&amp;&amp;</span><span class="bu"> [</span> <span class="ot">-d</span> <span class="st">&quot;</span><span class="va">${cgroup}</span><span class="st">/</span><span class="va">$1</span><span class="st">&quot;</span><span class="bu"> ]</span>; <span class="kw">then</span>
  <span class="kw">for</span> <span class="ex">c</span> in /sys/fs/cgroup/*/<span class="st">&quot;openrc_</span><span class="va">$1</span><span class="st">&quot;</span> <span class="kw">;</span> <span class="kw">do</span>
    <span class="fu">rmdir</span> <span class="st">&quot;</span><span class="va">${c}</span><span class="st">&quot;</span>
  <span class="kw">done</span>;
  <span class="fu">rmdir</span> <span class="st">&quot;</span><span class="va">$cgroup</span><span class="st">/</span><span class="va">${1}</span><span class="st">&quot;</span>
<span class="kw">fi</span></code></pre></div>
<p>Restart service script. This script simply checks service state and if it’s 32 (service failed) then start a new instance and set <code>$RC_CGROUP_CONTINUE</code></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#!/bin/sh</span>
<span class="co"># This script is run for service that need to be restarted</span>
<span class="co"># if it&#39;s last process leaves cgroup.</span>

<span class="va">action=$1</span>
<span class="va">service=$2</span>

<span class="kw">if</span><span class="bu"> [</span> cleanup <span class="ot">=</span> <span class="st">&quot;</span><span class="va">$action</span><span class="st">&quot;</span><span class="bu"> ]</span> ; <span class="kw">then</span>

    <span class="ex">rc-service</span> <span class="va">$service</span> status <span class="op">&gt;</span> /dev/null
    <span class="kw">case</span> <span class="va">$?</span><span class="kw"> in</span>
        32<span class="kw">)</span> 
        <span class="ex">/etc/init.d/</span><span class="va">${service}</span> <span class="ex">-d</span> restart
        <span class="bu">exit</span> <span class="va">$RC_CGROUP_CONTINUE</span>
                <span class="kw">;;</span>
        *<span class="kw">)</span> 
            <span class="bu">return</span> 0<span class="kw">;;</span>
    <span class="kw">esac</span>
<span class="kw">fi</span></code></pre></div>
<h2 id="other-solutions">Other solutions</h2>
<p>Generic supervision is quite a complicated problem as there are many conditions when we may suppose that our service failed, like:</p>
<ul>
<li>main process dies;</li>
<li>all service children die;</li>
<li>service does not write logs for some time;</li>
<li>large resource memory/cpu consuming;</li>
<li>service does not respond to control call;</li>
<li>log fd is closed.</li>
</ul>
<p>Some of the options can be translated to another, like large resource consuming can be translated to process death by setting correct limits. And process death (and in some cases even children deaths) can be tracked by log fd (in case of a process in background).</p>
<p>More complex hooks may be also needed, when deciding what to do with failed service, e.g. do not restart if it has failed many times in a short period of time.</p>
<p>So with all required features will be very complicated. So non-specialized subsystems address only a part of a problem domain. Here are some other examples of supervision systems:</p>
<ul>
<li>monit (full featured)</li>
<li>s6 (pid, fd based)</li>
<li>daemon-tools</li>
<li>angel</li>
<li>systemd (pid, cgroups based)</li>
<li>upstart (pid based)</li>
</ul>
<h1 id="future-work">Future work</h1>
<ol style="list-style-type: decimal">
<li>work on inclusion of a user hooks to OpenRC release agent.</li>
<li>improve restart script to track really dead services that can be restarted</li>
</ol>
<h1 id="conclusions-and-futher-work">Conclusions and futher work</h1>
<p>It’s possible to create a very simple and extensible supervision system based on OpenRC, by extending notification systems. Also there are more usecases for it, like:</p>
<ul>
<li>adding system wide notification mechanism via dbus</li>
<li>additional logging system</li>
</ul>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>I want to thank igli for code corrections and usefull tips, and Kirill Zaborsky for correcting lingual mistakes.</p>]]></summary>
</entry>
<entry>
    <title>Немного о gentoo-haskell</title>
    <link href="https://qnikst.github.io/posts/2013-03-31-gentoo-haskell.html" />
    <id>https://qnikst.github.io/posts/2013-03-31-gentoo-haskell.html</id>
    <published>2013-03-31T00:00:00Z</published>
    <updated>2013-03-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Как всем известно у haskell пакетов существует прекрасная система с сборки с центральным репозиторием, в котором хранятся пакеты, однако у этой проблемы существует ряд минусов:</p>
<ul>
<li>далеко не все пакеты собираются друг с другом даже если эти версии разрешены в cabal файле.</li>
<li>далеко не все пакеты протестированы</li>
<li>часть пакетов нацелены на работу под конкретной платформой и обновлять их до выхода следующей платформы не собираются</li>
<li>при обновлении пакета нужно пересобирать все обратные зависимости</li>
<li>в случае если нужны профилировочные библиотеки, то нужно пересобирать все зависимости с опциями профилировки.</li>
<li>полное отстуствие верификации исходников, которые вы качаете.</li>
</ul>
<p>Все эти пункты делают использование haskell не очень приятным, так же проблема усугубляется тем, что во многих дистрибутивах представлены устаревшие версии пакетов, за которыми не успевают следить (не верите, то можете посмотреть результаты <a href="https://docs.google.com/forms/d/1y5WtrCB7O9-jb-2Mzo1MtkToh4O6oY2oBXGkc_Q-cy0/viewanalytics">haskell survey</a> Обычным решением является использование cabal на пользовательном уровне, или сборка в песочницах. Но иногда бывают способы и лучше.</p>
<p>Естественно, каждый дистрибутив пытается по своему предложить решение проблем. В посте описана краткая инфрастурктура gentoo-linux и дополнительные пакеты сильно упрощающие работу с haskell, в целом пост может быть интересен, как пользователям Gentoo, так интересующимся пользователям других дистрибутивов, даже в том случае если не они не планируют переход или использование Gentoo Linux.</p>
<ol style="list-style-type: decimal">
<li><p>Gentoo работает под многими платформами: (alpha amd64 ia64 ppc ppc64 sparc x86) и под каждую есть поставка ghc и пакетов. Сам пакет ghc можно поставить в бинарном виде, в том случае, если его сборка слишком тяжела для хоста.</p></li>
<li><p>Для исправления зависимостей существует программа haskell-updater, которая находит все “поломанные” зависимости и пересобирает нужные пакеты. Не так давно для улучшения ситуации добавлен механизм подслотов (subslots) специальная форма зависимостей позволяющая указать, то что программа должна быть обновлена в случае обновления зависимости. В текущий момент этот метод не может решить все проблемы (и даже приводит к некоторым новым), то уже в скором времени подслоты будут <a href="https://bugs.gentoo.org/show_bug.cgi?id=449094">рекурсивными</a> и полностью решат проблему автоматического обновления зависимостей</p></li>
<li><p>Большая часть пакетов доступных на Hackage может быть установлена из оверлея gentoo-haskell. Это надет дополнительный слой, в котором можно провести дополнительные исправления, такие как фиксация зависимостей и добавление патчей, плюс с каждым пакетом ассоциирована хэш сумма, которая ползволяет автоматически проверять валидность скачанных исходников.</p></li>
</ol>
<p>В нашем проекте проводятся следующие политики:</p>
<ol style="list-style-type: decimal">
<li>в оверлее держится последняя версия пакета, и она патчится таким образом, чтобы она могла работать с последними версиями других пакетов. Для некоторых пакетов есть исключения по запросам от пользователей или в случае серьезного изменеия апи.</li>
<li>Во всех пакетах проверяется то, что тесты проходятся (если они есть).</li>
<li>сделаны утилиты для простого создания новых пакетов <em>действительно простого</em></li>
</ol>
<p>Таким образом в gentoo можно спокойно использовать haskell на системном уровне используя песочницы только в исключительных ситуациях.</p>
<p>Так же в дистрибутив входят допонительные полезные утилиты такие как hoogle с поддержкой локальной базы (т.е. всех установленных пакетов).</p>
<p>Если кому-то интересны подробности, шаги по быстрой установке или хочется рассказать, как в вашем дистрибутиве решаются подобные проблемы, то добро пожаловать в комментарии.</p>
<p>P.S. и важно, что gentoo можно поставить под любой вашей осью, данных механизм называется gentoo prefix, и подробности можно найти <a href="http://www.gentoo.org/proj/en/gentoo-alt/prefix/">тут</a>.</p>
<p>Полезные ссылки:</p>
<p>[1] Страница на gentoo wiki: <a href="">http://wiki.gentoo.org/wiki/Haskell</a></p>
<p>[2] Тематический блог: <a href="">http://gentoohaskell.wordpress.com/</a></p>
<p>[3] Haskell wiki: <a href="">http://www.haskell.org/haskellwiki/Gentoo</a></p>]]></summary>
</entry>

</feed>
