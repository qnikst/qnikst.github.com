<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - Post tagged haskell</title>
    <link href="http://qnikst.github.com/tags/haskell.xml" rel="self" />
    <link href="http://qnikst.github.com" />
    <id>http://qnikst.github.com/tags/haskell.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2013-09-08T00:00:00Z</updated>
    <entry>
    <title>Basic pathfinding</title>
    <link href="http://qnikst.github.com/posts/2013-09-08-pathfinding.html" />
    <id>http://qnikst.github.com/posts/2013-09-08-pathfinding.html</id>
    <published>2013-09-08T00:00:00Z</published>
    <updated>2013-09-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div style="float:right">
<strong>Updates:</strong><br />2013-09-09: fixes by @qrilka
</div>

<p>In this post I’ll review basic approach to pathfinding using functional approach. It possible that this post doesn’t contain the best approach and all other solutions are welcome.</p>
<div class="row">
<div class="span8">

<p>On the right you can see example of a simple map.</p>
<p>Here is a list of imports. I need it because this is pure lhs file that can be <a href="/posts/2013-09-08-pathfinding.lhs">downloaded</a> and executed in ghci, so you can skip it.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import</span>           Data.List
<span class="ot">&gt;</span> <span class="kw">import</span>           Data.Monoid
<span class="ot">&gt;</span> <span class="kw">import</span>           Data.Map (Map)
<span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.Map <span class="kw">as</span> Map
<span class="ot">&gt;</span> <span class="kw">import</span>           Data.Set (Set)
<span class="ot">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> Data.Set <span class="kw">as</span> Set
<span class="ot">&gt;</span> <span class="kw">import</span>           Data.Function</code></pre>
<p>We will solve simple task of finding the shortest path from one location to another (from 5 to 1). As a first step lets introduce some basic types. Most of them are just type synonyms:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Loc</span>     <span class="fu">=</span> <span class="dt">Int</span>                      <span class="co">-- Location</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Dist</span>    <span class="fu">=</span> <span class="dt">Int</span>                      <span class="co">-- Distance</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">History</span> <span class="fu">=</span> [<span class="dt">Loc</span>]                    <span class="co">-- History</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">LMap</span>    <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">Loc</span> [(<span class="dt">Loc</span>,<span class="dt">Dist</span>)]     <span class="co">-- map</span>
<span class="ot">&gt;</span> <span class="co">-- here is example of the map</span>
<span class="ot">&gt; testMap ::</span> <span class="dt">LMap</span>
<span class="ot">&gt;</span> testMap <span class="fu">=</span> Map.fromList [(<span class="dv">1</span>,[(<span class="dv">2</span>,<span class="dv">5</span>),(<span class="dv">3</span>,<span class="dv">40</span>),(<span class="dv">5</span>,<span class="dv">100</span>)])
<span class="ot">&gt;</span>                        ,(<span class="dv">2</span>,[(<span class="dv">1</span>,<span class="dv">5</span>),(<span class="dv">3</span>,<span class="dv">10</span>),(<span class="dv">4</span>,<span class="dv">30</span>)])
<span class="ot">&gt;</span>                        ,(<span class="dv">3</span>,[(<span class="dv">1</span>,<span class="dv">40</span>),(<span class="dv">2</span>,<span class="dv">10</span>),(<span class="dv">5</span>,<span class="dv">20</span>),(<span class="dv">4</span>,<span class="dv">10</span>)])
<span class="ot">&gt;</span>                        ,(<span class="dv">4</span>,[(<span class="dv">2</span>,<span class="dv">30</span>),(<span class="dv">3</span>,<span class="dv">10</span>),(<span class="dv">5</span>,<span class="dv">5</span>)])
<span class="ot">&gt;</span>                        ,(<span class="dv">5</span>,[(<span class="dv">1</span>,<span class="dv">100</span>),(<span class="dv">3</span>,<span class="dv">20</span>),(<span class="dv">4</span>,<span class="dv">5</span>)])
<span class="ot">&gt;</span>                        ]</code></pre>
<br />
</div><div class="span4">
<img src="/images/posts/pathfinding/1.png" class="img-polaroid"/>
</div></div>

<h2 id="basic-algorithm">Basic algorithm</h2>
<p>The basic idea of our solution is: ‘we need to create a list of the locations that is reachable from initial location sorted by distance’. You can this about this solution like we move in all possible directions at the same time. Then we can filter out final destination and find history related to the correct solution.</p>
<p>Terms: <code>frontier</code> - a list of possible locations with distance from the starting point, sorted by ascending distance.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Frontier0</span> <span class="fu">=</span> [(<span class="dt">Loc</span>, <span class="dt">Dist</span>)]</code></pre>
<p>So algorithm of generating result list will look like:</p>
<ol start="0" style="list-style-type: decimal">
<li>Add starting point with zero distance to the <code>frontier</code>.</li>
<li>Take the first location from the frontier. It will be our next <code>current location</code>.</li>
<li><code>p1</code> &lt;- get list of the locations reachable from the <code>current location</code> in one step.</li>
<li><code>p2</code> &lt;- sum distance to the current distance with the distance from the <code>current location</code> to each possible location from <code>p1</code>. Now we have a list of possible locations with distances from the starting point.</li>
<li>Add list of the new possible locations (<code>p2</code>) to the <code>frontier</code>.</li>
<li>goto 1.</li>
</ol>
<p>This algorithm will create a list of the possible destinations from the current point. The key of the algorithm is that frontier should be sorted by distance, so every time we will take closest position. It will guarantee that our algorithm will not diverge.</p>
<p>As you’ll see the solution will be a direct translation of literal description to the code. And that is a very nice property of haskell.</p>
<p>Here are few images describing process:</p>
<div class="row"><div class="span4">
<img src="/images/posts/pathfinding/2.png" class="img-polaroid"/>
</div><div class="span8">
<p>Here is an image of the current state after step 0.</p>
<p>We added <code>5</code> to the frontier and then take it as a <code>current location</code>.</p>
<p>Now we have 3 new locations reachable: <code>1</code>, <code>3</code> and <code>4</code> (marked with red).</p>
And <code>4</code> with distance 5 will be moved to the result list (dashed). <br />
</div></div>

<div class="row"><div class="span4">
<img src="/images/posts/pathfinding/3.png" class="img-polaroid"/>
</div><div class="span8">
<p>Here is next step.</p>
<p>We took <code>4</code> as a new current element.</p>
<p>We found 2 new reachabe locations: <code>2</code> and <code>3</code>.</p>
<p>We added current distance (5) to distances to the current locations and add them to the frontier.</p>
<code>&lt;&gt;</code> is a function that will merge and sort 2 lists. You can see result of the merge shown with dashed lines. <br />
</div></div>

<h2 id="additional-types.">Additional types.</h2>
<p>Now we can review types that we will use.</p>
<h3 id="candidate">Candidate</h3>
<p>All elements in a resulting set and a frontier are possible canditas for a solution, so they need to contain all temporary information (Distance) and information that we will need when we’ll filter out this solution (History). So we need to introduce a newtype for a candate, we use newtype here because we will need to redefine some properties otherwise we could use a tuple <code>(,,)</code>:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Candidate</span> <span class="fu">=</span> <span class="dt">Candidate</span> (<span class="dt">Loc</span>,<span class="dt">Dist</span>,<span class="dt">History</span>) <span class="kw">deriving</span> <span class="dt">Eq</span>   <span class="co">-- possible solution</span></code></pre>
<p>And helper functions:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; candidateLoc ::</span> <span class="dt">Candidate</span> <span class="ot">-&gt;</span> <span class="dt">Loc</span>
<span class="ot">&gt;</span> candidateLoc (<span class="dt">Candidate</span> (x,_,_)) <span class="fu">=</span> x
<span class="ot">&gt;</span> 
<span class="ot">&gt; candidateHist ::</span> <span class="dt">Candidate</span> <span class="ot">-&gt;</span> <span class="dt">History</span>
<span class="ot">&gt;</span> candidateHist (<span class="dt">Candidate</span> (_,_,x)) <span class="fu">=</span> x</code></pre>
<h3 id="ascending-list">Ascending list</h3>
<p>As we have seen in the algorithm resulting list and frontier are ascending lists. So we may introduce special type that will preserve this property. This will help us to avoid additional mistakes, and can help with undestanding of our solution. This type is isomorphic to the List, however we can’t just use a newtype as we shouldn’t unpack pure list from the AscList:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">AscList</span> a <span class="fu">=</span> (<span class="fu">:&lt;</span>) a (<span class="dt">AscList</span> a) <span class="fu">|</span> <span class="dt">Nil</span></code></pre>
<p>It’s easy to see that AscList forms a monoid with regard to <code>concat</code> operation, so we can use this information:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">AscList</span> a) <span class="kw">where</span>
<span class="ot">&gt;</span>   mempty <span class="fu">=</span> <span class="dt">Nil</span>
<span class="ot">&gt;</span>   mappend <span class="dt">Nil</span> b <span class="fu">=</span> b
<span class="ot">&gt;</span>   mappend a <span class="dt">Nil</span> <span class="fu">=</span> a
<span class="ot">&gt;</span>   mappend a&#39;<span class="fu">@</span>(a <span class="fu">:&lt;</span> as) b&#39;<span class="fu">@</span>(b <span class="fu">:&lt;</span> bs)
<span class="ot">&gt;</span>      <span class="fu">|</span> a <span class="fu">&lt;</span> b <span class="fu">=</span> a <span class="fu">:&lt;</span> (as <span class="fu">&lt;&gt;</span> b&#39;)
<span class="ot">&gt;</span>      <span class="fu">|</span> otherwise <span class="fu">=</span> b <span class="fu">:&lt;</span> (a&#39; <span class="fu">&lt;&gt;</span> bs)</code></pre>
<p>Introduce two helper functions:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- | create ascending list from arbitrary list</span>
<span class="ot">&gt; fromList ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">AscList</span> a
<span class="ot">&gt;</span> fromList <span class="fu">=</span> mconcat <span class="fu">.</span> map singleton 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- | convert value to Ascending List</span>
<span class="ot">&gt; singleton ::</span> a <span class="ot">-&gt;</span> <span class="dt">AscList</span> a
<span class="ot">&gt;</span> singleton x <span class="fu">=</span> x <span class="fu">:&lt;</span> <span class="dt">Nil</span></code></pre>
<p>In order to use Candidates in an AscList we need to introduce ordering on the Candidates:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Candidate</span> <span class="kw">where</span>
<span class="ot">&gt;</span>     compare (<span class="dt">Candidate</span> (_,d1,_)) (<span class="dt">Candidate</span> (_,d2,_)) <span class="fu">=</span> compare d1 d2</code></pre>
<p>Now we can guarantee that lists are properly ordered.</p>
<h3 id="builder-seed.">Builder seed.</h3>
<p>In order to create list we will use <code>unfoldr :: (b -&gt; Maybe (a, b)) -&gt; b -&gt; [a]</code> combinator. On each step we will create one new element and return new seed. So we will need to store frontier in the seed. Additionaly we will use one optimization: we will store a list of visited locations (that exists in result array) and we will filter out locations that we have visited, so we need to store a set of location. So resulting type will look like:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Visited</span> <span class="fu">=</span> <span class="dt">Set</span> <span class="dt">Loc</span>                  <span class="co">-- visited locations</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Seed</span> <span class="fu">=</span> (<span class="dt">AscList</span> <span class="dt">Candidate</span>,<span class="dt">Visited</span>) <span class="co">-- seed of the algorithm</span></code></pre>
<h2 id="solver">Solver</h2>
<p>Now we are ready to introduce our solver:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; solve ::</span> <span class="dt">LMap</span>       <span class="co">-- ^ map</span>
<span class="ot">&gt;</span>       <span class="ot">-&gt;</span> <span class="dt">Loc</span>        <span class="co">-- ^ finish location</span>
<span class="ot">&gt;</span>       <span class="ot">-&gt;</span> <span class="dt">Loc</span>        <span class="co">-- ^ start location</span>
<span class="ot">&gt;</span>       <span class="ot">-&gt;</span> <span class="dt">History</span>
<span class="ot">&gt;</span> solve mp finish <span class="fu">=</span> reverse
<span class="ot">&gt;</span>                 <span class="fu">.</span> (finish<span class="fu">:</span>)     <span class="co">-- we need to add finish place to the list</span>
<span class="ot">&gt;</span>                 <span class="fu">.</span> candidateHist <span class="co">-- we are interested in history only</span>
<span class="ot">&gt;</span>                 <span class="fu">.</span> head          <span class="co">-- we need only first solution</span>
<span class="ot">&gt;</span>                 <span class="fu">.</span> filter ((<span class="fu">==</span>finish) <span class="fu">.</span> candidateLoc)  <span class="co">-- take last result</span>
<span class="ot">&gt;</span>                 <span class="fu">.</span> unfoldr go    <span class="co">-- generate list of candidates using frontier</span>
<span class="ot">&gt;</span>                 <span class="fu">.</span> initial       <span class="co">-- initialize frontier using starting point</span>
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;</span>     initial i <span class="fu">=</span> (singleton <span class="fu">$</span> <span class="dt">Candidate</span> (i,<span class="dv">0</span>,[]),Set.empty)</code></pre>
<p>In go we need to guarantee that current seed in greater (using Candidate’s ordering) that any other element in list. We can guarantee it because:</p>
<ol start="0" style="list-style-type: decimal">
<li>when we have no elements in list we use first candidate with zero distance</li>
<li>all elements in frontier has length &gt; than current location. because we use AscList.</li>
<li>all possible locations from current location &gt; than current location as their distance is (current location distance + x, where x ≥ 0).</li>
</ol>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;     go ::</span> <span class="dt">Seed</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Candidate</span>,<span class="dt">Seed</span>)
<span class="ot">&gt;</span>     go (<span class="dt">Nil</span>,_) <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span>     go ((<span class="dt">Candidate</span> (x,d,h) <span class="fu">:&lt;</span> xs),visited) <span class="fu">=</span>
<span class="ot">&gt;</span>        <span class="kw">case</span> Map.lookup x mp <span class="kw">of</span>  <span class="co">-- read possible locations from map</span>
<span class="ot">&gt;</span>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> go (xs,visited)       <span class="co">-- if thre is no destinaction proceed with next element</span>
<span class="ot">&gt;</span>          <span class="dt">Just</span> ls <span class="ot">-&gt;</span> <span class="kw">let</span> ls&#39;   <span class="fu">=</span> fromList  <span class="co">-- generate AscList from current position</span>
<span class="ot">&gt;</span>                               <span class="fu">.</span> map (\(yl,yd) <span class="ot">-&gt;</span> <span class="dt">Candidate</span> (yl,yd<span class="fu">+</span>d,x<span class="fu">:</span>h))  <span class="co">-- increment distance (see 2.)</span>
<span class="ot">&gt;</span>                               <span class="fu">.</span> filter ((<span class="ot">`Set.notMember`</span> visited) <span class="fu">.</span> fst) <span class="fu">$</span> ls <span class="co">-- remove elements that we have visited</span>
<span class="ot">&gt;</span>                     <span class="kw">in</span> <span class="dt">Just</span> ( <span class="dt">Candidate</span> (x,d,h)
<span class="ot">&gt;</span>                               , (ls&#39; <span class="fu">&lt;&gt;</span> xs, Set.insert x visited))</code></pre>
<p>Yachoo! we have a solver. However it will work badly on the big maps and we need to use more advanced methods, like A<up>*</up>. But we need to fix Candidate ordering function.</p>
<p>I’ve heard that it is possible to use comonad approach to solve this problem however I couldn’t find any example of this approach.</p>]]></summary>
</entry>
<entry>
    <title>Сериализация структур данных в Haskell.<br/> Часть 1: типы данных</title>
    <link href="http://qnikst.github.com/posts/2013-09-06-serialization-p1.html" />
    <id>http://qnikst.github.com/posts/2013-09-06-serialization-p1.html</id>
    <published>2013-09-06T00:00:00Z</published>
    <updated>2013-09-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div style="float:right; width:200px">
<strong>Updates:</strong><br /> 2013-09-06: исправлены ошибки в тексте (спасибо qrilka)
</div>

<p><em>У меня тут в черновиках завалялась старый пост про сериализацию стуктур данных в haskell, доводить её до ума и продолжать мне немного лень, но если будет интересно то могу продолжать. Изначально серия статей предполагалась одновременно с доведением до ума пакета <a href="https://github.com/qnikst/strictput">strictput</a></em></p>
<p>Этим постом я хочу начать небольшую серию статей про сериализацию данных в Haskell. и описание библиотек их реализующих.</p>
<h1 id="типы-данных">Типы данных</h1>
<p>Перед тем как рассматривать непосредственно существующие системы сериализации и сопутсвующие им алгоритмы нужно рассмотреть типы данных, в которые можно сериализовать стуктуры. Это позволит упростить описание самой сериализации, а так же улучшит понимание низкого уровня задачи.</p>
<p>Сама задача сериализации может возникать в двух случаях:</p>
<ol style="list-style-type: decimal">
<li>Взаимодействие с внешним рантаймом, например FFI;</li>
<li>Взаимодействие с внешним миром (IPC, передача в сеть и т.д.)</li>
</ol>
<p>Разница между этими задачами заключается в том, что в первом случае, данные находятся в пространстве одного процесса (группы процессов), а во втором — в разных, и там будет произведено их копирование (существуют варианты, при которых копирование произведено не будет, но их мы оставим в стороне). В связи с этим структуры данных для варинта 1 не должны быть перемещены GC при сборке мусора, поскольку сериализация главным образом интересна нам для второго сценария, то мы не будем посвящать много времени рассмотрению непереносимых (pinned) структур, а будем только отмечать данное свойство.</p>
<h2 id="c-интерфейс">‘C’ интерфейс</h2>
<p>При взаимодействии с файлами или сетью для передачи бинарных данных в C принятно использовать пару “указатель, размер данных”, которая описывает откуда брать данные и сколько. Существуют более интересные варианты для векторной записи (семейство функций read/writev), в этом случае используется массив структур:</p>
<p>struct iovec { void *iov_base; size_t iov_len; }</p>
<p>в некоторых типах данных можно использовать данный подход, что позволит повысить их производительность, но об этом будет сказано отдельно.</p>
<p>Данный интерфейс может быть изображен в haskell как (# Addr#,CSize #) но крайне не рекомендуется так делать, поскольку это сильно усложнит работу с данными, при этом не принося выгоды, поскольку во многих случаях компилятор может преобразовать структуру к виду аналогичному данному.</p>
<p>Для данных, которые являются строковыми в C часто ещё использются null-terminated строки</p>
<h3 id="типы-haskell-соотвествующие-c-интерфейсу">Типы haskell соотвествующие C интерфейсу</h3>
<p>В haskell существуют следующие типы соответсующие указателям в C:</p>
<h4 id="addr">Addr#</h4>
<p>Addr# - unlifted unpacked тип данных являющийся указателем. Стоит напомнить, что данный тип является строгим по построению. С помощью данного типа можно обращаться напрямую к данным внутри примитивных частей программы. Функции для работы с этим типом есть в GHC.Prim (пакет ghc-prim) и Control.Primitive (пакет primitive). Обычно использовние Addr# не нужно, поскольку компилятор умеет приводить приводить работу к данному типу (за это отвечает анализатор строгости).</p>
<h4 id="ptr">Ptr</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Ptr</span> a <span class="fu">=</span> <span class="dt">Ptr</span> (<span class="dt">Addr</span><span class="fu">#</span>)</code></pre>
<p>Типизированная обертка над Addr (lifted, unpacked по умолчанию (изменится в ghc 7.8)), с помощью данного типа данных можно работать с указателями в “обычном” haskell коде. В подавляющем большинстве случаев ленивость и boxing убираются компилятором. Данный тип не “держит” содержимое на которое указывает и не защищает его от сборки GC.</p>
<p>Функции для работы с указателями предоставляются модулем ‘Foreign.Ptr’</p>
<h4 id="foreignptr">ForeignPtr</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ForeignPtr</span> <span class="fu">=</span> <span class="dt">ForeignPtr</span> <span class="dt">Addr</span><span class="fu">#</span> <span class="dt">ForeignPtrConents</span></code></pre>
<p>Указатель, к которому можно привязывать финализаторы: действие которое должно быть выполнено как только не осталось ссылок на ForeignPtr из кода.</p>
<h2 id="общее-описание-структур-данных">Общее описание структур данных</h2>
<h3 id="cstringcstring-len">CString/CString Len</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">type</span> <span class="dt">CString</span> <span class="fu">=</span> <span class="dt">Ptr</span> <span class="dt">CChar</span> <span class="co">-- Defined in `Foreign.C.String`</span>
    <span class="kw">type</span> <span class="dt">CStringLen</span> <span class="fu">=</span> (<span class="dt">Ptr</span> <span class="dt">CChar</span>, <span class="dt">Int</span>) <span class="co">-- Defined in `Foreign.C.String`</span></code></pre>
<p>Тип данных соответсвующий null-terminated и length строкам соответсвенно, обычно используется для взаимодействия с C кодом, поскольку данный тип строк является pinned. Данный тип может быть эффективно использован для низкоуровнего взаимодействия с C кодом. Стоит отметить, что существует модификация CString (ACString) в которой выделение происходит на стеке, а не в куче.</p>
<p>Характеристики:</p>
<ul>
<li>строгий</li>
<li>небезопасный</li>
<li>не предоставляет возможности работы с данными</li>
</ul>
<p>Операции над типом:</p>
<ul>
<li>библиотеки haskell не предоставляют операций над данным типом данных</li>
</ul>
<h3 id="string">String</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">type</span> <span class="dt">String</span> <span class="fu">=</span> [<span class="dt">Char</span>]</code></pre>
<p>Очень широко используемый тип данных для внутреннего представления текcтовых строк в виде потока (Stream/Lazy-Cons-List). Данный тип предоставляется базовой библиотекой Prelude и поэтому весьма часто используется не по назначению. Поскольку структура данных является ленивой, то возможно создание бесконечных и цикличеких списков, а так же итеративное построение списка.</p>
<p>Характеристики:</p>
<ul>
<li>ленивый</li>
<li>безопасный</li>
<li>простой в использовании</li>
<li>можно использовать pattern matching без дополнительных расширений</li>
<li>очень низкая локальность данных (не кэш локальный)</li>
<li>высокий overhead по памяти для хранения списка (x+8+2)*n+8</li>
<li>очень низкая скорость работы</li>
<li>внутренний (не pinned тип)</li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.646">build/foldr deforestation</a></li>
<li>IO библиотека существует, но все методы являются ленивыми, что подвергается жесткой критике, рекомендуется использовать не ленивый ввод-вывод, а итеративные библиотеки такие как pipes, conduit, или iteratee.</li>
</ul>
<p>Build/forldr deforestation позволяет не создавать списки в том случае, если это без этого можно обойтись, например, в случаях, если списки играют роль “клея” между операциями,.</p>
<p>Операции над структурой данных:</p>
<ul>
<li>size: O(N) /N прыжков по памяти/ const по памяти</li>
<li>a <code>append</code> b: O(size a), O(size a) выделяется строка O(size a), ‘a’ может быть освобождена.</li>
<li>a +: b -&gt; O(1),</li>
<li>a :+ b -&gt; O(size a)</li>
</ul>
<p>Все операции изменяющие структуру данных пересоздают структуру слева от списка.</p>
<h3 id="word8">[Word8]</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">data</span> [] a <span class="fu">=</span> [] <span class="fu">|</span> a <span class="fu">:</span> [a]</code></pre>
<p>Аналог String для бинарных типов данных, к данному типу применяемы все пункты относящиеся к String, кроме того, что нету возможностей работы с вводом выводом.</p>
<h3 id="text">Text</h3>
<p>Современный внутренний тип для предствления строковых данных. Однако рассмотрение данного типа выходит за рамки поста.</p>
<h3 id="bytestring">ByteString</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">data</span> <span class="dt">ByteString</span> <span class="fu">=</span> <span class="dt">PS</span> 
          <span class="ot">{-# UNPACK #-}</span> (<span class="dt">ForeignPtr</span> <span class="dt">Word8</span>) 
          <span class="ot">{-# UNPACK #-}</span> <span class="dt">Int</span> 
          <span class="ot">{-# UNPACK #-}</span> <span class="dt">Int</span></code></pre>
<p>Данная структура обощает представление данных CStringLen добавляя в него параметр offset, что позволяет сильно расширить круг операций, которые доступны и безопасны. Для данного типа вся работа с памятью скрыта и пользовател предоставляется чистый и безопасный интерфейс для работы.</p>
<p>Размер структуры ~16байт+выделенная память, она является полностью строгой.</p>
<p>Данный тип работает с pinned memory посредством libc вызовов и предоставляет быстрый интерфейс для работы с бинарными данными. Операции не требующие изменения самих данных (take,drop) создают новый заголовок O(1), 8 Byte располагающийся в памяти RTS (relocable). Операции требующие изменения данных создают новую строку. Данная структура данных не поддерживает deforestation, но является самой эффективной структурой данных для хранения строк, которые должны быть прочитаны и не изменяются.</p>
<p>То, что каждый из блоков данных содержит указатель на начало выделенной памяти позволяет обходиться без дополнительного копирования структуры удаляя её в том случае, если на неё никто не ссылается.</p>
<h3 id="lazy-bytestring">Lazy ByteString</h3>
<p>data ByteString = Empty | Chunk !Internal.ByteString ByteString</p>
<p>Как можно увидеть данная структура изоморфна списку байтстрок, однако есть существенное отличие: внутри каждого чанка существует не произвольная строка, а строка определенного размера. (64k)</p>
<h2 id="перевод-типов-данных-друг-в-друга">Перевод типов данных друг в друга</h2>
<p>Для того, чтобы показать как перечисленные типы данных переходят друг в друга, в конце поста я привел абсолютно невоспринимаемую картинку (кто хочет може предложить мне более адекватный вариант).</p>
<p>При переводе типов из одного в другой нужно следить за следующими вещами:</p>
<ol style="list-style-type: decimal">
<li>алгоритмическая сложность операции;</li>
<li>размер выделяемых структур данных;</li>
<li>энергичность/ленивость операции;</li>
<li>безопасность операции.</li>
</ol>
<p>С первым пунктом все важно, второй тоже важен, так как агрессивное использование памяти существенно может изменить поведение программы относительно ожидаемого. То же относится и к ленивости, в этом случае нужно понимать, какие плюсы идут от ленивости, и не может ли произойти каскадное “форсирование” вычислений в тот момент, когда этого допускать нельзя.</p>
<p>С безопасностью операций дело обстоит интереснее, в том случае если мы передаем выделенную память вне рантайма Haskell, мы не можем гарантировать чистоту данной структуры, так как внешнее окружениме может изменять память как хочет. Обычно для сохранения чистоты в рантайм передается не сама структура, а её копия ‘useAs*’. В этом случае нужно понимать, что данный подход приводит к увеличению сложности алгоритма и дополнительной нагрузке на память.</p>
<p>Картинка кликабельна: <a href="/images/posts/parser-1/1.png" target="_blank"><img src="/images/posts/parser-1/1.png"/></a></p>]]></summary>
</entry>
<entry>
    <title>My ghci</title>
    <link href="http://qnikst.github.com/posts/2013-09-04-my-ghci.html" />
    <id>http://qnikst.github.com/posts/2013-09-04-my-ghci.html</id>
    <published>2013-09-04T00:00:00Z</published>
    <updated>2013-09-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div style="float:right;width:200px;font-size:0.7em">
<strong>Updates:</strong><br />2013-09-05: add link to dotfile
</div>

<p>Here is small collection of my ghci scripts taken from different places. For complete file see my <a href="http://github.com/qnikst/dotfiles/ghc/ghci">dotfiles</a>.</p>
<h2 id="pointfree">Pointfree</h2>
<p>Convert expression into <a href="http://www.haskell.org/haskellwiki/Pointfree">pointfree</a> style. You need to have <a href="http://hackage.haskell.org/package/pointfree">pointree package</a> installed in order to use this function (in case of Gentoo run <code>emerge dev-haskell/pointfree</code>).</p>
<pre><code>-- pointfree
:def pf \str -&gt; return $ &quot;:! pointfree \&quot;&quot; ++ str ++ &quot;\&quot;&quot;</code></pre>
<h2 id="haskell-docs">Haskell-docs</h2>
<p>Show documentation on given function. In order to use it you need to intall <a href="http://hackage.haskell.org/package/haskell-docs">haskell-doc package</a> and built documentation for packages.</p>
<p>In Gentoo case: 1. echo ‘dev-haskell/* docs’ &gt;&gt; /etc/portage/package.use 2. <code>emerge dev-haskell/haskell-docs</code></p>
<pre><code>-- documentation
:def doc \input -&gt; return (&quot;:!haskell-docs &quot; ++ input)</code></pre>
<p>The format is following: <modulename> <name> [<package name>]</p>
<blockquote>
<p>:doc System.IO getContents base The getContents operation returns all user input as a single string, which is read lazily as it is needed (same as hGetContents stdin).</p>
</blockquote>
<h2 id="ghc-vis">GHC-Vis</h2>
<p>A great tool to show how expressions will be presented in memory. You can use it in order to understand your data structure and laziness/strictness of expressions. As usual you need to install <a href="http://hackage.haskell.org/package/ghc-vis">ghc-vis package</a>. Documentation for package (nice pictures included): http://felsin9.de/nnis/ghc-vis/</p>
<pre><code>-- ghc-vis
:script //usr/share/ghc-vis-0.7.1/ghc-7.6.3/ghci</code></pre>
<h2 id="hoogle">Hoogle</h2>
<p>To enable searching with hoogle (either local or global) you can install <a href="http://hackage.haskell.org/package/hoogle">hoogle package</a>.</p>
<pre><code>:def hoogle \str -&gt; return $ &quot;:! hoogle --count=15 \&quot;&quot; ++ str ++ &quot;\&quot;&quot;</code></pre>
<h2 id="prompt">Prompt</h2>
<p>To hide a big list of imported modules and have a nice look’n’feel you can change you ghci prompt.</p>
<pre><code>:set prompt &quot;λ&gt; &quot;</code></pre>
<p>To see list of imported modules you can type: <code>:show imports</code>.</p>]]></summary>
</entry>
<entry>
    <title>Adding license notes to blog pages.</title>
    <link href="http://qnikst.github.com/posts/2013-08-23-licenses-notes-in-hakyll.html" />
    <id>http://qnikst.github.com/posts/2013-08-23-licenses-notes-in-hakyll.html</id>
    <published>2013-08-23T00:00:00Z</published>
    <updated>2013-08-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’ve finally manged to create configurable license notes for each article:</p>
<p>To do it you need to add additional context:</p>
<pre><code>licenseCtx :: Context a
licenseCtx = field &quot;license&quot; $ \item -&gt; do
    metadata &lt;- getMetadata $ itemIdentifier item
    return $ case M.lookup &quot;license&quot; metadata of
                    Nothing -&gt; &quot;&quot;
                    Just m -&gt; case M.lookup (trim m) licenses of
                                      Nothing -&gt; &quot;unknown license&quot;
                                      Just (u,i) -&gt; &quot;&lt;a href=\&quot;&quot;++u++&quot;\&quot;&gt;&lt;img src=\&quot;&quot;++i++&quot;\&quot;/&gt;&lt;/a&gt;&quot;
  where
    trim = reverse . dropWhile isSpace . reverse . dropWhile isSpace


licenses = m.fromlist 
    [ (&quot;by&quot;,       ( &quot;http://creativecommons.org/licenses/by/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by/3.0/88x31.png&quot;))
    , (&quot;by-sa&quot;,    ( &quot;http://creativecommons.org/licenses/by-sa/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by-sa/3.0/88x31.png&quot;))
    , (&quot;by-nd&quot;,    ( &quot;http://creativecommons.org/licenses/by/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by/3.0/88x31.png&quot;))
    , (&quot;by-nc&quot;,    ( &quot;http://creativecommons.org/licenses/by/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by/3.0/88x31.png&quot;))
    , (&quot;by-nc-sa&quot;, ( &quot;http://creativecommons.org/licenses/by-nc-sa/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png&quot;))
    , (&quot;by-nc-nd&quot;, ( &quot;http://creativecommons.org/licenses/by-nc-nd/3.0&quot;
                   , &quot;http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png&quot;))]</code></pre>
<p>Currently only cc-* licenses are added, and but it will be possible to add another.</p>
<p>To apply license to template just add <code>$license$</code> and add context:</p>
<pre><code>  loadAndApplyTemplate &quot;templates/post.html&quot; (licenseCtx &lt;&gt; postCtx tags)</code></pre>
<p>For my blog I’m trying to use:</p>
<ul>
<li>by - for announces and physics</li>
<li>by-nc-sa - for documentation like posts</li>
<li>by-nc-nd - for personal posts</li>
</ul>]]></summary>
</entry>
<entry>
    <title>Using queues in conduits</title>
    <link href="http://qnikst.github.com/posts/2013-04-11-using-tqueues-in-conduit.html" />
    <id>http://qnikst.github.com/posts/2013-04-11-using-tqueues-in-conduit.html</id>
    <published>2013-04-11T00:00:00Z</published>
    <updated>2013-04-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Sometime when you use conduit you need to split processes for example when you have CPU bound and IO bound tasks thus you will have better workload. Also you may need to get events from different sources concurrently, and for such purposes you may want to use <a href="http://hackage.haskell.org/package/stm-conduit">stm-conduit</a> library.</p>
<p>This library provides conduits over STM primitives:</p>
<ul>
<li><a href="http://hackage.haskell.org/packages/archive/stm-chans/1.3.1/doc/html/Control-Concurrent-STM-TMChan.html#t:TMChan">TMChans</a> - closable (finite) STM channels</li>
<li><a href="http://hackage.haskell.org/packages/archive/stm-chans/1.3.1/doc/html/Control-Concurrent-STM-TBMChan.html#t:TBMChan">TBMChans</a> - closable (finite) bounded STM channels</li>
<li><a href="http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/Control-Concurrent-STM-TQueue.html#t:TQueue">TQueue</a> - infinite STM Queues</li>
<li><a href="http://hackage.haskell.org/packages/archive/stm/2.4.2/doc/html/Control-Concurrent-STM-TBQueue.html#t:TBQueue">TBQueue</a> - infinite bounded STM Queues</li>
</ul>
<p>and closable queues comming soon.</p>
<p>Here closable means that you can close a primitives outside it, so source will report that it is closed on the opposite infinite primitive will wait for an input forever, so you should use another conduit to handle end of a stream or send an asynchronous exception.</p>
<p>Bounded means that there is a limit of pending messages inside primitive and if that limit is reached any thread that wants to write to the primitive will be blocked on input. This is basically what you need to guarantee limited (or even constant) memory usage.</p>
<p>New primitive TQueue was added in stm-2.3 and provides shared amortized queue that is faster than TChan/Chan but doesn’t provide dupTChan, cloneTChan primitives.</p>]]></summary>
</entry>
<entry>
    <title>Anouncing binary conduit</title>
    <link href="http://qnikst.github.com/posts/2013-04-07-announcing-binary-conduit.html" />
    <id>http://qnikst.github.com/posts/2013-04-07-announcing-binary-conduit.html</id>
    <published>2013-04-07T00:00:00Z</published>
    <updated>2013-04-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m happy to announce <a href="http://hackage.haskell.org/package/binary-conduit">binary-conduit</a> an library for <a href="http://hackage.haskell.org/package/conduit">conduit</a> streaming data library using <a href="http://hackage.haskell.org/package/binary">binary</a> package.</p>]]></summary>
</entry>
<entry>
    <title>Немного о gentoo-haskell</title>
    <link href="http://qnikst.github.com/posts/2013-03-31-gentoo-haskell.html" />
    <id>http://qnikst.github.com/posts/2013-03-31-gentoo-haskell.html</id>
    <published>2013-03-31T00:00:00Z</published>
    <updated>2013-03-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Как всем известно у haskell пакетов существует прекрасная система с сборки с центральным репозиторием, в котором хранятся пакеты, однако у этой проблемы существует ряд минусов:</p>
<ul>
<li>далеко не все пакеты собираются друг с другом даже если эти версии разрешены в cabal файле.</li>
<li>далеко не все пакеты протестированы</li>
<li>часть пакетов нацелены на работу под конкретной платформой и обновлять их до выхода следующей платформы не собираются</li>
<li>при обновлении пакета нужно пересобирать все обратные зависимости</li>
<li>в случае если нужны профилировочные библиотеки, то нужно пересобирать все зависимости с опциями профилировки.</li>
<li>полное отстуствие верификации исходников, которые вы качаете.</li>
</ul>
<p>Все эти пункты делают использование haskell не очень приятным, так же проблема усугубляется тем, что во многих дистрибутивах представлены устаревшие версии пакетов, за которыми не успевают следить (не верите, то можете посмотреть результаты <a href="https://docs.google.com/forms/d/1y5WtrCB7O9-jb-2Mzo1MtkToh4O6oY2oBXGkc_Q-cy0/viewanalytics">haskell survey</a> Обычным решением является использование cabal на пользовательном уровне, или сборка в песочницах. Но иногда бывают способы и лучше.</p>
<p>Естественно, каждый дистрибутив пытается по своему предложить решение проблем. В посте описана краткая инфрастурктура gentoo-linux и дополнительные пакеты сильно упрощающие работу с haskell, в целом пост может быть интересен, как пользователям Gentoo, так интересующимся пользователям других дистрибутивов, даже в том случае если не они не планируют переход или использование Gentoo Linux.</p>
<ol style="list-style-type: decimal">
<li><p>Gentoo работает под многими платформами: (alpha amd64 ia64 ppc ppc64 sparc x86) и под каждую есть поставка ghc и пакетов. Сам пакет ghc можно поставить в бинарном виде, в том случае, если его сборка слишком тяжела для хоста.</p></li>
<li><p>Для исправления зависимостей существует программа haskell-updater, которая находит все “поломанные” зависимости и пересобирает нужные пакеты. Не так давно для улучшения ситуации добавлен механизм подслотов (subslots) специальная форма зависимостей позволяющая указать, то что программа должна быть обновлена в случае обновления зависимости. В текущий момент этот метод не может решить все проблемы (и даже приводит к некоторым новым), то уже в скором времени подслоты будут <a href="https://bugs.gentoo.org/show_bug.cgi?id=449094">рекурсивными</a> и полностью решат проблему автоматического обновления зависимостей</p></li>
<li><p>Большая часть пакетов доступных на Hackage может быть установлена из оверлея gentoo-haskell. Это надет дополнительный слой, в котором можно провести дополнительные исправления, такие как фиксация зависимостей и добавление патчей, плюс с каждым пакетом ассоциирована хэш сумма, которая ползволяет автоматически проверять валидность скачанных исходников.</p></li>
</ol>
<p>В нашем проекте проводятся следующие политики:</p>
<ol style="list-style-type: decimal">
<li>в оверлее держится последняя версия пакета, и она патчится таким образом, чтобы она могла работать с последними версиями других пакетов. Для некоторых пакетов есть исключения по запросам от пользователей или в случае серьезного изменеия апи.</li>
<li>Во всех пакетах проверяется то, что тесты проходятся (если они есть).</li>
<li>сделаны утилиты для простого создания новых пакетов <em>действительно простого</em></li>
</ol>
<p>Таким образом в gentoo можно спокойно использовать haskell на системном уровне используя песочницы только в исключительных ситуациях.</p>
<p>Так же в дистрибутив входят допонительные полезные утилиты такие как hoogle с поддержкой локальной базы (т.е. всех установленных пакетов).</p>
<p>Если кому-то интересны подробности, шаги по быстрой установке или хочется рассказать, как в вашем дистрибутиве решаются подобные проблемы, то добро пожаловать в комментарии.</p>
<p>P.S. и важно, что gentoo можно поставить под любой вашей осью, данных механизм называется gentoo prefix, и подробности можно найти <a href="http://www.gentoo.org/proj/en/gentoo-alt/prefix/">тут</a>.</p>
<p>Полезные ссылки:</p>
<p>[1] Страница на gentoo wiki: <a href="">http://wiki.gentoo.org/wiki/Haskell</a></p>
<p>[2] Тематический блог: <a href="">http://gentoohaskell.wordpress.com/</a></p>
<p>[3] Haskell wiki: <a href="">http://www.haskell.org/haskellwiki/Gentoo</a></p>]]></summary>
</entry>
<entry>
    <title>Resourcet usage</title>
    <link href="http://qnikst.github.com/posts/2013-02-28-resourcet-usage.html" />
    <id>http://qnikst.github.com/posts/2013-02-28-resourcet-usage.html</id>
    <published>2013-02-28T00:00:00Z</published>
    <updated>2013-02-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post describes an interesting resourcet usecase that may be usefull due to the lack of liner-types support in haskell.</p>
<p>Lets look at the next problem. Assuming we have got a some sort of transaction mechanism that receives data and then perform transaction, but sometimes it may call callback to users code (originally it’s about <a href="http://github.com/qnikst/2pc">2pc</a> library).</p>
<p>So we have method:</p>
<pre><code>withWH0 :: (Binary b) -&gt; ByteString -&gt; (b -&gt; IO Bool) -&gt; IO ()
withWH0 = undefined</code></pre>
<p>Where Bool is result of transaction i.e. either we accept or decline transaction.</p>
<p>This variant is not good as callback is synchronous, we will not be able to run next transaction untill callback is finished. And it will be a bottleneck for the code.</p>
<p>There can be an interesting solution:</p>
<blockquote>
<p>one can provide an trasaction handler, i.e. a resource that for communication of the user code and library, this resource should be either accepted or declined. If that resource is ‘alive’ it means that user is working on transaction. If resource is not touched by user code a default action should be run, before resource will be cleared.</p>
</blockquote>
<p>The problem that we should somehow guarantee that user will free resource. One solution use linear types, but we don’t have them (or at least it’s too difficult for me and I don’t know how to do it). Another option is to use some kind of region library: one option is <a href="http://hackage.haskell.org/package/regions">regions</a> originaly proposed by <a href="http://okmij.org/ftp/Haskell/regions.html#light-weight">Oleg</a> but this package doesn’t work in recent ghc`s due some unsolved bugs, another option is <a href="http://hackage.haskell.org/package/resourcet">resourcet</a> package written by Michael Snoyman, this package doesn’t give so much guarantees as regions but at least it works. Resourcet package introduce ResourceT monad that forms a block where all resources that were registered in that blog will be closed as soon as compulation would left a block (there is an api for an early close but will not look at it now).</p>
<p>So we can guarantee that:</p>
<ol style="list-style-type: decimal">
<li>every resource registered in the block will be freed</li>
<li>resources freeing will be determinated in time/</li>
<li>resource will be freed only once (second call to release is noop)</li>
</ol>
<p>Here are minimal definition for what we need:</p>
<pre><code>data TH = TH -- ^ transaction handler

-- | accept transaction (send message via network)
accept = undefined  
-- | decline transaction (send message via network)
decline = undefined
-- | real release (synonym for decline)
thRelease = undefined

withWH1 d cb = runResourceT $ do
  let d&#39; = decode d
  th &lt;- accure create thRelease
  cb th d&#39;</code></pre>
<p>Now we create a ResourceT region, register resource there and then call user code, our code is not as safe as resourcet release as user can call accept more that once, so we need to check if it was called.</p>
<p>The best thing that now client can use <code>resourceForkIO</code> to make withWH1 asynchronous.</p>
<p>But there is another issue: how user can queue some part of the messages?</p>
<p>TBD make nice picture</p>
<p>There is a solution: <code>unprotect</code> function. This function allowes you to degerister resource in the current resourcet block and then register it in another block, or register new release action.</p>
<p>Currently resourcet package lacks helpers that allowes to move resource to some other place, so one need to create that functions himself. Here are some advices how one can do it safely.</p>
<p>You need a structure that has the following interface:</p>
<ul>
<li>put :: s -&gt; (a, IO ()) -&gt; m () – put resource into storage</li>
<li>get :: s -&gt; m (ReleaseKey a) – get resource and register it in current process</li>
</ul>
<p>Put and get should be atomic and mask exceptions, moreover if you can’t guarantee that message will be immidiatelly read by another process you should register datastructure in some higher level ResourceT block, this way you’ll guarantee that no resources will be left in store unfreed.</p>
<p>Here are some basic examples of such datastructures:</p>
<p>(this code is not well tested as I’ve used more complicated datastructure for such purpose, that have an additional API, but its not usefull for common case)</p>
<p>At first let’s write an <code>InstantMVar</code>, this structure allow you to send message into other process, where it will be immideatelly read, so we don’t need to store that structure in ‘global’ resource block</p>
<pre><code>data InstanceMVar a = InstanceMVar (MVar (a,IO ())) (MVar ())

newMVar = InstanceMVar &lt;$&gt; newEmptyMVar &lt;*&gt; newEmptyMVar

put (InstanceMVar a b) (key, x) = mask_ $ unprotect key &gt;&gt;= putMVar a . ((,) x) &gt;&gt; takeMVar b

get (InstanceMVar a b) = mask_ $ takeMVar a &gt;&gt;= \(x, r) -&gt; register r &gt;&gt; putMVar b () &gt;&gt; return x</code></pre>
<p>This code will guarantee that resource will be read, however it may lock.</p>
<p>Let’s write a <code>DelayedMVar</code> this structure will not block on write, but should be registered in global resourcet block</p>
<pre><code>newtype DelayedMVar a = DelayedMVar (MVar (a,IO ()))

newDelayedMVar = allocate (DelayedMVar &lt;$&gt; newEmptyMVar) (releaseDelayedMVar)

releaseDelayedMVar (DelayedMVar v) = maybe (return ()) (snd) =&lt;&lt; tryReadMVar v

put (DelayedMVar v) (key, x) = mask_ $ unprotect key &gt;&gt;= putMVar a . ((,) x)

get (DelayedMVar v) = mask_ $ takeMVar a &gt;&gt;= \(x, r) -&gt; register r &gt;&gt; return x</code></pre>
<p>Same way one can write Channel or STM Channel, however channel is not fully safe unless chan is closable.</p>
<pre><code>newtype SChan a = SChan (SChan (a,IO ()))

newSChan = allocate (SChan &lt;$&gt; newChan) releaseChan

releaseChan (ChanMVar v) = go =&lt;&lt; tryReadChan v
  where go Nothing = return ()
        go (Just (x,a)) = a &gt;&gt; tryReadChan v {- we have a possible race condition here -} &gt;&gt;= go</code></pre>
<p>There are many variants each with it’s own tradeoffs so one a free to build a way that matchs his task. But the next things should hold:</p>
<ol style="list-style-type: decimal">
<li>Datastructure should either guarantee that other side will read resource atomically or be registered in ResourceT monad</li>
<li>Read and writes should be exception safe</li>
</ol>]]></summary>
</entry>
<entry>
    <title>announcing imagemagick-hs</title>
    <link href="http://qnikst.github.com/posts/2013-01-19-announcing-imagemagick.html" />
    <id>http://qnikst.github.com/posts/2013-01-19-announcing-imagemagick.html</id>
    <published>2013-01-19T00:00:00Z</published>
    <updated>2013-01-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m happy to announce new <a href="http://hackage.haskell.org/package/imagemagick">haskell binding library to imagemagick</a>.</p>
<p>This library is similar to some other bindings. It has some good points:</p>
<ol style="list-style-type: decimal">
<li><p>it has friendly and helpfull maintainers, that willing to help it’s users</p></li>
<li><p>it’s as safe as possible [1]</p></li>
<li><p>it has basics for functional interfaces</p></li>
<li><p>it has MagickWand interface</p></li>
<li><p>it has built-in examples</p></li>
</ol>
<p>But not everything is good:</p>
<ol style="list-style-type: decimal">
<li><p>we have not ported all API. Really it’s not a problem once you can reqyest adding new functionallity or fix pull-request it =).</p></li>
<li><p>it has known bugs and most of them related to imagemagick itself. I’m ready to investigate further if you will have problems with it.</p></li>
<li><p>it has no haddock documentation. Sorry.. I always had troubles with documentation</p></li>
<li><p>it uses modern version of imagemagick so it may lack some enum definitions. I’d like to find a safe way to use only defined enum values.</p></li>
</ol>
<p>About status and future of library:</p>
<p>I had some cool plans for this bindings such as make full imagemagick API support and provide a functional/declarative inteface but unfortunatelly I have no time for this library. So all functionality will be added on demand, i.e. if you lack some features feel free to request it or pull-request.</p>
<p>[1] library using resourcet for controlling external resources lifetime and scope, it’s not as safe as it could be possible with regions but unlucky regions regions are not working with recent GHC.</p>]]></summary>
</entry>
<entry>
    <title>Playing with trees: prefix map</title>
    <link href="http://qnikst.github.com/posts/2013-01-01-playing-with-trees-one.html" />
    <id>http://qnikst.github.com/posts/2013-01-01-playing-with-trees-one.html</id>
    <published>2013-01-01T00:00:00Z</published>
    <updated>2013-01-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>We introduce a binary tree like data structure with next structure.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE OverloadedStrings, ScopedTypeVariables #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import</span> Prelude <span class="kw">hiding</span> (head, length, drop, take, lookup, null)
<span class="ot">&gt;</span> <span class="kw">import</span> Data.Function
<span class="ot">&gt;</span> <span class="kw">import</span> Data.ByteString.Char8 <span class="kw">hiding</span> (empty)
<span class="ot">&gt;</span> <span class="kw">import</span> Test.QuickCheck
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">--        [Node (current value) l v r eq]</span>
<span class="ot">&gt;</span> <span class="co">--                              | | |  +------------------------------------+</span>
<span class="ot">&gt;</span> <span class="co">--        +---------------------+ | +------------------+                    |</span>
<span class="ot">&gt;</span> <span class="co">--        |                       |                    |                    |</span>
<span class="ot">&gt;</span> <span class="co">--        +                       |                    +                    |</span>
<span class="ot">&gt;</span> <span class="co">--  element less            value or nothing        elements that        elements that</span>
<span class="ot">&gt;</span> <span class="co">--  than current            if it intermideate      are more then        have &lt;current value&gt;</span>
<span class="ot">&gt;</span> <span class="co">--                              node                current              as prefix</span>
<span class="ot">&gt;</span> <span class="co">-- </span></code></pre>
<p>Top level item represent empty value and can have a value.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">PrefixMap</span> a <span class="fu">=</span> (<span class="dt">Maybe</span> a, <span class="dt">PMap</span> a)</code></pre>
<p>Inner tree is either an empty value or node, that has left/right children and maybe can have a value and next element</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">PMap</span>  a <span class="fu">=</span> <span class="dt">E</span>
<span class="ot">&gt;</span>              <span class="fu">|</span> <span class="dt">N</span> <span class="dt">ByteString</span> (<span class="dt">PMap</span> a) (<span class="dt">Maybe</span> a) (<span class="dt">PMap</span> a) (<span class="dt">PMap</span> a)
<span class="ot">&gt;</span>              <span class="co">{-   current    less      value        more    eq   -}</span>
<span class="ot">&gt;</span>              <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre>
<p>Having PrefixMap as a additional layer we can assume, that we have a non-null prefix on each level.</p>
<p>Introduce simple builders</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; empty ::</span> <span class="dt">PrefixMap</span> a
<span class="ot">&gt;</span> empty <span class="fu">=</span> (<span class="dt">Nothing</span>, <span class="dt">E</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; node ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">PrefixMap</span> a
<span class="ot">&gt;</span> node b a <span class="fu">|</span> null b    <span class="fu">=</span> (<span class="dt">Just</span> a, <span class="dt">E</span>) 
<span class="ot">&gt;</span>          <span class="fu">|</span> otherwise <span class="fu">=</span> (<span class="dt">Nothing</span>, <span class="dt">N</span> b <span class="dt">E</span>  (<span class="dt">Just</span> a)  <span class="dt">E</span> <span class="dt">E</span>)</code></pre>
<p>Now inserting elements it’s a bit tricky and may be simplified in the way of removing not needed insances</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; insert ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">PrefixMap</span> a <span class="ot">-&gt;</span> <span class="dt">PrefixMap</span> a
<span class="ot">&gt;</span> insert b a (v,n) <span class="fu">|</span> null b    <span class="fu">=</span> (<span class="dt">Just</span> a, n)
<span class="ot">&gt;</span>                  <span class="fu">|</span> otherwise <span class="fu">=</span> (v, inner b a n)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; inner ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">PMap</span> a <span class="ot">-&gt;</span> <span class="dt">PMap</span> a
<span class="ot">&gt;</span> inner b a <span class="dt">E</span> <span class="fu">=</span> <span class="dt">N</span> b <span class="dt">E</span> (<span class="dt">Just</span> a) <span class="dt">E</span> <span class="dt">E</span>
<span class="ot">&gt;</span> inner b a n<span class="fu">@</span>(<span class="dt">N</span> b&#39; l v r e) <span class="fu">|</span> null b     <span class="fu">=</span> n
<span class="ot">&gt;</span>                            <span class="fu">|</span> otherwise  <span class="fu">=</span> 
<span class="ot">&gt;</span>   <span class="kw">case</span> comparing head b b&#39; <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">N</span> b&#39; (inner b a l) v r e   <span class="co">-- value less then current</span>
<span class="ot">&gt;</span>     <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dt">N</span> b&#39; l v (inner b a r) e   <span class="co">-- value more then current</span>
<span class="ot">&gt;</span>     <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> commonPart b b&#39; <span class="co">-- value has common part</span>
<span class="ot">&gt;</span>               c <span class="fu">=</span> take x b
<span class="ot">&gt;</span>               c&#39;<span class="fu">=</span> take x b&#39;
<span class="ot">&gt;</span>               n&#39; <span class="fu">=</span> <span class="dt">N</span> (drop x b&#39;) <span class="dt">E</span> v <span class="dt">E</span> e
<span class="ot">&gt;</span>           <span class="kw">in</span> <span class="kw">if</span> on (<span class="fu">==</span>) length c b&#39;       <span class="co">-- b&#39; isPrefix of b</span>
<span class="ot">&gt;</span>                  <span class="kw">then</span> 
<span class="ot">&gt;</span>                   <span class="kw">if</span> on (<span class="fu">==</span>) length c b    <span class="co">-- b&#39; == b </span>
<span class="ot">&gt;</span>                       <span class="kw">then</span> <span class="dt">N</span> c l (<span class="dt">Just</span> <span class="fu">$!</span> a <span class="ot">`fq`</span> v) r e
<span class="ot">&gt;</span>                       <span class="kw">else</span> <span class="dt">N</span> c l v r (inner (drop x b) a e) <span class="co">-- [b &lt; b&#39;]</span>
<span class="ot">&gt;</span>                  <span class="kw">else</span> <span class="co">-- [ c &lt; b ]</span>
<span class="ot">&gt;</span>                   <span class="kw">if</span> on (<span class="fu">==</span>) length c b
<span class="ot">&gt;</span>                       <span class="kw">then</span> <span class="dt">N</span> c&#39; l (<span class="dt">Just</span> a) r n&#39;
<span class="ot">&gt;</span>                       <span class="kw">else</span> <span class="dt">N</span> c  l <span class="dt">Nothing</span>  r (inner (drop x b) a n&#39;)
<span class="ot">&gt;</span>   <span class="kw">where</span> 
<span class="ot">&gt;</span>     fq a _ <span class="fu">=</span> a</code></pre>
<p>lookup function</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; lookup ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">PrefixMap</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
<span class="ot">&gt;</span> lookup b (v, n) <span class="fu">|</span> null b <span class="fu">=</span> v 
<span class="ot">&gt;</span>                 <span class="fu">|</span> otherwise <span class="fu">=</span> lookinner b n</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; lookinner ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">PMap</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
<span class="ot">&gt;</span> lookinner b <span class="dt">E</span> <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="ot">&gt;</span> lookinner b (<span class="dt">N</span> b&#39; l v r e) <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="kw">case</span> comparing head b b&#39; <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="dt">LT</span> <span class="ot">-&gt;</span> lookinner b l
<span class="ot">&gt;</span>     <span class="dt">GT</span> <span class="ot">-&gt;</span> lookinner b r
<span class="ot">&gt;</span>     <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> commonPart b b&#39;
<span class="ot">&gt;</span>           <span class="kw">in</span> <span class="kw">if</span> x <span class="fu">==</span> length b&#39;
<span class="ot">&gt;</span>                 <span class="kw">then</span> <span class="kw">if</span> x <span class="fu">==</span> length b <span class="kw">then</span> v <span class="kw">else</span> lookinner (drop x b) e
<span class="ot">&gt;</span>                 <span class="kw">else</span> <span class="dt">Nothing</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; commonPart ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> commonPart a b <span class="fu">=</span> go <span class="dv">0</span>
<span class="ot">&gt;</span>   <span class="kw">where</span> 
<span class="ot">&gt;     go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     go x <span class="fu">|</span> x <span class="fu">==</span> y                <span class="fu">=</span> x
<span class="ot">&gt;</span>          <span class="fu">|</span> on (<span class="fu">==</span>) (findex x) a b <span class="fu">=</span> go (x<span class="fu">+</span><span class="dv">1</span>)
<span class="ot">&gt;</span>          <span class="fu">|</span> otherwise             <span class="fu">=</span> x
<span class="ot">&gt;</span>     y <span class="fu">=</span> on min length a b
<span class="ot">&gt;</span>     findex <span class="fu">=</span> flip index
<span class="ot">&gt;</span>     <span class="ot">{-# INLINE findex #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> comparing <span class="fu">=</span> on compare</code></pre>
<p>Check if we are right</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> prop_InsertList (<span class="ot">ls::</span>[<span class="dt">String</span>]) <span class="fu">=</span> 
<span class="ot">&gt;</span>   <span class="kw">let</span> x <span class="fu">=</span> Prelude.foldl (\o x <span class="ot">-&gt;</span> insert (pack x) (pack x) o) empty ls
<span class="ot">&gt;</span>   <span class="kw">in</span> Prelude.all (\l <span class="ot">-&gt;</span> (l<span class="fu">==</span><span class="st">&quot;&quot;</span>) <span class="fu">||</span> pack l <span class="ot">`lookup`</span> x <span class="fu">==</span> <span class="dt">Just</span> (pack l)) ls
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> main <span class="fu">=</span> quickCheck prop_InsertList</code></pre>
<p>What interesting is what properties to we have, ideally we can rewrite code thinking of a N c l v r e as a Tree (M v e)</p>
<p>Caveats:</p>
<ul>
<li><p>this tree is unbalanced so we don’t have best case: this can be fixed by rewriting structure as RB-tree so tree on each level will be sorted.</p></li>
<li><p>this tree doesn’t pack data as it possible: to pack data correctly one need to store a lenght of full bytestring in each node and replace element by the longer string, and copy bytestiring at the leaf node. It this variant we will smallest overhead.</p></li>
<li><p>Node can be rewritten as N (PMap a) (PMap a) (PrefixTree a) this will add a level of indirection but will simplify an insert and lookup a bit.</p></li>
</ul>]]></summary>
</entry>

</feed>
