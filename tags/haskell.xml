<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - Post tagged haskell</title>
    <link href="http://qnikst.github.com/tags/haskell.xml" rel="self" />
    <link href="http://qnikst.github.com" />
    <id>http://qnikst.github.com/tags/haskell.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2013-04-07T00:00:00Z</updated>
    <entry>
    <title>Anouncing binary conduit</title>
    <link href="http://qnikst.github.com/posts/2013-04-07-announcing-binary-conduit.html" />
    <id>http://qnikst.github.com/posts/2013-04-07-announcing-binary-conduit.html</id>
    <published>2013-04-07T00:00:00Z</published>
    <updated>2013-04-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m happy to announce <a href="http://hackage.haskell.org/package/binary-conduit">binary-conduit</a> an library for <a href="http://hackage.haskell.org/package/conduit">conduit</a> streaming data library using <a href="http://hackage.haskell.org/package/binary">binary</a> package.</p>]]></summary>
</entry>
<entry>
    <title>Немного о gentoo-haskell</title>
    <link href="http://qnikst.github.com/posts/2013-03-31-gentoo-haskell.html" />
    <id>http://qnikst.github.com/posts/2013-03-31-gentoo-haskell.html</id>
    <published>2013-03-31T00:00:00Z</published>
    <updated>2013-03-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Как всем известно у haskell пакетов существует прекрасная система с сборки с центральным репозиторием, в котором хранятся пакеты, однако у этой проблемы существует ряд минусов:</p>
<ul>
<li>далеко не все пакеты собираются друг с другом даже если эти версии разрешены в cabal файле.</li>
<li>далеко не все пакеты протестированы</li>
<li>часть пакетов нацелены на работу под конкретной платформой и обновлять их до выхода следующей платформы не собираются</li>
<li>при обновлении пакета нужно пересобирать все обратные зависимости</li>
<li>в случае если нужны профилировочные библиотеки, то нужно пересобирать все зависимости с опциями профилировки.</li>
<li>полное отстуствие верификации исходников, которые вы качаете.</li>
</ul>
<p>Все эти пункты делают использование haskell не очень приятным, так же проблема усугубляется тем, что во многих дистрибутивах представлены устаревшие версии пакетов, за которыми не успевают следить (не верите, то можете посмотреть результаты <a href="https://docs.google.com/forms/d/1y5WtrCB7O9-jb-2Mzo1MtkToh4O6oY2oBXGkc_Q-cy0/viewanalytics">haskell survey</a> Обычным решением является использование cabal на пользовательном уровне, или сборка в песочницах. Но иногда бывают способы и лучше.</p>
<p>Естественно, каждый дистрибутив пытается по своему предложить решение проблем. В посте описана краткая инфрастурктура gentoo-linux и дополнительные пакеты сильно упрощающие работу с haskell, в целом пост может быть интересен, как пользователям Gentoo, так интересующимся пользователям других дистрибутивов, даже в том случае если не они не планируют переход или использование Gentoo Linux.</p>
<ol style="list-style-type: decimal">
<li><p>Gentoo работает под многими платформами: (alpha amd64 ia64 ppc ppc64 sparc x86) и под каждую есть поставка ghc и пакетов. Сам пакет ghc можно поставить в бинарном виде, в том случае, если его сборка слишком тяжела для хоста.</p></li>
<li><p>Для исправления зависимостей существует программа haskell-updater, которая находит все “поломанные” зависимости и пересобирает нужные пакеты. Не так давно для улучшения ситуации добавлен механизм подслотов (subslots) специальная форма зависимостей позволяющая указать, то что программа должна быть обновлена в случае обновления зависимости. В текущий момент этот метод не может решить все проблемы (и даже приводит к некоторым новым), то уже в скором времени подслоты будут <a href="https://bugs.gentoo.org/show_bug.cgi?id=449094">рекурсивными</a> и полностью решат проблему автоматического обновления зависимостей</p></li>
<li><p>Большая часть пакетов доступных на Hackage может быть установлена из оверлея gentoo-haskell. Это надет дополнительный слой, в котором можно провести дополнительные исправления, такие как фиксация зависимостей и добавление патчей, плюс с каждым пакетом ассоциирована хэш сумма, которая ползволяет автоматически проверять валидность скачанных исходников.</p></li>
</ol>
<p>В нашем проекте проводятся следующие политики:</p>
<ol style="list-style-type: decimal">
<li>в оверлее держится последняя версия пакета, и она патчится таким образом, чтобы она могла работать с последними версиями других пакетов. Для некоторых пакетов есть исключения по запросам от пользователей или в случае серьезного изменеия апи.</li>
<li>Во всех пакетах проверяется то, что тесты проходятся (если они есть).</li>
<li>сделаны утилиты для простого создания новых пакетов <em>действительно простого</em></li>
</ol>
<p>Таким образом в gentoo можно спокойно использовать haskell на системном уровне используя песочницы только в исключительных ситуациях.</p>
<p>Так же в дистрибутив входят допонительные полезные утилиты такие как hoogle с поддержкой локальной базы (т.е. всех установленных пакетов).</p>
<p>Если кому-то интересны подробности, шаги по быстрой установке или хочется рассказать, как в вашем дистрибутиве решаются подобные проблемы, то добро пожаловать в комментарии.</p>
<p>P.S. и важно, что gentoo можно поставить под любой вашей осью, данных механизм называется gentoo prefix, и подробности можно найти <a href="http://www.gentoo.org/proj/en/gentoo-alt/prefix/">тут</a>.</p>
<p>Полезные ссылки:</p>
<p>[1] Страница на gentoo wiki: <a href="">http://wiki.gentoo.org/wiki/Haskell</a></p>
<p>[2] Тематический блог: <a href="">http://gentoohaskell.wordpress.com/</a></p>
<p>[3] Haskell wiki: <a href="">http://www.haskell.org/haskellwiki/Gentoo</a></p>]]></summary>
</entry>
<entry>
    <title>Resourcet usage</title>
    <link href="http://qnikst.github.com/posts/2013-02-28-resourcet-usage.html" />
    <id>http://qnikst.github.com/posts/2013-02-28-resourcet-usage.html</id>
    <published>2013-02-28T00:00:00Z</published>
    <updated>2013-02-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post describes an interesting resourcet usecase that may be usefull due to the lack of liner-types support in haskell.</p>
<p>Lets look at the next problem. Assuming we have got a some sort of transaction mechanism that receives data and then perform transaction, but sometimes it may call callback to users code (originally it’s about <a href="http://github.com/qnikst/2pc">2pc</a> library).</p>
<p>So we have method:</p>
<pre><code>withWH0 :: (Binary b) -&gt; ByteString -&gt; (b -&gt; IO Bool) -&gt; IO ()
withWH0 = undefined</code></pre>
<p>Where Bool is result of transaction i.e. either we accept or decline transaction.</p>
<p>This variant is not good as callback is synchronous, we will not be able to run next transaction untill callback is finished. And it will be a bottleneck for the code.</p>
<p>There can be an interesting solution:</p>
<blockquote>
<p>one can provide an trasaction handler, i.e. a resource that for communication of the user code and library, this resource should be either accepted or declined. If that resource is ‘alive’ it means that user is working on transaction. If resource is not touched by user code a default action should be run, before resource will be cleared.</p>
</blockquote>
<p>The problem that we should somehow guarantee that user will free resource. One solution use linear types, but we don’t have them (or at least it’s too difficult for me and I don’t know how to do it). Another option is to use some kind of region library: one option is <a href="http://hackage.haskell.org/package/regions">regions</a> originaly proposed by <a href="http://okmij.org/ftp/Haskell/regions.html#light-weight">Oleg</a> but this package doesn’t work in recent ghc`s due some unsolved bugs, another option is <a href="http://hackage.haskell.org/package/resourcet">resourcet</a> package written by Michael Snoyman, this package doesn’t give so much guarantees as regions but at least it works. Resourcet package introduce ResourceT monad that forms a block where all resources that were registered in that blog will be closed as soon as compulation would left a block (there is an api for an early close but will not look at it now).</p>
<p>So we can guarantee that:</p>
<ol style="list-style-type: decimal">
<li>every resource registered in the block will be freed</li>
<li>resources freeing will be determinated in time/</li>
<li>resource will be freed only once (second call to release is noop)</li>
</ol>
<p>Here are minimal definition for what we need:</p>
<pre><code>data TH = TH -- ^ transaction handler

-- | accept transaction (send message via network)
accept = undefined  
-- | decline transaction (send message via network)
decline = undefined
-- | real release (synonym for decline)
thRelease = undefined

withWH1 d cb = runResourceT $ do
  let d&#39; = decode d
  th &lt;- accure create thRelease
  cb th d&#39;</code></pre>
<p>Now we create a ResourceT region, register resource there and then call user code, our code is not as safe as resourcet release as user can call accept more that once, so we need to check if it was called.</p>
<p>The best thing that now client can use <code>resourceForkIO</code> to make withWH1 asynchronous.</p>
<p>But there is another issue: how user can queue some part of the messages?</p>
<p>TBD make nice picture</p>
<p>There is a solution: <code>unprotect</code> function. This function allowes you to degerister resource in the current resourcet block and then register it in another block, or register new release action.</p>
<p>Currently resourcet package lacks helpers that allowes to move resource to some other place, so one need to create that functions himself. Here are some advices how one can do it safely.</p>
<p>You need a structure that has the following interface:</p>
<ul>
<li>put :: s -&gt; (a, IO ()) -&gt; m () – put resource into storage</li>
<li>get :: s -&gt; m (ReleaseKey a) – get resource and register it in current process</li>
</ul>
<p>Put and get should be atomic and mask exceptions, moreover if you can’t guarantee that message will be immidiatelly read by another process you should register datastructure in some higher level ResourceT block, this way you’ll guarantee that no resources will be left in store unfreed.</p>
<p>Here are some basic examples of such datastructures:</p>
<p>(this code is not well tested as I’ve used more complicated datastructure for such purpose, that have an additional API, but its not usefull for common case)</p>
<p>At first let’s write an <code>InstantMVar</code>, this structure allow you to send message into other process, where it will be immideatelly read, so we don’t need to store that structure in ‘global’ resource block</p>
<pre><code>data InstanceMVar a = InstanceMVar (MVar (a,IO ())) (MVar ())

newMVar = InstanceMVar &lt;$&gt; newEmptyMVar &lt;*&gt; newEmptyMVar

put (InstanceMVar a b) (key, x) = mask_ $ unprotect key &gt;&gt;= putMVar a . ((,) x) &gt;&gt; takeMVar b

get (InstanceMVar a b) = mask_ $ takeMVar a &gt;&gt;= \(x, r) -&gt; register r &gt;&gt; putMVar b () &gt;&gt; return x</code></pre>
<p>This code will guarantee that resource will be read, however it may lock.</p>
<p>Let’s write a <code>DelayedMVar</code> this structure will not block on write, but should be registered in global resourcet block</p>
<pre><code>newtype DelayedMVar a = DelayedMVar (MVar (a,IO ()))

newDelayedMVar = allocate (DelayedMVar &lt;$&gt; newEmptyMVar) (releaseDelayedMVar)

releaseDelayedMVar (DelayedMVar v) = maybe (return ()) (snd) =&lt;&lt; tryReadMVar v

put (DelayedMVar v) (key, x) = mask_ $ unprotect key &gt;&gt;= putMVar a . ((,) x)

get (DelayedMVar v) = mask_ $ takeMVar a &gt;&gt;= \(x, r) -&gt; register r &gt;&gt; return x</code></pre>
<p>Same way one can write Channel or STM Channel, however channel is not fully safe unless chan is closable.</p>
<pre><code>newtype SChan a = SChan (SChan (a,IO ()))

newSChan = allocate (SChan &lt;$&gt; newChan) releaseChan

releaseChan (ChanMVar v) = go =&lt;&lt; tryReadChan v
  where go Nothing = return ()
        go (Just (x,a)) = a &gt;&gt; tryReadChan v {- we have a possible race condition here -} &gt;&gt;= go</code></pre>
<p>There are many variants each with it’s own tradeoffs so one a free to build a way that matchs his task. But the next things should hold:</p>
<ol style="list-style-type: decimal">
<li>Datastructure should either guarantee that other side will read resource atomically or be registered in ResourceT monad</li>
<li>Read and writes should be exception safe</li>
</ol>]]></summary>
</entry>
<entry>
    <title>announcing imagemagick-hs</title>
    <link href="http://qnikst.github.com/posts/2013-01-19-announcing-imagemagick.html" />
    <id>http://qnikst.github.com/posts/2013-01-19-announcing-imagemagick.html</id>
    <published>2013-01-19T00:00:00Z</published>
    <updated>2013-01-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m happy to announce new <a href="http://hackage.haskell.org/package/imagemagick">haskell binding library to imagemagick</a>.</p>
<p>This library is similar to some other bindings. It has some good points:</p>
<ol style="list-style-type: decimal">
<li><p>it has friendly and helpfull maintainers, that willing to help it’s users</p></li>
<li><p>it’s as safe as possible [1]</p></li>
<li><p>it has basics for functional interfaces</p></li>
<li><p>it has MagickWand interface</p></li>
<li><p>it has built-in examples</p></li>
</ol>
<p>But not everything is good:</p>
<ol style="list-style-type: decimal">
<li><p>we have not ported all API. Really it’s not a problem once you can reqyest adding new functionallity or fix pull-request it =).</p></li>
<li><p>it has known bugs and most of them related to imagemagick itself. I’m ready to investigate further if you will have problems with it.</p></li>
<li><p>it has no haddock documentation. Sorry.. I always had troubles with documentation</p></li>
<li><p>it uses modern version of imagemagick so it may lack some enum definitions. I’d like to find a safe way to use only defined enum values.</p></li>
</ol>
<p>About status and future of library:</p>
<p>I had some cool plans for this bindings such as make full imagemagick API support and provide a functional/declarative inteface but unfortunatelly I have no time for this library. So all functionality will be added on demand, i.e. if you lack some features feel free to request it or pull-request.</p>
<p>[1] library using resourcet for controlling external resources lifetime and scope, it’s not as safe as it could be possible with regions but unlucky regions regions are not working with recent GHC.</p>]]></summary>
</entry>
<entry>
    <title>Playing with trees: prefix map</title>
    <link href="http://qnikst.github.com/posts/2013-01-01-playing-with-trees-one.html" />
    <id>http://qnikst.github.com/posts/2013-01-01-playing-with-trees-one.html</id>
    <published>2013-01-01T00:00:00Z</published>
    <updated>2013-01-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>We introduce a binary tree like data structure with next structure.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE OverloadedStrings, ScopedTypeVariables #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import</span> Prelude <span class="kw">hiding</span> (head, length, drop, take, lookup, null)
<span class="ot">&gt;</span> <span class="kw">import</span> Data.Function
<span class="ot">&gt;</span> <span class="kw">import</span> Data.ByteString.Char8 <span class="kw">hiding</span> (empty)
<span class="ot">&gt;</span> <span class="kw">import</span> Test.QuickCheck
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">--        [Node (current value) l v r eq]</span>
<span class="ot">&gt;</span> <span class="co">--                              | | |  +------------------------------------+</span>
<span class="ot">&gt;</span> <span class="co">--        +---------------------+ | +------------------+                    |</span>
<span class="ot">&gt;</span> <span class="co">--        |                       |                    |                    |</span>
<span class="ot">&gt;</span> <span class="co">--        +                       |                    +                    |</span>
<span class="ot">&gt;</span> <span class="co">--  element less            value or nothing        elements that        elements that</span>
<span class="ot">&gt;</span> <span class="co">--  than current            if it intermideate      are more then        have &lt;current value&gt;</span>
<span class="ot">&gt;</span> <span class="co">--                              node                current              as prefix</span>
<span class="ot">&gt;</span> <span class="co">-- </span></code></pre>
<p>Top level item represent empty value and can have a value.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">PrefixMap</span> a <span class="fu">=</span> (<span class="dt">Maybe</span> a, <span class="dt">PMap</span> a)</code></pre>
<p>Inner tree is either an empty value or node, that has left/right children and maybe can have a value and next element</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">PMap</span>  a <span class="fu">=</span> <span class="dt">E</span>
<span class="ot">&gt;</span>              <span class="fu">|</span> <span class="dt">N</span> <span class="dt">ByteString</span> (<span class="dt">PMap</span> a) (<span class="dt">Maybe</span> a) (<span class="dt">PMap</span> a) (<span class="dt">PMap</span> a)
<span class="ot">&gt;</span>              <span class="co">{-   current    less      value        more    eq   -}</span>
<span class="ot">&gt;</span>              <span class="kw">deriving</span> (<span class="kw">Show</span>)</code></pre>
<p>Having PrefixMap as a additional layer we can assume, that we have a non-null prefix on each level.</p>
<p>Introduce simple builders</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; empty ::</span> <span class="dt">PrefixMap</span> a
<span class="ot">&gt;</span> empty <span class="fu">=</span> (<span class="kw">Nothing</span>, <span class="dt">E</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; node ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">PrefixMap</span> a
<span class="ot">&gt;</span> node b a <span class="fu">|</span> <span class="fu">null</span> b    <span class="fu">=</span> (<span class="kw">Just</span> a, <span class="dt">E</span>) 
<span class="ot">&gt;</span>          <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> (<span class="kw">Nothing</span>, <span class="dt">N</span> b <span class="dt">E</span>  (<span class="kw">Just</span> a)  <span class="dt">E</span> <span class="dt">E</span>)</code></pre>
<p>Now inserting elements it’s a bit tricky and may be simplified in the way of removing not needed insances</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; insert ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">PrefixMap</span> a <span class="ot">-&gt;</span> <span class="dt">PrefixMap</span> a
<span class="ot">&gt;</span> insert b a (v,n) <span class="fu">|</span> <span class="fu">null</span> b    <span class="fu">=</span> (<span class="kw">Just</span> a, n)
<span class="ot">&gt;</span>                  <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> (v, inner b a n)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; inner ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">PMap</span> a <span class="ot">-&gt;</span> <span class="dt">PMap</span> a
<span class="ot">&gt;</span> inner b a <span class="dt">E</span> <span class="fu">=</span> <span class="dt">N</span> b <span class="dt">E</span> (<span class="kw">Just</span> a) <span class="dt">E</span> <span class="dt">E</span>
<span class="ot">&gt;</span> inner b a n<span class="fu">@</span>(<span class="dt">N</span> b&#39; l v r e) <span class="fu">|</span> <span class="fu">null</span> b     <span class="fu">=</span> n
<span class="ot">&gt;</span>                            <span class="fu">|</span> <span class="fu">otherwise</span>  <span class="fu">=</span> 
<span class="ot">&gt;</span>   <span class="kw">case</span> comparing <span class="fu">head</span> b b&#39; <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="kw">LT</span> <span class="ot">-&gt;</span> <span class="dt">N</span> b&#39; (inner b a l) v r e   <span class="co">-- value less then current</span>
<span class="ot">&gt;</span>     <span class="kw">GT</span> <span class="ot">-&gt;</span> <span class="dt">N</span> b&#39; l v (inner b a r) e   <span class="co">-- value more then current</span>
<span class="ot">&gt;</span>     <span class="kw">EQ</span> <span class="ot">-&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> commonPart b b&#39; <span class="co">-- value has common part</span>
<span class="ot">&gt;</span>               c <span class="fu">=</span> <span class="fu">take</span> x b
<span class="ot">&gt;</span>               c&#39;<span class="fu">=</span> <span class="fu">take</span> x b&#39;
<span class="ot">&gt;</span>               n&#39; <span class="fu">=</span> <span class="dt">N</span> (<span class="fu">drop</span> x b&#39;) <span class="dt">E</span> v <span class="dt">E</span> e
<span class="ot">&gt;</span>           <span class="kw">in</span> <span class="kw">if</span> on (<span class="fu">==</span>) <span class="fu">length</span> c b&#39;       <span class="co">-- b&#39; isPrefix of b</span>
<span class="ot">&gt;</span>                  <span class="kw">then</span> 
<span class="ot">&gt;</span>                   <span class="kw">if</span> on (<span class="fu">==</span>) <span class="fu">length</span> c b    <span class="co">-- b&#39; == b </span>
<span class="ot">&gt;</span>                       <span class="kw">then</span> <span class="dt">N</span> c l (<span class="kw">Just</span> <span class="fu">$!</span> a <span class="ot">`fq`</span> v) r e
<span class="ot">&gt;</span>                       <span class="kw">else</span> <span class="dt">N</span> c l v r (inner (<span class="fu">drop</span> x b) a e) <span class="co">-- [b &lt; b&#39;]</span>
<span class="ot">&gt;</span>                  <span class="kw">else</span> <span class="co">-- [ c &lt; b ]</span>
<span class="ot">&gt;</span>                   <span class="kw">if</span> on (<span class="fu">==</span>) <span class="fu">length</span> c b
<span class="ot">&gt;</span>                       <span class="kw">then</span> <span class="dt">N</span> c&#39; l (<span class="kw">Just</span> a) r n&#39;
<span class="ot">&gt;</span>                       <span class="kw">else</span> <span class="dt">N</span> c  l <span class="kw">Nothing</span>  r (inner (<span class="fu">drop</span> x b) a n&#39;)
<span class="ot">&gt;</span>   <span class="kw">where</span> 
<span class="ot">&gt;</span>     fq a _ <span class="fu">=</span> a</code></pre>
<p>lookup function</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; lookup ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">PrefixMap</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
<span class="ot">&gt;</span> <span class="fu">lookup</span> b (v, n) <span class="fu">|</span> <span class="fu">null</span> b <span class="fu">=</span> v 
<span class="ot">&gt;</span>                 <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> lookinner b n</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; lookinner ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">PMap</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
<span class="ot">&gt;</span> lookinner b <span class="dt">E</span> <span class="fu">=</span> <span class="kw">Nothing</span>
<span class="ot">&gt;</span> lookinner b (<span class="dt">N</span> b&#39; l v r e) <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="kw">case</span> comparing <span class="fu">head</span> b b&#39; <span class="kw">of</span>
<span class="ot">&gt;</span>     <span class="kw">LT</span> <span class="ot">-&gt;</span> lookinner b l
<span class="ot">&gt;</span>     <span class="kw">GT</span> <span class="ot">-&gt;</span> lookinner b r
<span class="ot">&gt;</span>     <span class="kw">EQ</span> <span class="ot">-&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> commonPart b b&#39;
<span class="ot">&gt;</span>           <span class="kw">in</span> <span class="kw">if</span> x <span class="fu">==</span> <span class="fu">length</span> b&#39;
<span class="ot">&gt;</span>                 <span class="kw">then</span> <span class="kw">if</span> x <span class="fu">==</span> <span class="fu">length</span> b <span class="kw">then</span> v <span class="kw">else</span> lookinner (<span class="fu">drop</span> x b) e
<span class="ot">&gt;</span>                 <span class="kw">else</span> <span class="kw">Nothing</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; commonPart ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> commonPart a b <span class="fu">=</span> go <span class="dv">0</span>
<span class="ot">&gt;</span>   <span class="kw">where</span> 
<span class="ot">&gt;     go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     go x <span class="fu">|</span> x <span class="fu">==</span> y                <span class="fu">=</span> x
<span class="ot">&gt;</span>          <span class="fu">|</span> on (<span class="fu">==</span>) (findex x) a b <span class="fu">=</span> go (x<span class="fu">+</span><span class="dv">1</span>)
<span class="ot">&gt;</span>          <span class="fu">|</span> <span class="fu">otherwise</span>             <span class="fu">=</span> x
<span class="ot">&gt;</span>     y <span class="fu">=</span> on <span class="fu">min</span> <span class="fu">length</span> a b
<span class="ot">&gt;</span>     findex <span class="fu">=</span> <span class="fu">flip</span> <span class="fu">index</span>
<span class="ot">&gt;</span>     <span class="ot">{-# INLINE findex #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> comparing <span class="fu">=</span> on <span class="fu">compare</span></code></pre>
<p>Check if we are right</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> prop_InsertList (<span class="ot">ls::</span>[<span class="dt">String</span>]) <span class="fu">=</span> 
<span class="ot">&gt;</span>   <span class="kw">let</span> x <span class="fu">=</span> Prelude.foldl (\o x <span class="ot">-&gt;</span> insert (<span class="fu">pack</span> x) (<span class="fu">pack</span> x) o) empty ls
<span class="ot">&gt;</span>   <span class="kw">in</span> Prelude.all (\l <span class="ot">-&gt;</span> (l<span class="fu">==</span><span class="st">&quot;&quot;</span>) <span class="fu">||</span> <span class="fu">pack</span> l <span class="ot">`lookup`</span> x <span class="fu">==</span> <span class="kw">Just</span> (<span class="fu">pack</span> l)) ls
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> main <span class="fu">=</span> quickCheck prop_InsertList</code></pre>
<p>What interesting is what properties to we have, ideally we can rewrite code thinking of a N c l v r e as a Tree (M v e)</p>
<p>Caveats:</p>
<ul>
<li><p>this tree is unbalanced so we don’t have best case: this can be fixed by rewriting structure as RB-tree so tree on each level will be sorted.</p></li>
<li><p>this tree doesn’t pack data as it possible: to pack data correctly one need to store a lenght of full bytestring in each node and replace element by the longer string, and copy bytestiring at the leaf node. It this variant we will smallest overhead.</p></li>
<li><p>Node can be rewritten as N (PMap a) (PMap a) (PrefixTree a) this will add a level of indirection but will simplify an insert and lookup a bit.</p></li>
</ul>]]></summary>
</entry>
<entry>
    <title>cabal-dev</title>
    <link href="http://qnikst.github.com/posts/2012-01-30-cabal-dev.html" />
    <id>http://qnikst.github.com/posts/2012-01-30-cabal-dev.html</id>
    <published>2010-01-30T00:00:00Z</published>
    <updated>2010-01-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>Q: how to use cabal?</p>
<p>A: just cabal install cabal-dev</p>
</blockquote>
<p>Cabal is a great system of building and packaging Haskell libraries but is has some downsides such as:</p>
<ol style="list-style-type: decimal">
<li><p>it has very poor handling of library versions and tracking dependecies.</p></li>
<li><p>it can’t have multiply versions of same library (really it can but then it becomes a pain to use them)</p></li>
</ol>
<p>So sometimes it becomes a pain to fix haskell tree.</p>
<p>Cabal-dev is a cabal-install wrapper that build project and dependencies in sandboxed enviromnent, this allowes to use multiple version of the same library and so chanses to break system are very low. Additionally it generates image of installed application so you can check how it will be installed on your system without real installation.</p>
<p>Of cause as there are some problems:</p>
<ol style="list-style-type: decimal">
<li><p>cabal-dev is slow, because you should install all dependencies in sandbox environment (unless they are installed system wide).</p></li>
<li><p>cabal-dev can’t handle some Setup.hs options at least it was true in Dec-2011.</p></li>
</ol>
<p>First problem easily fixed in gentoo, one can install basic dependencies with emerge, so portage will track tree consitency with <code>haskell-updater &lt;http://www.haskell.org/haskellwiki/Gentoo#haskell-updater&gt;</code> (replacement tool for ghc-updater) and has all other features out of the box. So cabal-dev will be using most of libs from system and some other will be sandboxed.</p>
<p>For second one I had a workaround by creating makefile that run setup.hs and then cabal-dev intall.</p>
<p>Also cabal-dev has additional feature of running built program in ghc (i.e. run ghci and load every module in project) it can be done with</p>
<p><code>cabal-dev build &amp;&amp; cabal-dev ghci</code></p>]]></summary>
</entry>

</feed>
