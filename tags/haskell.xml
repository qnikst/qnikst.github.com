<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - Post tagged haskell</title>
    <link href="https://qnikst.github.io/tags/haskell.xml" rel="self" />
    <link href="https://qnikst.github.io" />
    <id>https://qnikst.github.io/tags/haskell.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2019-12-28T00:00:00Z</updated>
    <entry>
    <title>Resticting servant query parameters</title>
    <link href="https://qnikst.github.io/posts/2019-09-28-restricting-servant.html" />
    <id>https://qnikst.github.io/posts/2019-09-28-restricting-servant.html</id>
    <published>2019-12-28T00:00:00Z</published>
    <updated>2019-12-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In this post, I’d like to share one solution to the problem I had at work. It is split into three parts, <a href="#problem">the definition of the problem</a>, <a href="#boring">boring part</a> (how we can achieve the goal), and then something <a href="#fancy">fancy</a> that we can have if we go a big forward with the solution.</p>
<h1 id="the-problem-definition"><a name="problem">The problem definition</a></h1>
<p>TLDR we want to make our servant service to reply <code>404</code> whenever we see query part in some endpoints subtree. If you are not interested in why do I need that you can proceed to the <a href="#boring">solution</a> directly.</p>
<p>I’m working on building a few web services. One of them provides service to run contents. On such contests, lots of people come at once to solve some tasks. Thus we have a severe load in bounded time (It’s not entirely true as those contests are running all the time, but most of them are quite small). However, we have some significant events with up to 20k unique people passing in 3 hours, generating a load a bit higher than 500rps. It is not high value, but the main problem here is that any issue with availability or responsiveness hit our reputation a lot. Additionally, in the past, we had experienced DDOS attacks during such events. Currently, our services can handle at least three times higher load even in the worth case, but still, we are interested in reducing the surface of the possible attacks. Yet we can handle many requests the network in the cluster is not very wide, so it’s possible to introduce a denial of service if you’ll use all the network by for example loading large data.</p>
<p>The usual solution for such sort of issues is offloading static and large content to a CDN service. Such services are distributed enough can easily manage a high load. There are two kinds of CDN services we can use: external CDN service transparent CDN service.</p>
<p>External CDN service (pic.1) is just a 3rd party service that provides API for uploading and removing files. Such service takes all responsibilities for distributing data and providing the required quality of service. All you do in your user-facing service is giving links to the third-party one. The cost is that you need to upload and control files on that service explicitly.</p>
<p><img src="/images/posts/servant/external.png"/></p>
<p>Transparent CDN service (pic2.) is a service that acts as a distributed proxy for your service. In addition to proxying requests, it stores and propagates files on its nodes based on the response headers. This way, you can control all the data on CDN. Besides, such services often provide firewall and anti-DDOS services.</p>
<p><img src="/images/posts/servant/transparent.png"/></p>
<p>We took the transparent CDN service because our patterns of working with the contest are quite intricate: until frozen files are not expected to be cached and may mutate, but once frozen file can never mutate and should be persisted. Additionally, we get DDOS protection and a firewall for free.</p>
<p>But, just plugging transparent CDN service in front of yours will not work. CDN is very simple, it does not and can’t analyse actual traffic, so if a malicious user asks for <code>https://our.service/content/big_image</code>, and then <code>https://our.service/content/big_image?foobar</code> both requests will pass through CDN and fall on our service. This way attacker can generate infinite amount of URLs and be able to attack the service no matter if there is CDN or not.</p>
<p>But what to do? One option is to forbid access to content if there is a query part of the URL. It looks like a sane option as “valid” clients never access content while adding query parameters. For other parts of the service, it’s done by NGINX rules. But for some parts of the service, it is responsible for generating contents and setting proper headers, and we want it to be accountable to replying 404 on such queries.</p>
<h1 id="solution."><a name="boring">Solution</a>.</h1>
<p>We use <a href="https://hackage.haskell.org/package/servant">servant</a> as a framework to write a server. It allows writing a declarative description of the service structure on the type level. More details on that may be found in the servant <a href="http://docs.servant.dev/en/stable/tutorial/index.html">tutorial</a>, or a very basic <a href="https://qnikst.github.io/posts/2018-10-09-starting-webapp.html">howto</a>.</p>
<p>We want to restrict query parameters on some part of the endpoints tree. It may look like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> <span class="dt">MyService</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="ot">=</span> <span class="st">&quot;content&quot;</span> <span class="op">:&gt;</span> <span class="dt">RestrictQueryParams</span> <span class="op">:&gt;</span> <span class="dt">ContentEndpoint</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>  <span class="op">&lt;|&gt;</span> other<span class="op">..</span>end<span class="op">..</span>points</span></code></pre></div>
<p>This way, <code>ContentEndpoint</code> doesn’t know that it was restricted and can implement its logic without knowing how is it called. It is a crucial point that provides a necessary abstraction level.</p>
<p>We are going to implement <code>RestrictQueryParam</code> now. To achieve it, we need to introduce a new servant combinator the one like (Capture, QueryParam or other from the <a href="https://hackage.haskell.org/package/servant-0.16.2/docs/Servant-API.html">Servant.API</a> hierarchy). It’s not particularly well documented, but there are enough examples in the servant itself.</p>
<p>The first thing we need is to introduce the type for</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- | Forbid passing any query parameter.</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">-- If the parameter is given, then we throw 404</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">data</span> <span class="dt">RestrictQueryParams</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="kw">deriving</span> <span class="dt">Typeable</span></span></code></pre></div>
<p>Note it doesn’t have type constructor there this construction may live on the type level only.</p>
<p>Nest step is implementing <a href="https://hackage.haskell.org/package/servant-server-0.16.2/docs/Servant-Server.html#t:HasServer"><code>HasServer</code></a> instance. This instance describes how we parse the request and how we work with the response.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">instance</span></span>
<span id="cb3-2"><a href="#cb3-2"></a> (<span class="dt">HasServer</span> api context) <span class="co">{-1-}</span></span>
<span id="cb3-3"><a href="#cb3-3"></a> <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (<span class="dt">RestrictQueryParams</span> <span class="op">:&gt;</span> api) context <span class="kw">where</span> <span class="co">{-2-}</span></span>
<span id="cb3-4"><a href="#cb3-4"></a> <span class="kw">type</span> <span class="dt">ServerT</span> (<span class="dt">RestrictQueryParams</span> <span class="op">:&gt;</span> api) m <span class="ot">=</span> <span class="dt">ServerT</span> api m <span class="co">{-3-}</span></span>
<span id="cb3-5"><a href="#cb3-5"></a> hoistServerWithContext <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb3-6"><a href="#cb3-6"></a> route <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>The instance is very straighforward it tells that internal server (<code>{-1-}</code>) wrapped in the <code>RestrictQueryParams</code> (<code>{-2-}</code>) is also a server. Type <code>ServerT</code> tells that resulting server type. In our case it’s the same as for the internal server: RestrictQueryParams doesn’t change it. <code>hoistServerWithContext</code> tells how to change underlying monad if needed, you skip it and see how it’s implemented in the other combinators:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>  hoistServerWithContext _ pc nt s</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="ot">=</span> hoistServerWithContext (<span class="dt">Proxy</span><span class="ot">::</span> <span class="dt">Proxy</span> api) pc nt s</span></code></pre></div>
<p>And the last but not the least method is the route, that describes routing itself.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a>  route <span class="dt">Proxy</span> context subserver <span class="ot">=</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>     route (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api) context <span class="op">$</span> add subserver</span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="kw">where</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>      add <span class="dt">Delayed</span>{<span class="op">..</span>} <span class="ot">=</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>        <span class="dt">Delayed</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>          { paramsD <span class="ot">=</span> withRequest check <span class="op">*&gt;</span> paramsD</span>
<span id="cb5-7"><a href="#cb5-7"></a>          , <span class="op">..</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>          }</span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="ot">      check ::</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">DelayedIO</span> ()</span>
<span id="cb5-10"><a href="#cb5-10"></a>      check req</span>
<span id="cb5-11"><a href="#cb5-11"></a>        <span class="op">|</span> <span class="fu">not</span> <span class="op">$</span> B.null <span class="op">$</span> rawQueryString req <span class="ot">=</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>          delayedFailFatal err404</span>
<span id="cb5-13"><a href="#cb5-13"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">pure</span> ()</span></code></pre></div>
<p>Here we add parameters check to the internal server checks (<code>add subserver</code>). It checks the <code>Wai.Request</code> (<code>withRequest check</code>) to the checks added by internal server (<code>*&gt; paramsD</code>), keeping other checks untouched. In the <code>check</code> function we check <code>rawQueryString</code> and reply with 404 if it’s not emoty. Description of the request checks is given in the <a href="https://hackage.haskell.org/package/servant-server-0.16.2/docs/Servant-Server-Internal-Delayed.html#t:Delayed">docs</a>.</p>
<p>Instances for client and swagger are trivial; they pass all the work to the internal API.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">instance</span> (<span class="dt">HasSwagger</span> api) <span class="ot">=&gt;</span> <span class="dt">HasSwagger</span> (<span class="dt">RestrictQueryParams</span> <span class="op">:&gt;</span> <span class="dt">API</span>) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>  toSwagger _ <span class="ot">=</span> toSwagger (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api)</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">instance</span> <span class="dt">HasClient</span> m api <span class="ot">=&gt;</span> <span class="dt">HasClient</span> m (<span class="dt">RestrictQueryParams</span> <span class="op">:&gt;</span> api) <span class="kw">where</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>  <span class="kw">type</span> <span class="dt">Client</span> m (<span class="dt">RestrictQueryParams</span> <span class="op">:&gt;</span> api) <span class="ot">=</span> <span class="dt">Client</span> m api</span>
<span id="cb6-6"><a href="#cb6-6"></a>  clientWithRoute pm <span class="dt">Proxy</span> req <span class="ot">=</span> clientWithRoute pm (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api) req</span>
<span id="cb6-7"><a href="#cb6-7"></a>  hoistClientMonad pm _ f cl <span class="ot">=</span> hoistClientMonad pm (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> api) f cl</span></code></pre></div>
<p>This way, it has landed in our codebase because it just solves the problem. Adding this check solves our problem and can be reused in other projects.</p>
<h1 id="more-checks"><a name="fancy">More checks</a></h1>
<p>But there is a problem. Sub server doesn’t know about that it runs in the restricted context, but the server itself should know if this restriction can be safely applied. It can’t be used if the server uses query parameters. So we want to prove that we doesn’t have this problem. It can be achieved using <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html#t:TypeError">custom type erros</a> more on docs on the <a href="https://gitlab.haskell.org/ghc/ghc/wikis/proposal/custom-type-errors">ghc wiki</a>.</p>
<p>To use it, we need to introduce additional type family. You may think of type family as a function on types, that can perform pattern matching on types and return some result. This function should either return a error or the same type. We need to traverse servant endpoint structure and return a type error.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">CheckNoParams</span> e <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="dt">CheckNoParams</span> (f <span class="op">:&gt;</span> g) <span class="ot">=</span> f <span class="op">:&gt;</span> (<span class="dt">CheckNoParams</span> g)</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="dt">CheckNoParams</span> (f <span class="op">:&lt;|&gt;</span> g) <span class="ot">=</span> <span class="dt">CheckNoParams</span> f <span class="op">:&lt;|&gt;</span> <span class="dt">CheckNoParams</span> g</span>
<span id="cb7-4"><a href="#cb7-4"></a>  <span class="dt">CheckNoParams</span> (<span class="dt">QueryParam</span> sym x <span class="op">:&gt;</span> y) <span class="ot">=</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="dt">TypeError</span> (<span class="dt">&#39;Text</span> <span class="st">&quot;can&#39;t use QueryParam under RestrictQueryParams&quot;</span>)</span>
<span id="cb7-6"><a href="#cb7-6"></a>  <span class="dt">CheckNoParams</span> a <span class="ot">=</span> a</span></code></pre></div>
<p>This way we recursively go through all endpoints (lines 1 and 2), return a error if see a query param (line 3), and type as it was if it’s not QueryParam (line 5)</p>
<p>If you’ll use <code>RestrictQueryParam</code> on the endpoint that uses query you get following error message:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a>src<span class="op">/</span>Server.hs<span class="op">:</span><span class="dv">124</span><span class="op">:</span><span class="dv">9</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>    • can&#39;t use <span class="dt">QueryParam</span> under <span class="dt">RestrictQueryParams</span></span></code></pre></div>
<p>I think after the post it will land in the codebase as well.</p>
<p>But it’s possible to go even further and allow the headers that are used in the internal site. Unfortunately this problem is much more complex and I’m not sure if the checks will not be too expensive, but if anyone has a solution I’ll be happy to check it.</p>]]></summary>
</entry>
<entry>
    <title>Writing a simple web-application</title>
    <link href="https://qnikst.github.io/posts/2018-10-09-starting-webapp.html" />
    <id>https://qnikst.github.io/posts/2018-10-09-starting-webapp.html</id>
    <published>2018-10-09T00:00:00Z</published>
    <updated>2018-10-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the <a href="https://qnikst.github.io/posts/2018-10-29-metrics-haskell.html">last post</a>, I’ve talked about adding metrics to a Haskell application. Unfortunately that post didn’t have a full code example and contained only minor pieces of the code. So it could be hard to write your own application based on that post. So I decided to prepare a full example that can be looked at and reused in later posts and projects. You can find the source code on <a href="https://github.com/qnikst/sample-site">GitHub</a>. The app is a very simple skeleton so if you have experience with writing those feel free to skip this post.</p>
<p>I’ll take <a href="https://www.techempower.com/benchmarks/">the techempower benchmark</a> as a site specification. The API is simple enough to represent exciting features and doesn’t take much time to write. I’m not going to compete against other implementations of that benchmark (at least I think so at the time of writing this post). Today I’m going to make a skeleton of the site and one endpoint only.</p>
<p>I’ll take servant as a web framework, to my taste it is the best framework you can use unless you have exceptional needs. The main feature of the servant framework is that it allows to generate and test much code for free, without much extra cost.</p>
<p>Servant framework has a very nice tutorial and documentation that can be found at <a href="https://haskell-servant.readthedocs.io/en/stable/">read-the-doc site</a> .</p>
<p>When writing an application using servant you first need to define its API:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> <span class="dt">Api</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="ot">=</span> <span class="dt">JsonApi</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">type</span> <span class="dt">JsonApi</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>  <span class="ot">=</span> <span class="dt">Description</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="st">&quot;Raw JSON output API \</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="st">    \ For each request, an object mapping the key message \</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="st">    \ to \&quot;Hello, World!\&quot; must be instantiated.&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>  <span class="op">:&gt;</span> <span class="st">&quot;json&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>  <span class="op">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">Message</span></span></code></pre></div>
<p>I prefer to keep a type synonym for each endpoint (or endpoint structure) as that would allow using that type in the other parts of the program for code generation.</p>
<p>This type explains how a handler does its work and <code>:&gt;</code> splits the type into URL pieces. This type tells that application can handle Get requests to the URL <code>/json</code> if accept type is <code>application/json</code> and when doing that it returns a <code>Message.</code></p>
<p>The additional <code>Description</code> part comes from the <a href="http://hackage.haskell.org/package/servant-swagger">servant-swagger</a> package. A few more extra lines provide additional information about our API:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">apiVersion ::</span> <span class="dt">T.Text</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>apiVersion <span class="ot">=</span> <span class="st">&quot;0.0.1&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="ot">swagger ::</span> <span class="dt">Swagger</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>swagger <span class="ot">=</span> toSwagger (<span class="dt">Proxy</span> <span class="op">@</span> <span class="dt">Api</span>)</span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="op">&amp;</span> info<span class="op">.</span>title <span class="op">.~</span> <span class="st">&quot;Experimental API&quot;</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="op">&amp;</span> info<span class="op">.</span>description <span class="op">?~</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="st">&quot;This is a benchmark site, and used for general \</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="st">    \ experiments and blog examples.&quot;</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>  <span class="op">&amp;</span> info<span class="op">.</span>version <span class="op">.~</span> apiVersion</span></code></pre></div>
<p>Now we can run the server. Our sever consists of the swagger UI and our application.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">type</span> <span class="dt">API</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="ot">=</span> <span class="dt">SwaggerSchemaUI</span> <span class="st">&quot;swagger-ui&quot;</span> <span class="st">&quot;swagger.json&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="op">:&lt;|&gt;</span> <span class="dt">Api</span></span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="ot">run ::</span> <span class="dt">IO</span> ()</span>
<span id="cb3-6"><a href="#cb3-6"></a>run <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>  Warp.run configPort</span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="op">$</span> prometheus def {</span>
<span id="cb3-9"><a href="#cb3-9"></a>        prometheusInstrumentPrometheus <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>        }</span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="op">$</span> serve (<span class="dt">Proxy</span> <span class="op">@</span><span class="dt">API</span>)</span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="op">$</span> swaggerSchemaUIServer swagger </span>
<span id="cb3-13"><a href="#cb3-13"></a>        <span class="op">:&lt;|&gt;</span> server</span>
<span id="cb3-14"><a href="#cb3-14"></a>  <span class="kw">where</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="ot">    configPort ::</span> <span class="dt">Int</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>    configPort <span class="ot">=</span> <span class="dv">8080</span></span>
<span id="cb3-17"><a href="#cb3-17"></a></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="ot">server ::</span> <span class="dt">Handler</span> <span class="dt">Message</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>server <span class="ot">=</span> <span class="fu">pure</span> <span class="op">$</span> <span class="dt">Message</span> <span class="st">&quot;Hello World!&quot;</span></span></code></pre></div>
<p>Remember <code>prometheus def</code> lines from the previous post. And the application runner is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">import</span> <span class="dt">Prometheus</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">import</span> <span class="dt">Prometheus.Metric.GHC</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">import</span> <span class="dt">Sample.Server</span> (run)</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-6"><a href="#cb4-6"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>  _ <span class="ot">&lt;-</span> register ghcMetrics</span>
<span id="cb4-8"><a href="#cb4-8"></a>  run</span></code></pre></div>
<p>Now we can have an application that returns us <code>{message:"Hello, World!"}</code> on <code>json</code> URL and swagger UI on <code>swagger-ui/</code>. With that interface you can explore site API:</p>
<div>
<img src="../images/posts/web-app-1/0.swagger-ui-1.png" width="80%" style="inline"/>
</div>
<p>Send requests and observe results</p>
<div>
<img src="../images/posts/web-app-1/1.swagger-ui-2.png" width="80%" style="inline"/>
</div>
<p>And all that comes for free.</p>
<p>There are a few more things I’d like to discuss before moving to metrics:</p>
<ol type="1">
<li><p><a href="https://github.com/qnikst/sample-site/blob/2d6bb3b39ce6a6e5afe9de055cda73d6babcce0c/sample-site/src/Data/Aeson/Extended.hs#L11-L21">Naming conventions</a> - it’s worth to define common conventions for converting Haskell data types into their JSON representation and use them across the project.</p></li>
<li><p><a href="https://github.com/qnikst/sample-site/blob/master/sample-site/test/spec/Sample/ApiSpec.hs#L23-L35">Encoding tests</a> with servant and swagger you can automatically test serialisation of values for all the types used in the API. Also tests check that specification is up to date.</p></li>
</ol>
<p>Now we have a simple site with helper interface and specification. There are many missing pieces, for example: a. configuration parsing; b. logging; c. more autogenerated tests; d. nice defaults for RTS options.</p>
<p>All of them will be covered in the following posts.</p>
<p>In order to build everything I prefer to use <code>nix</code> package manager. Both <code>stack</code> and <code>cabal-install</code> are nice tools to do that but with nix you can add more features to the build system. For example building of docker containers, building packages written in other languages and setting up a development environment. Build scripts for the package can be found at <a href="https://github.com/qnikst/sample-site/blob/2d6bb3b39ce6a6e5afe9de055cda73d6babcce0c/nix/overlays.nix#L15-L19">overlays.nix</a>. Build scripts for its docker container are in <a href="https://github.com/qnikst/sample-site/blob/2d6bb3b39ce6a6e5afe9de055cda73d6babcce0c/nix/docker.nix#L8-L28">docker.nix</a>.</p>
<p>At this point we are ready to setup our environment with Grafana and Prometheus. Configs are the same as the ones described earlier or they can be found at <a href="https://github.com/qnikst/sample-site/tree/2d6bb3b39ce6a6e5afe9de055cda73d6babcce0c/deploy/docker">GitHub</a>.</p>
<p>Graphana reports are looking like:</p>
<ol type="1">
<li>Main screen: <br /> main screen lists all instances with Haskell application to filter on. If specific instance is chosen then all the following plots show information for that instance only.
<div style="margin: 10px 0;">
<img src="../images/posts/web-app-1/3.grafana-1.png" width="100%" style="inline"/>
</div></li>
<li>CPU panel:<br /> shows rate of CPU seconds spent by the program. Basically it says whaf fraction of a secod the program worked during 1s of clock time. You can realize how active your application was. <code>Mutator CPU time</code> shows how much CPU time you’ve spent doing actual work. If total CPU time is much higher than Mutator CPU time, then you are likely to have problems with GC.
<div style="margin: 10px 0; ">
<img src="../images/posts/web-app-1/4.grafana-1.png" width="100%" style="inline"/>
</div></li>
<li>Memory panel:<br /> shows the rate of allocations and copying data during GC. This panel is for general information because it’s not easier to use other controller to get information about memory usage of the given instance.
<div style="margin: 10px 0;">
<img src="../images/posts/web-app-1/5.grafana-1.png" width="100%" style="inline"/>
</div></li>
<li>GC information:<br /> data that shows GC information that is provided by the runtime system. It provides total number of GCs and major GCs and their rate. Proportion of time spent in GC to the total running time, if this metric grows higher than 0.1 then it means that you are spending one tenth of your time in GCs and that is not good. Proportion of the time that capabilities spent synchronising to the time they did actual work, if this value grows high then you have problems.
<div style="margin: 10px 0;">
<img src="../images/posts/web-app-1/6.grafana-1.png" width="100%" style="inline"/>
</div>
In addition the structure of the heap is explained and we plot how many values of different types (from GC perspective) we have.
<div style="margin: 10px 0;">
<img src="../images/posts/web-app-1/7.grafana-1.png" width="100%" style="inline"/>
</div></li>
</ol>
<p>Config itself can be taken from <a href="https://raw.githubusercontent.com/qnikst/sample-site/master/deploy/docker/rts.json">GitHub</a>.</p>
<p>Unfortunately GC information tells us information about the last GC only so everything that had happened between scribe intervals will be missing from our data. In the next post I’m going to run some benchmarks of the application (and potentially introduce other endpoints) and discuss if missing information is actually a problem and what can be done about that.</p>]]></summary>
</entry>
<entry>
    <title>Metric a Haskell application</title>
    <link href="https://qnikst.github.io/posts/2018-09-29-metrics-haskell.html" />
    <id>https://qnikst.github.io/posts/2018-09-29-metrics-haskell.html</id>
    <published>2018-09-29T00:00:00Z</published>
    <updated>2018-09-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In one of my <a href="https://qnikst.github.io/posts/2018-08-23-ht-no-more.html">recept posts</a>, I’ve mentioned gathering metrics of my Haskell application. Some people asked me about my setup so I will try to describe how I configure and structure my applications.</p>
<p>I will try to split the description in a series of posts, in this one I’ll describe the general setup. After reading this post you’ll be able to set up the metrics system of your Haskell application (or suggest me how to do that better). At this point you’ll be able to get some information about your application and set up alerts based on that. In the following posts we will try to go deeper into each metric, check if those metrics are helpful, look if any pieces are missing and how that could be improved.</p>
<h2 id="haskell-and-metrics.">Haskell and metrics.</h2>
<p>Let’s spend a bit of time defining the problem we want to solve and describing its solution area. The purpose of a metrics system is to tell if your application is alive and behaves as expected. It should not give you more than statistical information about your application. We can split information into two categories:</p>
<ol type="1">
<li>general information: memory use, runtime system statistics.</li>
<li>application specific information.</li>
</ol>
<p>The border line between those two is quite fuzzy: for example, you may have a general web-server statistics, like number of processed requests or time to reply which are application specific but applicable to any web-server. So I’d add them to the first group. But the main trap here is not to try to solve an incorrect problem; metrics may not work as an exact source of information. Nor could they be a mechanism for tracing or log server, you need other tools for thse purposes.</p>
<p>In the Haskell ecosystem, there are a few packages providing metrics support. The one that is the best known and has a long history is <a href="https://hackage.haskell.org/package/ekg-core">EKG</a> - this package offers few metrics types and a large variety of systems that you can integrate with. While EKG is generally a good generic solution, I found that some companies are trying to move from that package. (I was not able to gather concrete reports what was a problem with it, so I will try to avoid answering that question).</p>
<p>Otherwise we can take a specific solution that works great with a single system. In Tweag we’re used to use <a href="https://prometheus.io/">Prometheus</a>. With Prometheus you can dump your metrics to the well-maintained package that other people usually familiar with. Hackage offers an excellent library for working with Prometheus: <a href="https://hackage.haskell.org/package/prometheus-client">prometheus-client</a>. Even if you like EKG more or have projects that are using it you can use the adapter for EKG <a href="https://hackage.haskell.org/package/ekg-prometheus-adapter">ekg-prometheus-adapter</a>. I have not used that package myself but I hope that it just works, or at least it could be easily fixed.</p>
<h2 id="setup.">Setup.</h2>
<p>For an application setup I’m going to use Docker compose. With this approach we will be able to cover all the details and this approach may be adapted to a more complex system like Kubernetes.</p>
<p>Let’s start writing docker compose files. I omitted all irrelevant links and configuration.</p>
<pre class="docker"><code>version: &quot;3&quot;
services:

  haskell-app:
    image: &lt;your-image&gt;
    ports:
    - &#39;8080:8080&#39;

  node_exporter:
    image: prom/node-exporter
    expose:
      - 9100
  
  prometheus:
    image: prom/prometheus:latest
    volumes:
    - ./config/prometheus:/etc/prometheus
    - prometheus_data:/prometheus
    command:
    - &#39;--config.file=/etc/prometheus/prometheus.yml&#39;
    ports:
    - &#39;9090:9090&#39;
    links:
    - haskell-app
  grafana:
    image: grafana/grafana
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=XxXchangemeXxX
    depends_on:
      - prometheus
    ports:
      - &quot;3000:3000&quot;
    links:
      - prometheus
    volumes:
      - grafana_data:/var/lib/grafana
    user: &quot;104&quot;    

volumes:
  prometheus_data: {}
  grafana_data: {}</code></pre>
<p>Prometheus config:</p>
<pre class="docker"><code>global:
    scrape_interval: 5s
    external_labels:
      monitor: &#39;my-monitor&#39;
scrape_configs:
  - job_name: &#39;myapp&#39;
    static_configs:
      - targets: 
        - haskell-app:8080</code></pre>
<p>It’s possible to configure Grafana declaratively as well but as I don’t have a final solution that I can use out of the box on any system I tend to setup Grafana manually. Just log into your instance and go through the onboarding process.</p>
<p>Now we are ready to set up our Haskell application.</p>
<p>Setup of a Haskell application may be pretty simple. To dump GHC statistics you may use <a href="https://hackage.haskell.org/package/prometheus-metrics-ghc">prometheus-metrics-ghc</a>. To make the full use of this package you need to enable gathering of runtime statistics with:</p>
<pre class="cabal"><code>  build-depends: prometheus-metrics-ghc
  ghc-options: &quot;-with-rtsopts=-T&quot;</code></pre>
<p>Then add to your main:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">import</span>  <span class="dt">Prometheus</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">import</span>  <span class="dt">Prometheus.Metric.GHC</span></span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="ot">main  ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-5"><a href="#cb4-5"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>   register ghcMetrics</span></code></pre></div>
<p>At this point you gather RTS stats but you don’t export you metrics yet. To export your data you may want to use <a href="https://hackage.haskell.org/package/wai-middleware-prometheus">wai-middleware-prometheus</a>. This package allows you to provide metrics inside any <code>wai</code>/<code>warp</code> application.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">import</span> <span class="dt">Network.Wai.Middleware.Prometheus</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">import</span> <span class="dt">Prometheus</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">import</span> <span class="dt">Prometheus.Metric.GHC</span></span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a>main <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb5-6"><a href="#cb5-6"></a>   register ghcMetrics</span>
<span id="cb5-7"><a href="#cb5-7"></a>   Warp.run <span class="dv">9090</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>        <span class="op">$</span>   prometheus def</span>
<span id="cb5-9"><a href="#cb5-9"></a>              { prometheusInstrumentPrometheus  <span class="ot">=</span><span class="dt">False</span> }</span>
<span id="cb5-10"><a href="#cb5-10"></a>         <span class="op">$</span> yourApplication</span></code></pre></div>
<p>Or use <a href="https://hackage.haskell.org/package/wai-middleware-prometheus-1.0.0/docs/Network-Wai-Middleware-Prometheus.html#v:metricsApp">metricsApp</a> function if you don’t have any web application. And Prometheus will scrape that data from your application. At this point you’ll have some basic information about your endpoints and GC stats. And you can add your application-specific data using Prometheus interface.</p>
<p>We will cover interesting stats in the next posts but for now you may be interested in the following data:</p>
<ul>
<li><code>ghc_allocated_bytes_total</code> - to build a <code>rate</code> plot based on that metric</li>
<li><code>ghc_num_gcs</code> - to build a rate plot of GCs</li>
<li><code>ghc_mutator_wall_seconds_total/(ghc_mutator_wall_seconds_total+ghc_gc_wall_seconds_total)</code> - to understand the proportion of time spent in GC</li>
<li>information about memory usage split by the type of memory</li>
<li>and a number of metrics from <code>ghc_gcdetails</code> category. This data may not be very useful as it shows data since last GC, so you may report the same GC multiple times if no GC happened during the report period, or miss some reports if more that one GC happens.</li>
</ul>
<p>I hope that this information will be useful and will try to dig into concrete metrics examples in the following posts.</p>]]></summary>
</entry>
<entry>
    <title>Logging all exceptions in ghci</title>
    <link href="https://qnikst.github.io/posts/2015-04-30-grabbing-exceptions.html" />
    <id>https://qnikst.github.io/posts/2015-04-30-grabbing-exceptions.html</id>
    <published>2015-04-30T00:00:00Z</published>
    <updated>2015-04-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>On one resource there was a question how to log all exception in GHCI. There was a use case where user could start a background processes and some exceptions could be lost.</p>
<p>In a normal program you can use <code>-prof</code> compilation option and run program with <code>+RTS -xc</code> in order to get exceptions messages and stack-traces logged. However I assume that most of the ghc users doesn’t have <code>ghc</code> compiled with profiling flags. So we need to find another option.</p>
<p>And there is a solution. Every forked thread installs a exceptions handler:</p>
<p>From <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Conc-Sync.html#forkIO">GHC.Cons.Sym</a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">forkIO ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>forkIO action <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \ s <span class="ot">-&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>   <span class="kw">case</span> (fork<span class="op">#</span> action_plus s) <span class="kw">of</span> (<span class="op">#</span> s1, tid <span class="op">#</span>) <span class="ot">-&gt;</span> (<span class="op">#</span> s1, <span class="dt">ThreadId</span> tid <span class="op">#</span>)</span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="kw">where</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>      action_plus <span class="ot">=</span> catchException action childHandler</span></code></pre></div>
<p>From <a href="">GHC.IO</a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">{-</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">catchException used to handle the passing around of the state to the</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">action and the handler.  This turned out to be a bad idea - it meant</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">that we had to wrap both arguments in thunks so they could be entered</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">as normal (remember IO returns an unboxed pair...).</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co">Now catch# has type</span></span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="co">catch# :: IO a -&gt; (b -&gt; IO a) -&gt; IO a</span></span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co">(well almost; the compiler doesn&#39;t know about the IO newtype so we</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co">have to work around that in the definition of catchException below).</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="co">-}</span></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="ot">catchException ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span></code></pre></div>
<p>In order to set hander we can use:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">setUncaughtExceptionHandler ::</span> (<span class="dt">SomeException</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>In order to add something to ghci we can load a script by passing it with <code>-ghci-script</code> option</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="op">:</span>m <span class="dt">GHC.Conc.Sync</span> <span class="dt">Control.Exception</span></span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="op">:</span>{</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="kw">let</span><span class="ot"> uncaughtExceptionHandler ::</span> <span class="dt">SomeException</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb4-5"><a href="#cb4-5"></a>    uncaughtExceptionHandler e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>        <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Unhandled exception: &quot;</span> <span class="op">++</span> <span class="fu">show</span> e</span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="op">:</span>}</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a>setUncaughtExceptionHandler uncaughtExceptionHandler</span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="op">:</span>m <span class="op">-</span><span class="dt">GHC.Conc.Sync</span> <span class="dt">Control.Exception</span></span></code></pre></div>
<p>And load it with <code>ghci -ghci-script script.hs</code>.</p>
<pre><code>qnikst@localhost ~ $ ghci -ghci-script script.hs 
GHCi, version 7.8.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude&gt; :m +Control.Exception Control.Concurrent
Prelude Control.Exception Control.Concurrent&gt; forkIO $ threadDelay 10000 &gt;&gt; error &quot;yo!&quot;
ThreadId 28
Prelude Control.Exception Control.Concurrent&gt; Unhandled exception: yo!</code></pre>]]></summary>
</entry>
<entry>
    <title>Approaches to carry a proof for typelevel natural</title>
    <link href="https://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" />
    <id>https://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html</id>
    <published>2014-12-16T00:00:00Z</published>
    <updated>2014-12-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>For time ago Bas van Dijk asked a question on glasgow-haskell-users mailing list about <a href="https://www.haskell.org/pipermail/glasgow-haskell-users/2014-November/025451.html">proving the properties of type-level natural numbers obtained by user</a>. That lead to an interesting discussion, that you can read in the list archives.</p>
<p>The problem was that we want to impose a constraint on some typelevel natural and then read value from user and guarantee that we have that constraint. For such constraint we took (&lt;=255).</p>
<p>Here is a file that describe few approaches to solve this problem.</p>
<p>At first we need to use a HUGE list of pragmas.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="ot">{-# LANGUAGE ViewPatterns #-}</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span></code></pre></div>
<p>And relax compiler options a bit.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">{-# OPTIONS_GHC -ftype-function-depth=1024 #-}</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="ot">{-# OPTIONS_GHC -fcontext-stack=1024 #-}</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span> </span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">import</span> <span class="dt">Data.Constraint</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="kw">import</span> <span class="dt">Data.Type.Bool</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">import</span> <span class="dt">System.Environment</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="kw">import</span> <span class="dt">Unsafe.Coerce</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="kw">import</span> <span class="dt">Data.Singletons</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span></code></pre></div>
<h2 id="attempt-1-tagged-value">Attempt-1: Tagged value</h2>
<p>We can keep a proof together with value, so we can introduce a new type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">Proof</span> n  (<span class="ot">c ::</span> <span class="dt">Constraint</span>) <span class="kw">where</span> <span class="dt">Proof</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof</span> n c</span></code></pre></div>
<p>In mailing list I provide following code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">fromSomeError ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof</span> n (n <span class="op">&lt;=</span> <span class="dv">255</span>))</span>
<span id="cb4-2"><a href="#cb4-2"></a>fromSomeError (<span class="dt">SomeNat</span> p)</span>
<span id="cb4-3"><a href="#cb4-3"></a>   <span class="op">|</span> natVal p <span class="op">&lt;=</span> <span class="dv">255</span> <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Proof</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n))</span>
<span id="cb4-4"><a href="#cb4-4"></a>   <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>This is obviously a bug as we check natVal p, but return Proxy n. And correct version fails, as there is no way to simply inject a constraint.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">{-</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co">fromSome :: SomeNat -&gt; Maybe (Proof n (n &lt;= 255))</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">fromSome (SomeNat p)</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co">  | natVal p &lt;= 255 = Just (Proof p)</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">  | otherwise = Nothing</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">-}</span></span></code></pre></div>
<pre><code> Proof.lhs:53:37:
    Could not deduce (n1 ~ n)
    from the context (KnownNat n1)
    bound by a pattern with constructor
        SomeNat :: forall (n :: Nat). KnownNat n =&gt; Proxy n -&gt; SomeNat,
	in an equation for ‘fromSome’
	at Proof.lhs:52:13-21</code></pre>
<h2 id="attempt-2-type-carrier">Attempt-2: Type carrier</h2>
<p>Now we want to have the following constraint on out Nat</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">data</span> <span class="dt">Proof2</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="dt">Proof2</span><span class="ot"> ::</span> c n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c</span></code></pre></div>
<p>In order to have a ‘curried’ version of our constaint we can introduce a type family</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">LessThan255</span><span class="ot"> n ::</span> <span class="dt">Constraint</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="dt">LessThan255</span> f <span class="ot">=</span> (f <span class="op">&lt;=</span> <span class="dv">255</span>)</span></code></pre></div>
<p>Now lets try to create a proof from known natural:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">{-</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co">strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co">strange = Proof2</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co">-}</span></span></code></pre></div>
<p>~~~~~~~~~~~~~~~ Proof.lhs:89:13: Could not deduce (LessThan255 n) arising from a use of ‘Proof2’ from the context (LessThan255 n) bound by the type signature for strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255 ~~~~~~~~~~~~~~</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">strange ::</span> (<span class="dt">LessThan255</span> <span class="op">~</span> c, c n) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c</span>
<span id="cb10-2"><a href="#cb10-2"></a>strange <span class="ot">=</span> <span class="dt">Proof2</span></span></code></pre></div>
<p>Previous attempt to build function failed, but this one works. I don’t know if it’s related to non-injectivity or a bug.. I can report it :)</p>
<p>When I realized this problem, I have stopped.</p>
<p>Update. As Richard Eisenberg says:</p>
<pre><code>By the way, the bug in the Proof2 version is a bug in GHC 7.8.3
(only in .3 -- not in .2 or in the soon-to-be .4) that allows you
to write unsaturated type families that don&#39;t work.
Saying `LessThan255` without a parameter should be a syntax error,
but that check was accidentally turned off for 7.8.3, leading to a bogus type error.</code></pre>
<h2 id="attempt-3-carry-a-contraint-in-a-datatype">Attempt-3: carry a contraint in a datatype</h2>
<p>Now let’s keep our ‘constraint’ in a datatype, here we have 2 proxy, one for datatype, and one for value, also a KnownNat constraint that we want to use later:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">data</span> <span class="dt">Proof3</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>  <span class="dt">Proof3</span><span class="ot"> ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c</span></code></pre></div>
<p>We can introduce a Show instance</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Proof3</span> c) <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="fu">show</span> (<span class="dt">Proof3</span> _ k) <span class="ot">=</span> <span class="fu">show</span> <span class="op">$</span> natVal k</span></code></pre></div>
<p>And now we can introduce a LessThen constraint as a datatype:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">data</span> <span class="dt">LessThan255D</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="kw">where</span> <span class="dt">LessThan255D</span><span class="ot"> ::</span> (n <span class="op">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">LessThan255D</span> n</span></code></pre></div>
<p>We can convert type level constrant to data easily:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">c2d ::</span> <span class="dt">LessThan255</span> n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">LessThan255D</span> n</span>
<span id="cb15-2"><a href="#cb15-2"></a>c2d _ <span class="ot">=</span> <span class="dt">LessThan255D</span></span></code></pre></div>
<p>But what about a proof, ideally we want to have following code:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="co">{-</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="co">fromSome3 :: SomeNat -&gt; Maybe (Proof3 LessThan255D)</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co">fromSome3 (SomeNat p)</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="co">   | natVal p &lt; natVal t255 = Just (Proof3 LessThan255D p)</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="co">   | otherwise = Nothing</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="co">   where t255 = Proxy :: Proxy 255</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="co">-}</span></span></code></pre></div>
<pre><code>Proof.lhs:138:46:
  Could not deduce ((n &lt;=? 255) ~ &#39;True)
  from the context (KnownNat n)</code></pre>
<p>It doesn’t work simply because value level check doesn’t guarantee typelevel properties.</p>
<p>One way to solve it is to use unsafeCoerce: the idea is to use a proof for the value we know, and then coerce a type of a proof to the type of the proof related to the users value:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="ot">fromSome3 ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</span>
<span id="cb18-2"><a href="#cb18-2"></a>fromSome3 (<span class="dt">SomeNat</span> p)</span>
<span id="cb18-3"><a href="#cb18-3"></a>   <span class="op">|</span> natVal p <span class="op">&lt;</span> natVal t255 <span class="ot">=</span> <span class="dt">Just</span> (fake (c2d t255) p)</span>
<span id="cb18-4"><a href="#cb18-4"></a>   <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>   <span class="kw">where</span> t255 <span class="ot">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="ot">         fake ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c p <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c</span>
<span id="cb18-7"><a href="#cb18-7"></a>         fake k p <span class="ot">=</span> <span class="dt">Proof3</span> (unsafeCoerce<span class="ot"> k ::</span> c n) p</span></code></pre></div>
<p>It’s a nice solution, it’s unsafe as typechecker does not check that our predicate <code>(natVal (p::Proxy n) &lt; natVal (t255::Proxy 255))</code> implies the safety of a coerce from <code>LessThan255 ~ 255 -&gt; LessThan255 ~ p</code>.</p>
<p>There is one more solution that is really typesafe, but has a big complexity, and require a bounded set of values:</p>
<p>We can try to check is equal to one specific value from the set.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">guessProof ::</span> (<span class="dt">KnownNat</span> n, n <span class="op">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</span>
<span id="cb19-2"><a href="#cb19-2"></a>guessProof (<span class="dt">SomeNat</span> p) n <span class="ot">=</span> <span class="kw">case</span> sameNat p n <span class="kw">of</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="dt">Just</span> _  <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> n</span>
<span id="cb19-4"><a href="#cb19-4"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>Now we can build all set of values that are good:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Guesses</span> (<span class="ot">n::</span><span class="dt">Nat</span>)<span class="ot"> ::</span> [<span class="dt">Nat</span>] <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>   <span class="dt">Guesses</span> <span class="dv">0</span> <span class="ot">=</span> &#39;[<span class="dv">0</span>]</span>
<span id="cb20-3"><a href="#cb20-3"></a>   <span class="dt">Guesses</span> n <span class="ot">=</span> n &#39;<span class="op">:</span> <span class="dt">Guesses</span> (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>And write a code that will check all possible values:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">class</span> <span class="dt">GuessProof</span> (<span class="ot">n ::</span> [<span class="dt">Nat</span>]) <span class="kw">where</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="ot">  proof ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</span>
<span id="cb21-3"><a href="#cb21-3"></a></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="kw">instance</span> <span class="dt">GuessProof</span> &#39;[] <span class="kw">where</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>  proof _ _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb21-6"><a href="#cb21-6"></a></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="kw">instance</span> (<span class="dt">KnownNat</span> n, n <span class="op">&lt;=</span> <span class="dv">255</span>, <span class="dt">GuessProof</span> ns) <span class="ot">=&gt;</span> <span class="dt">GuessProof</span> (n &#39;<span class="op">:</span> ns) <span class="kw">where</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>  proof s p <span class="ot">=</span> guessProof s (inner p) <span class="ot">`mplus`</span> proof s (next p)</span>
<span id="cb21-9"><a href="#cb21-9"></a>   <span class="kw">where</span><span class="ot"> inner ::</span> <span class="dt">Proxy</span> (n &#39;<span class="op">:</span> ns) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="ot">n::</span><span class="dt">Nat</span>)</span>
<span id="cb21-10"><a href="#cb21-10"></a>         inner _ <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="ot">         next ::</span> <span class="dt">Proxy</span> (n &#39;<span class="op">:</span> ns) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="ot">ns::</span>[<span class="dt">Nat</span>])</span>
<span id="cb21-12"><a href="#cb21-12"></a>         next _ <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>It’s not very usable, have a bad complexity and require to change ghc options but it works and it’s safe.</p>
<p>Now let’s test our code:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="ot">f2 ::</span> (c <span class="op">~</span> (n <span class="op">&lt;=</span> <span class="dv">255</span>)) <span class="ot">=&gt;</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb22-2"><a href="#cb22-2"></a>f2 (<span class="dt">Proof3</span> n p) <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> natVal p</span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="ot">test1 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb23-2"><a href="#cb23-2"></a>test1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></span>
<span id="cb23-4"><a href="#cb23-4"></a></span>
<span id="cb23-5"><a href="#cb23-5"></a>    <span class="kw">case</span> someNatVal n <span class="kw">of</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Input is not a natural number!&quot;</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>      <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> fromSome3 sn <span class="kw">of</span></span>
<span id="cb23-8"><a href="#cb23-8"></a>                   <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p</span>
<span id="cb23-9"><a href="#cb23-9"></a>                   _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Input if larger than 255&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="ot">test2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb24-2"><a href="#cb24-2"></a>test2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>  n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>  <span class="kw">case</span> someNatVal n <span class="kw">of</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Input is not a natural number!&quot;</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>      <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> proof sn (g (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span>)) <span class="kw">of</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>                   <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p</span>
<span id="cb24-8"><a href="#cb24-8"></a>                   _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Input if larger than 255&quot;</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>  <span class="kw">where</span></span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="ot">    g ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="dt">Guesses</span> n)</span>
<span id="cb24-11"><a href="#cb24-11"></a>    g _ <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<h2 id="attempt-5-singletons">Attempt 5: Singletons</h2>
<p>This is not the only solution, one more solution was provided by Richard Eisenberg I have not found it in mailing list archives so including it here.</p>
<p>The idea is that we may use less effective representation for typelevel naturals, i.e. unary naturals we can build a proof using singletons:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell, DataKinds, PolyKinds, TypeFamilies,</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="ot">             ScopedTypeVariables, TypeOperators, UndecidableInstances,</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="ot">             GADTs, RankNTypes #-}</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="ot">{-# OPTIONS_GHC -ftype-function-depth=300 -fcontext-stack=300 #-}</span></span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="kw">import</span> <span class="dt">Data.Singletons.TH</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> <span class="kw">hiding</span> ( <span class="dt">Nat</span> )</span>
<span id="cb25-8"><a href="#cb25-8"></a></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="op">$</span>(singletons [d|</span>
<span id="cb25-10"><a href="#cb25-10"></a>  data Nat = Zero | Succ Nat</span>
<span id="cb25-11"><a href="#cb25-11"></a></span>
<span id="cb25-12"><a href="#cb25-12"></a>  leNat :: Nat -&gt; Nat -&gt; Bool</span>
<span id="cb25-13"><a href="#cb25-13"></a>  leNat Zero     _        = True</span>
<span id="cb25-14"><a href="#cb25-14"></a>  leNat (Succ _) Zero     = False</span>
<span id="cb25-15"><a href="#cb25-15"></a>  leNat (Succ a) (Succ b) = a `leNat` b</span>
<span id="cb25-16"><a href="#cb25-16"></a>  |])</span>
<span id="cb25-17"><a href="#cb25-17"></a></span>
<span id="cb25-18"><a href="#cb25-18"></a><span class="co">-- | Singletons&#39;s &#39;withSomeSing&#39; is what we want, but a bug in 7.8.3 doesn&#39;t</span></span>
<span id="cb25-19"><a href="#cb25-19"></a><span class="co">-- let it work without a specialized type for &#39;Nat&#39;s</span></span>
<span id="cb25-20"><a href="#cb25-20"></a><span class="ot">withSomeNat ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> (<span class="kw">forall</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="op">.</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb25-21"><a href="#cb25-21"></a>withSomeNat <span class="ot">=</span> withSomeSing</span>
<span id="cb25-22"><a href="#cb25-22"></a></span>
<span id="cb25-23"><a href="#cb25-23"></a><span class="co">-- | Conveniently generate unary naturals</span></span>
<span id="cb25-24"><a href="#cb25-24"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">U</span> n <span class="kw">where</span></span>
<span id="cb25-25"><a href="#cb25-25"></a>  <span class="dt">U</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb25-26"><a href="#cb25-26"></a>  <span class="dt">U</span> n <span class="ot">=</span> <span class="dt">Succ</span> (<span class="dt">U</span> (n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb25-27"><a href="#cb25-27"></a></span>
<span id="cb25-28"><a href="#cb25-28"></a><span class="ot">toNat ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Nat</span></span>
<span id="cb25-29"><a href="#cb25-29"></a>toNat n <span class="op">|</span> n <span class="op">&lt;</span> <span class="dv">0</span>      <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb25-30"><a href="#cb25-30"></a>        <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go n</span>
<span id="cb25-31"><a href="#cb25-31"></a>  <span class="kw">where</span></span>
<span id="cb25-32"><a href="#cb25-32"></a>    go <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb25-33"><a href="#cb25-33"></a>    go n <span class="ot">=</span> <span class="dt">Succ</span> (go (n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb25-34"><a href="#cb25-34"></a></span>
<span id="cb25-35"><a href="#cb25-35"></a><span class="kw">type</span> <span class="dt">Bound</span> <span class="ot">=</span> <span class="dt">U</span> <span class="dv">255</span></span>
<span id="cb25-36"><a href="#cb25-36"></a></span>
<span id="cb25-37"><a href="#cb25-37"></a><span class="co">-- easier to test in GHCi than a proper &#39;main&#39;</span></span>
<span id="cb25-38"><a href="#cb25-38"></a><span class="ot">go ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb25-39"><a href="#cb25-39"></a>go n <span class="ot">=</span></span>
<span id="cb25-40"><a href="#cb25-40"></a>   <span class="kw">case</span> toNat n <span class="kw">of</span></span>
<span id="cb25-41"><a href="#cb25-41"></a>     <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;Input is not a natural number!&quot;</span></span>
<span id="cb25-42"><a href="#cb25-42"></a>     <span class="dt">Just</span> nat <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="op">$</span> withSomeNat nat <span class="op">$</span> \ snat <span class="ot">-&gt;</span></span>
<span id="cb25-43"><a href="#cb25-43"></a>       <span class="kw">case</span> snat <span class="ot">`sLeNat`</span> (<span class="ot">sing ::</span> <span class="dt">Sing</span> <span class="dt">Bound</span>) <span class="kw">of</span></span>
<span id="cb25-44"><a href="#cb25-44"></a>         <span class="dt">STrue</span>  <span class="ot">-&gt;</span> f snat</span>
<span id="cb25-45"><a href="#cb25-45"></a>         <span class="dt">SFalse</span> <span class="ot">-&gt;</span> <span class="st">&quot;Didn&#39;t work&quot;</span></span>
<span id="cb25-46"><a href="#cb25-46"></a></span>
<span id="cb25-47"><a href="#cb25-47"></a><span class="ot">f ::</span> <span class="kw">forall</span> proxy (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="op">.</span> (n <span class="ot">`LeNat`</span> <span class="dt">Bound</span>) <span class="op">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> proxy n <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb25-48"><a href="#cb25-48"></a>f _ <span class="ot">=</span> <span class="st">&quot;It worked!&quot;</span></span></code></pre></div>
<h2 id="attempt-6-using-luquid-haskell">Attempt 6: Using Luquid haskell</h2>
<p>Ranjit Jhala, provided a great solution for liquid haskell, that could be found either by <a href="http://goto.ucsd.edu:8090/index.html#?demo=permalink%2F1418064183.hs">url</a> or here:</p>
<hr />
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="co">{-@ LIQUID &quot;--no-termination&quot; @-}</span></span>
<span id="cb26-3"><a href="#cb26-3"></a></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="kw">module</span> <span class="dt">Nat255</span> <span class="kw">where</span></span>
<span id="cb26-5"><a href="#cb26-5"></a></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="co">-- | Define a predicate for valid integers</span></span>
<span id="cb26-7"><a href="#cb26-7"></a></span>
<span id="cb26-8"><a href="#cb26-8"></a><span class="co">{-@ predicate IsValid X = 0 &lt;= X &amp;&amp; X &lt; 255 @-}</span></span>
<span id="cb26-9"><a href="#cb26-9"></a></span>
<span id="cb26-10"><a href="#cb26-10"></a><span class="co">-- | Use the predicate to define a refinement type (subset) of valid integers</span></span>
<span id="cb26-11"><a href="#cb26-11"></a></span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="co">{-@ type Valid = {v:Int | IsValid v}        @-}</span></span>
<span id="cb26-13"><a href="#cb26-13"></a></span>
<span id="cb26-14"><a href="#cb26-14"></a><span class="co">-- | A function that checks whether a given Int is indeed valid</span></span>
<span id="cb26-15"><a href="#cb26-15"></a></span>
<span id="cb26-16"><a href="#cb26-16"></a><span class="co">{-@ isValid   :: n:Int -&gt; {v:Bool | Prop v &lt;=&gt; IsValid n} @-}</span></span>
<span id="cb26-17"><a href="#cb26-17"></a>isValid n     <span class="ot">=</span> <span class="dv">0</span> <span class="op">&lt;=</span> n <span class="op">&amp;&amp;</span> n <span class="op">&lt;</span> (<span class="dv">255</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb26-18"><a href="#cb26-18"></a></span>
<span id="cb26-19"><a href="#cb26-19"></a><span class="co">-- | A function that can only be called with Valid Ints.</span></span>
<span id="cb26-20"><a href="#cb26-20"></a></span>
<span id="cb26-21"><a href="#cb26-21"></a><span class="co">{-@ workWithValidNumber :: Valid -&gt; IO () @-}</span> </span>
<span id="cb26-22"><a href="#cb26-22"></a>workWithValidNumber n <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;This is a valid number&quot;</span> <span class="op">++</span> <span class="fu">show</span> (<span class="ot">n ::</span> <span class="dt">Int</span>)</span>
<span id="cb26-23"><a href="#cb26-23"></a></span>
<span id="cb26-24"><a href="#cb26-24"></a><span class="co">-- | This is fine...</span></span>
<span id="cb26-25"><a href="#cb26-25"></a>ok    <span class="ot">=</span> workWithValidNumber <span class="dv">12</span></span>
<span id="cb26-26"><a href="#cb26-26"></a></span>
<span id="cb26-27"><a href="#cb26-27"></a><span class="co">-- | ... But this is not.        </span></span>
<span id="cb26-28"><a href="#cb26-28"></a>notOk <span class="ot">=</span> workWithValidNumber <span class="dv">257</span></span>
<span id="cb26-29"><a href="#cb26-29"></a></span>
<span id="cb26-30"><a href="#cb26-30"></a><span class="co">-- | Finally the top level loop that inputs a number, tests it </span></span>
<span id="cb26-31"><a href="#cb26-31"></a><span class="co">--   and calls `workWithValidNumber` if the number is valid.</span></span>
<span id="cb26-32"><a href="#cb26-32"></a></span>
<span id="cb26-33"><a href="#cb26-33"></a>loop <span class="ot">=</span> <span class="kw">do</span> <span class="fu">putStrLn</span> <span class="st">&quot;Enter Number between 0 and 255&quot;</span></span>
<span id="cb26-34"><a href="#cb26-34"></a>          n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb26-35"><a href="#cb26-35"></a>          <span class="kw">if</span> isValid n</span>
<span id="cb26-36"><a href="#cb26-36"></a>             <span class="kw">then</span> workWithValidNumber n</span>
<span id="cb26-37"><a href="#cb26-37"></a>             <span class="kw">else</span> <span class="fu">putStrLn</span> <span class="st">&quot;Humph, bad input, try again!&quot;</span> <span class="op">&gt;&gt;</span> loop</span></code></pre></div>
<p>I hope you have enjoyed reading this.</p>]]></summary>
</entry>
<entry>
    <title>Compositional methods for numerical ODE integrators</title>
    <link href="https://qnikst.github.io/posts/2014-08-18-compositional-methods.html" />
    <id>https://qnikst.github.io/posts/2014-08-18-compositional-methods.html</id>
    <published>2014-08-18T00:00:00Z</published>
    <updated>2014-08-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>We show a way to improve properties of a ODE integrators, by introducing a composition of the methods with a different steps.</p>
<!--more-->
<p>This post is based on the work of the Ernst Harrier [<a href="http://www.springer.com/mathematics/computational+science+%26+engineering/book/978-3-540-30663-4">1</a>] and doesn’t contain any additional research work.</p>
<p>Here we want to solve a system of equations that can we written as:</p>
<p><span class="math display">\[ \dot{y} = f(y). \]</span></p>
<p>In order to solve it we are introducing a mapping from an old state at <span class="math inline">\(t0\)</span> to a new one at <span class="math inline">\(t_1 = t_0 + dt\)</span>:</p>
<p><span class="math display">\[\Phi_h: y_{n} \rightarrow  y_{n+1}\]</span></p>
<p>In order to increase the order of the solution while preserving some desirable properties of the base method we may prepare a compositional method:</p>
<p><span class="math display">\[\Psi_h = \Phi_{\gamma_1h} \circ \ldots \circ \Phi_{\gamma_nh},\]</span></p>
<p>where <span class="math inline">\(\gamma_i\)</span> is a coefficient from <span class="math inline">\(\mathbb R\)</span>. This approach was studied by Suzuki, Yoshina, McLackcan in 1990th. Here we compose a base method at a different points in time.</p>
<p>We have a theorem about this approach to compositional methods.</p>
<p><em>Theorem</em></p>
<blockquote>
<p>Let <span class="math inline">\(\Phi_h\)</span> be a one-step method of order <span class="math inline">\(p\)</span>. If</p>
<p><span class="math display">\[
\begin{eqnarray}
\gamma_1 + \ldots + \gamma_s = 1 \\
\gamma_1^{p+1} + \ldots + \gamma_s^{p+1} = 0 \\
\end{eqnarray}
\]</span> then the compositional method <span class="math inline">\(\Psi_h\)</span> is at least of the order <span class="math inline">\(p+1\)</span>.</p>
</blockquote>
<p>This gives theorem gives us a nice way to improve properties of the existing method. The question now is how to find a good coefficients <span class="math inline">\(\gamma_i\)</span>.</p>
<p>The first notice is that equations does not have a real solution for the odd <span class="math inline">\(p\)</span>, so we can improve only solutions with even <span class="math inline">\(p\)</span>.</p>
<p>The smallest number <span class="math inline">\(s\)</span> where a solution in reals exists is <span class="math inline">\(3\)</span>. And coefficients are defined as:</p>
<p><span class="math display">\[ \gamma_1 = \gamma_3 = \frac{1}{2 - 2^{\frac{1}{p+1}}} \]</span></p>
<p><span class="math display">\[ \gamma_2 = - \frac{2^{\frac{1}{p+1}}}{2 - 2^{\frac{1}{p+1}}} \]</span></p>
<p>This method is called tripple jump. Lets check how does it work.</p>
<p>At first we will introduce a coefficients</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">g1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>g1 p <span class="ot">=</span>  <span class="dv">1</span> <span class="op">/</span> (<span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>(<span class="fu">fromIntegral</span> p<span class="op">+</span><span class="dv">1</span>)))</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="ot">g2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>g2 p <span class="ot">=</span> <span class="op">-</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>(<span class="fu">fromIntegral</span> p<span class="op">+</span><span class="dv">1</span>)) <span class="op">/</span> ( <span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>(<span class="fu">fromIntegral</span> p<span class="op">+</span><span class="dv">1</span>)))</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="ot">g3 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>g3 <span class="ot">=</span> g1</span></code></pre></div>
<p>Having a method of an order 2 (for example standard Runge-Kutta method) we may use a composition a points defined by <span class="math inline">\(\gamma_i\)</span> with <span class="math inline">\(p=2\)</span>. Let step be a <span class="math inline">\(dt = 1\)</span> for simplicity.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="op">&gt;</span><span class="ot"> t ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="op">&gt;</span> t p dt <span class="ot">=</span> <span class="fu">map</span> (<span class="op">*</span>dt) [g1 p, g2 p, g3 p]</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> t <span class="dv">2</span> <span class="dv">1</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>[<span class="fl">1.3512071919596578</span>,<span class="op">-</span><span class="fl">1.7024143839193153</span>,<span class="fl">1.3512071919596578</span>]</span></code></pre></div>
<p>We have 3 points. If we will take a compositional method <span class="math inline">\(\Psi\)</span> in the points we got then we will have a method of order <span class="math inline">\(3\)</span>. However if you method is symmetric then it’s order is <span class="math inline">\(4\)</span> and we can apply a tripple jump once again to our composed method.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="op">&gt;</span><span class="ot"> ut ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="op">&gt;</span> ut p xs <span class="ot">=</span> xs <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> t (p<span class="op">+</span><span class="dv">2</span>) x)</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> ut <span class="dv">4</span> (t <span class="dv">2</span> <span class="dv">1</span>)</span>
<span id="cb3-5"><a href="#cb3-5"></a>[<span class="fl">1.5081944151591316</span>,<span class="op">-</span><span class="fl">1.665181638358605</span>,<span class="fl">1.5081944151591316</span>,<span class="op">-</span><span class="fl">1.900205890992877</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>,<span class="fl">2.097997398066439</span>,<span class="op">-</span><span class="fl">1.900205890992877</span>,<span class="fl">1.5081944151591316</span>,<span class="op">-</span><span class="fl">1.665181638358605</span>,<span class="fl">1.5081944151591316</span>]</span></code></pre></div>
<p>This is a coefficients for a compositional method of order <span class="math inline">\(5\)</span>, (<span class="math inline">\(6\)</span> due to symmetry. Applying tripple jump nce again:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> ut <span class="dv">6</span> \<span class="op">$</span> ut <span class="dv">4</span> (t <span class="dv">2</span> <span class="dv">1</span>)</span>
<span id="cb4-2"><a href="#cb4-2"></a>[<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">1.77070200653487</span>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">1.8100975778074668</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>,<span class="fl">1.955013517256328</span>,<span class="op">-</span><span class="fl">1.8100975778074668</span>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">1.77070200653487</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">2.0655753110586246</span>,<span class="fl">2.2309447311243717</span>,<span class="op">-</span><span class="fl">2.0655753110586246</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>,<span class="fl">2.2805800406433505</span>,<span class="op">-</span><span class="fl">2.4631626832202618</span>,<span class="fl">2.2805800406433505</span>,<span class="op">-</span><span class="fl">2.0655753110586246</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>,<span class="fl">2.2309447311243717</span>,<span class="op">-</span><span class="fl">2.0655753110586246</span>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">1.77070200653487</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">1.8100975778074668</span>,<span class="fl">1.955013517256328</span>,<span class="op">-</span><span class="fl">1.8100975778074668</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">1.77070200653487</span>,<span class="fl">1.639448210847001</span>]</span></code></pre></div>
<p>this is a compositional method of order 8.</p>
<p>To see a places where function will be evaluated we can use:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> <span class="fu">scanl</span> (<span class="op">+</span>) <span class="dv">0</span> <span class="op">$</span> ut <span class="dv">6</span> <span class="op">$</span> ut <span class="dv">4</span> (t <span class="dv">2</span> <span class="dv">1</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a>[<span class="fl">0.0</span>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">0.131253795687869</span>,<span class="fl">1.508194415159132</span>,<span class="op">-</span><span class="fl">0.30190316264833483</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>,<span class="fl">1.6531103546079933</span>,<span class="op">-</span><span class="fl">0.15698722319947356</span>,<span class="fl">1.4824609876475274</span>,<span class="op">-</span><span class="fl">0.28824101888734255</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>,<span class="fl">1.3512071919596584</span>,<span class="op">-</span><span class="fl">0.7143681190989661</span>,<span class="fl">1.5165766120254056</span>,<span class="op">-</span><span class="fl">0.548998699033219</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>,<span class="fl">1.7315813416101316</span>,<span class="op">-</span><span class="fl">0.7315813416101302</span>,<span class="fl">1.5489986990332203</span>,<span class="op">-</span><span class="fl">0.5165766120254043</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>,<span class="fl">1.7143681190989675</span>,<span class="op">-</span><span class="fl">0.3512071919596571</span>,<span class="fl">1.2882410188873439</span>,<span class="op">-</span><span class="fl">0.4824609876475261</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>,<span class="fl">1.156987223199475</span>,<span class="op">-</span><span class="fl">0.6531103546079919</span>,<span class="fl">1.3019031626483362</span>,<span class="op">-</span><span class="fl">0.5081944151591307</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>,<span class="fl">1.1312537956878703</span>,<span class="op">-</span><span class="fl">0.6394482108469997</span>,<span class="fl">1.0000000000000013</span>]</span></code></pre></div>
<p>This way we may obtain a method of any order by the price of a terrible zig-zag of the step points.</p>
<p>Another approach to a compositional method is using Suzuki`s Fractals.</p>
<p>The same schema exists for Suzuki`s Fractals, however how we have a diffierent coefficients:</p>
<p><span class="math display">\[
\begin{eqnarray}
  \gamma_1 = \gamma_2 = \gamma_4 = \gamma_5 = \frac{1}{4-4^{\frac{1}{p+1}}} \\
  \gamma_3 = - \frac{4^{\frac{1}{p+1}}}{4-4^{\frac{1}{p+1}}}
\end{eqnarray}
\]</span></p>
<p>However <span class="math inline">\(t\)</span> and <span class="math inline">\(ut\)</span> methods looks quite ugly and we may want to improve this situation.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)</span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb6-15"><a href="#cb6-15"></a></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="co">-- Coefficients</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="ot">g1 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>g1 p <span class="ot">=</span>  <span class="dv">1</span> <span class="op">/</span> (<span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>(<span class="fu">fromIntegral</span> p<span class="op">+</span><span class="dv">1</span>)))</span>
<span id="cb6-19"><a href="#cb6-19"></a></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="ot">g2 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>g2 p <span class="ot">=</span> <span class="op">-</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>(<span class="fu">fromIntegral</span> p<span class="op">+</span><span class="dv">1</span>)) <span class="op">/</span> ( <span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>(<span class="fu">fromIntegral</span> p<span class="op">+</span><span class="dv">1</span>)))</span>
<span id="cb6-22"><a href="#cb6-22"></a></span>
<span id="cb6-23"><a href="#cb6-23"></a><span class="ot">g3 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb6-24"><a href="#cb6-24"></a>g3 <span class="ot">=</span> g1</span>
<span id="cb6-25"><a href="#cb6-25"></a></span>
<span id="cb6-26"><a href="#cb6-26"></a><span class="co">-- Description of the method</span></span>
<span id="cb6-27"><a href="#cb6-27"></a><span class="kw">data</span> <span class="dt">RK2</span> <span class="ot">=</span> <span class="dt">RK2</span></span>
<span id="cb6-28"><a href="#cb6-28"></a></span>
<span id="cb6-29"><a href="#cb6-29"></a><span class="co">-- Description of the method order</span></span>
<span id="cb6-30"><a href="#cb6-30"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Order</span><span class="ot"> a ::</span> <span class="dt">Nat</span></span>
<span id="cb6-31"><a href="#cb6-31"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Order</span> <span class="dt">RK2</span> <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb6-32"><a href="#cb6-32"></a></span>
<span id="cb6-33"><a href="#cb6-33"></a><span class="co">-- Description of symmetric properties of the method</span></span>
<span id="cb6-34"><a href="#cb6-34"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">IsSymmetric</span><span class="ot"> a ::</span> <span class="dt">Constraint</span></span>
<span id="cb6-35"><a href="#cb6-35"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">IsSymmetric</span> <span class="dt">RK2</span> <span class="ot">=</span> ()</span>
<span id="cb6-36"><a href="#cb6-36"></a></span>
<span id="cb6-37"><a href="#cb6-37"></a><span class="co">-- One level composition</span></span>
<span id="cb6-38"><a href="#cb6-38"></a><span class="ot">buildComposePoints ::</span> <span class="kw">forall</span> p <span class="op">.</span> <span class="dt">KnownNat</span> (<span class="dt">Order</span> p)</span>
<span id="cb6-39"><a href="#cb6-39"></a>                   <span class="ot">=&gt;</span> p <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb6-40"><a href="#cb6-40"></a>buildComposePoints p dt <span class="ot">=</span> <span class="fu">map</span> (<span class="op">*</span>dt) [g1 o, g2 o, g3 o]</span>
<span id="cb6-41"><a href="#cb6-41"></a>  <span class="kw">where</span></span>
<span id="cb6-42"><a href="#cb6-42"></a>    o <span class="ot">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Order</span> p))</span>
<span id="cb6-43"><a href="#cb6-43"></a></span>
<span id="cb6-44"><a href="#cb6-44"></a><span class="co">-- Composition for the symmetric method</span></span>
<span id="cb6-45"><a href="#cb6-45"></a><span class="ot">buildComposePointsSym ::</span> <span class="kw">forall</span> p n <span class="op">.</span> (<span class="dt">UpdateCompose</span> (<span class="dt">Order</span> p <span class="op">+</span> <span class="dv">2</span>) n, <span class="dt">IsSymmetric</span> p, <span class="dt">KnownNat</span> (<span class="dt">Order</span> p), <span class="dt">KnownNat</span> n)</span>
<span id="cb6-46"><a href="#cb6-46"></a>                      <span class="ot">=&gt;</span> p <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb6-47"><a href="#cb6-47"></a>buildComposePointsSym p pn dt <span class="ot">=</span> update (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> ((<span class="dt">Order</span> p) <span class="op">+</span> <span class="dv">2</span>)) pn (buildComposePoints p dt)</span>
<span id="cb6-48"><a href="#cb6-48"></a></span>
<span id="cb6-49"><a href="#cb6-49"></a><span class="kw">class</span> <span class="dt">UpdateCompose</span> (<span class="ot">k ::</span> <span class="dt">Nat</span>) (<span class="ot">v::</span><span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb6-50"><a href="#cb6-50"></a><span class="ot">  update ::</span> <span class="dt">Proxy</span> k <span class="ot">-&gt;</span> <span class="dt">Proxy</span> v <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb6-51"><a href="#cb6-51"></a></span>
<span id="cb6-52"><a href="#cb6-52"></a><span class="kw">class</span> <span class="dt">UpdateComposeCase</span> (<span class="ot">leq ::</span> <span class="dt">Bool</span>) (<span class="ot">k ::</span> <span class="dt">Nat</span>) (<span class="ot">v ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb6-53"><a href="#cb6-53"></a><span class="ot">  updateCase ::</span> <span class="dt">Proxy</span> leq <span class="ot">-&gt;</span> <span class="dt">Proxy</span> k <span class="ot">-&gt;</span> <span class="dt">Proxy</span> v <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb6-54"><a href="#cb6-54"></a></span>
<span id="cb6-55"><a href="#cb6-55"></a><span class="kw">instance</span> <span class="dt">UpdateComposeCase</span> (k <span class="op">&lt;=?</span> v) k v <span class="ot">=&gt;</span> <span class="dt">UpdateCompose</span> k v <span class="kw">where</span></span>
<span id="cb6-56"><a href="#cb6-56"></a>  update <span class="ot">=</span> updateCase (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (k <span class="op">&lt;=?</span> v))</span>
<span id="cb6-57"><a href="#cb6-57"></a></span>
<span id="cb6-58"><a href="#cb6-58"></a><span class="kw">instance</span> <span class="dt">UpdateComposeCase</span> <span class="dt">False</span> k v <span class="kw">where</span></span>
<span id="cb6-59"><a href="#cb6-59"></a>  updateCase _ _ _ <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb6-60"><a href="#cb6-60"></a>  </span>
<span id="cb6-61"><a href="#cb6-61"></a><span class="kw">instance</span> (<span class="dt">KnownNat</span> k, <span class="dt">UpdateCompose</span> (k<span class="op">+</span><span class="dv">2</span>) v) <span class="ot">=&gt;</span> <span class="dt">UpdateComposeCase</span> <span class="dt">True</span> k v <span class="kw">where</span></span>
<span id="cb6-62"><a href="#cb6-62"></a>  updateCase _ k v ds <span class="ot">=</span> update (plus2 k) v (ds <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> <span class="fu">map</span> (<span class="op">*</span>x) [g1 o, g2 o, g3 o])</span>
<span id="cb6-63"><a href="#cb6-63"></a>    <span class="kw">where</span></span>
<span id="cb6-64"><a href="#cb6-64"></a>      o <span class="ot">=</span> natVal k</span>
<span id="cb6-65"><a href="#cb6-65"></a><span class="ot">      plus2 ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (n<span class="op">+</span><span class="dv">2</span>)</span>
<span id="cb6-66"><a href="#cb6-66"></a>      plus2 _ <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>]]></summary>
</entry>
<entry>
    <title>Formal Power series in haskell</title>
    <link href="https://qnikst.github.io/posts/2014-08-11-series.markdown.html" />
    <id>https://qnikst.github.io/posts/2014-08-11-series.markdown.html</id>
    <published>2014-08-12T00:00:00Z</published>
    <updated>2014-08-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Code and math in this post is done with the great help of Korolyov V. This post is written as a literate haskell file so it’s possible to copy it in a text file and run it in ghci. All sources can be found in <a href="https://github.com/qnikst/haskell-fun/tree/master/series">haskell-fun</a> repository.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">import</span> <span class="dt">Control.Monad.Fix</span></span></code></pre></div>
<p>We want to implement a with formal series expansion using haskell. Formal series can be expressed as follows:</p>
<p><span class="math display">\[ f(x) = \sum\limits_{i=0}^\infty a_ix^i \]</span></p>
<p>And also address a Taylor series as an example. For a function <span class="math inline">\(f\)</span> we can expand it an any given point <span class="math inline">\(x_0\)</span>, then:</p>
<p><span class="math display">\[ f(x) = f(x_0) + \sum_{k=1}\frac{f^{(k)}}{k!}(x-x_0)^k \]</span></p>
<p>Here we wanto to introduce a data structure that is capable for representation of such series. For such datastructure we have 2 main candidates:</p>
<ol type="1">
<li><p>List - a datastructure with two constructors that represent a possibly infinite single-linked list.</p></li>
<li><p>Stream - a datastructure with one constructor that represent an infinite stream of values.</p></li>
</ol>
<p>We may want to select a list because this way we may represent a finite series (as some functions have all coefficients equal to <span class="math inline">\(0\)</span> starting at some point, or if function diverge than all element will be represented as machine zero starting at some point). But we decide to use ‘Stream’ data type in order not to have a branching in functions.</p>
<p>It’s possible to use an existing library for <code>Stream</code> – <a href="https://hackage.haskell.org/package/Stream">Stream package</a>. However here we decide to implement our own data type for educational purposes. However if this module will grow to a real library the implementation likely will be changed to the one from the common package.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span> <span class="dt">S</span> a <span class="ot">=</span> <span class="dt">S</span> <span class="op">!</span>a (<span class="dt">S</span> a)</span></code></pre></div>
<p>## Instances</p>
<p>Having a data structure we may define a set of instances.</p>
<p>### Functor</p>
<p>Series is a Functor:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">S</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>   <span class="fu">fmap</span> f (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="dt">S</span> (f a) (<span class="fu">fmap</span> f x)</span></code></pre></div>
<p>An interesting note that <span class="math inline">\(fmap ~ (f :: a \to b)\)</span> moves a function that is represented by a serie from <span class="math inline">\(a \to a\)</span> to <span class="math inline">\(b \to b\)</span> that may not be a desired behaviour when <span class="math inline">\(a \neq b\)</span>.</p>
<p>### Num</p>
<p>In order to use series in calculations we need to define a <code>Num</code> instance. But befor we will introduce few helpers:</p>
<p>A product of scalar and series:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">(^*) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb4-2"><a href="#cb4-2"></a>(<span class="op">^*</span>) a <span class="ot">=</span> <span class="fu">fmap</span> (<span class="op">*</span>a)</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">(*^) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb5-2"><a href="#cb5-2"></a>(<span class="op">*^</span>) <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">^*</span>)</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">(/^) ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb6-2"><a href="#cb6-2"></a>(<span class="op">/^</span>) s a <span class="ot">=</span> <span class="fu">fmap</span> (<span class="op">/</span> a) s</span></code></pre></div>
<p>And pointwise product for future (see Library section for szipWith implementation):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">(^*^) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb7-2"><a href="#cb7-2"></a>(<span class="op">^*^</span>) <span class="ot">=</span> szipWith (<span class="op">*</span>)</span></code></pre></div>
<p>Now we may give a ‘Num’ instance:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Num</span> (<span class="dt">S</span> a) <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>  (<span class="dt">S</span> a x) <span class="op">+</span> (<span class="dt">S</span> b y) <span class="ot">=</span> <span class="dt">S</span> (a <span class="op">+</span> b) (x <span class="op">+</span> y)</span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="fu">abs</span> s <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">abs</span> s</span>
<span id="cb8-4"><a href="#cb8-4"></a>  <span class="fu">negate</span> s <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">negate</span> s</span>
<span id="cb8-5"><a href="#cb8-5"></a>  <span class="fu">signum</span> s <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">signum</span> s</span>
<span id="cb8-6"><a href="#cb8-6"></a>  (<span class="dt">S</span> a x) <span class="op">*</span> (<span class="dt">S</span> b y) <span class="ot">=</span> <span class="dt">S</span> (a <span class="op">*</span> b) (a <span class="op">^*</span> y <span class="op">+</span>  b <span class="op">^*</span> x <span class="op">+</span> <span class="dt">S</span> <span class="dv">0</span> (x <span class="op">*</span> y))</span>
<span id="cb8-7"><a href="#cb8-7"></a>  <span class="fu">fromInteger</span> x <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">fromInteger</span> x) <span class="dv">0</span></span></code></pre></div>
<p>Here are 2 tricky parts, first one is implementation of <code>*</code> second one is implementation of <code>fromInteger</code>. For <code>*</code> we need to think of an expansion like of polymonial, i.e. <span class="math inline">\(S a b = a + b \cdot p\)</span>. Then we can write the following:</p>
<p><span class="math display">\[
\begin{aligned}
 (S~a~x) \cdot (S~b~y) &amp;= (a + x p) \cdot (b + y p) = \\
  &amp;= (a b + a y p + b x p + x y p^2) = \\
  &amp;= S~(a b)~(a y + b x + x y p)     = \\
  &amp;= S~(a b)~(fmap~(*a)~y + fmap~(*b)~x + S~0~(x * y))
\end{aligned}
\]</span></p>
<p>There are 2 possible implementations for fromInteger:</p>
<ol type="1">
<li><p><code>fromInteger x = S (fromInteger x) (fromInteger x)</code></p></li>
<li><p><code>fromInteger x = S (fromInteger x) 0</code></p></li>
</ol>
<p>For <code>fromInteger</code> we need to select an implemention such that <span class="math inline">\(fromInteger 1 * a == a\)</span> <span class="math inline">\(fromInteger 0 + a = a\)</span> <span class="math inline">\(fromInteger 0 * a == 0\)</span> for any <span class="math inline">\(a\)</span>. So then we see that we can select only the second one, otherwise properties for <span class="math inline">\(1\)</span> will not hold.</p>
<p>### Fractional</p>
<p>Now we can add a simple Fractional instance.</p>
<p>We say that <span class="math inline">\((S\,b\,y) = \cfrac{1}{(S\, a\, x)}\)</span> iff <span class="math inline">\((S\, b\, y)\)</span> is the solution of equation <span class="math inline">\((S\,b\,y)\,\cdot\,(S\,a\,x) = 1\)</span>. So the following intance is the result of this system of equations:</p>
<p><span class="math display">\[
\begin{aligned}
  b_0 a_0 &amp; = 1,\\
  b_0 a_1 + b_1 a_0 &amp; = 0,\\
  b_0 a_2 + b_1 a_1 + a_2 a_0 &amp; = 0,\\
  \ldots
\end{aligned}
\]</span></p>
<p>These equations can be resursively solved by moving the last term from left-side convolutions to the right side, and dividing by <span class="math inline">\((-a_0)\)</span>. Moreover the rest of terms on the left are convolutions too, then as now series <span class="math inline">\(a\)</span> convolve with the tail of series <span class="math inline">\(b\)</span>. That fact may be used for compact of definition of recursive equations:</p>
<p><span class="math display">\[
\begin{aligned}
  b_0 &amp; = \cfrac{1}{a_0},\\
  b_i &amp; = \cfrac{-1}{a_0} \sum\limits_{j = 0}^{i - 1} b_{j} a_{j + 1}.
\end{aligned}
\]</span></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">instance</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Fractional</span> (<span class="dt">S</span> a) <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="fu">recip</span> (<span class="dt">S</span> a x) <span class="ot">=</span> fix <span class="op">$</span> <span class="fu">fmap</span> (<span class="op">/</span> (<span class="op">-</span>a)) <span class="op">.</span> <span class="dt">S</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">.</span> (<span class="op">*</span> x)</span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="fu">fromRational</span> x <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">fromRational</span> x) <span class="dv">0</span></span></code></pre></div>
<p>Formulas for composition and inversion. Only series with zeroed head can be composed or reversed. Composition is handled according to Horner’s method:</p>
<p><span class="math display">\[
\begin{aligned}
  f(x) &amp;= \sum\limits_{i=0}^{\infty} a_i x^i =
           a_0 + x \sum\limits_{i=0}^{\infty} a_{i+1} x^i,\\
  g(x) &amp;= \sum\limits_{j=1}^{\infty} b_j x^j =
           x \sum\limits_{j=0}^{\infty} b_{j+1} x^j, \\
  f(g(x)) &amp;= a_0 + g(x) \sum\limits_{i=0}^{\infty} a_{i+1} g(x)^i = \\
          &amp;= a_0 + x \left(\sum\limits_{j=0}^{\infty} b_{j+1} x^j\right)
              \left(\sum\limits_{i=0}^{\infty} a_{i+1} g(x)^i\right).
\end{aligned}
\]</span></p>
<p>The product of two series can be treated recursively, so:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">compose ::</span> (<span class="dt">Num</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb10-2"><a href="#cb10-2"></a>compose (<span class="dt">S</span> a x) (<span class="dt">S</span> <span class="dv">0</span> y) <span class="ot">=</span> <span class="dt">S</span> a (y <span class="op">*</span> compose x (<span class="dt">S</span> <span class="dv">0</span> y))</span>
<span id="cb10-3"><a href="#cb10-3"></a>compose _ _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;compose: Non-zero head&quot;</span></span></code></pre></div>
<p>Inversion can be done by the following formula:</p>
<p><span class="math display">\[
\begin{eqnarray}
  f(g(x)) &amp; = x, \\
  a_1 g(x) + a_2 g^2(x) + \ldots &amp; = x, \\
  g(x) (a_1 + a_2 g(x) + \ldots) &amp; = x, \\
  b_1 x + b_2 x^2 + \ldots &amp; = \cfrac{x}{a_1 + a_2 g(x) + \ldots}, \\
  b_1 + b_2 x + \ldots &amp; = \cfrac{1}{a_1 + a_2 g(x) + \ldots}.
\end{eqnarray}
\]</span></p>
<p>The last equality gives the recursive rule:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">inverse ::</span> (<span class="dt">Fractional</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb11-2"><a href="#cb11-2"></a>inverse (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> <span class="kw">let</span> y <span class="ot">=</span> <span class="dt">S</span> <span class="dv">0</span> (<span class="fu">recip</span> <span class="op">$</span> compose x y) <span class="kw">in</span> y</span>
<span id="cb11-3"><a href="#cb11-3"></a>inverse _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;inverse: Non-zero head&quot;</span></span></code></pre></div>
<p>According to general theory elementary special functions cannot be evaluated on the non-zero headed series. We try to handle this situaton by breaking the series into two parts: the head and the zero-headed tail.</p>
<p>The head is treated by classic functions, the tail is treated by composing argument series with classical series of elementary functions, and the combination is done by ad-hoc formulas. The first example of the ad-hoc formula:</p>
<p><span class="math display">\[
\begin{eqnarray}
  \sin \sum\limits_{i = 0}^{\infty} a_i x^i =
       \sin (a_0 + \sum\limits_{i = 1}^{\infty} a_i x^i) =
  \sin a_0 \cdot \cos \sum\limits_{i = 1}^{\infty} a_i x^i +
       \cos a_0 \cdot \sin \sum\limits_{i = 1}^{\infty} a_i x^i.
\end{eqnarray}
\]</span></p>
<p>Here <span class="math inline">\(\cos a_0\)</span> and <span class="math inline">\(\sin a_0\)</span> are sine and cosine of scalar. And the sine/cosine of zero-headed series can be calculated by composition of the argument with well-known series of sine/cosine.</p>
<p>The second example. Let’s look at the <span class="math inline">\(\arcsin\)</span>, definitions:</p>
<p><span class="math display">\[
\begin{eqnarray}
  \sum\limits_{i = 0}^{\infty} b_i x^i = \arcsin \sum\limits_{i = 0}^{\infty} a_i x^i,\\
  \sin\sum\limits_{i = 0}^{\infty} b_i x^i = \sum\limits_{i = 0}^{\infty} a_i x^i.
\end{eqnarray}
\]</span></p>
<p>And solution for an ad-hoc formula is obtained as follows (using the fact <span class="math inline">\(b_0 = \arcsin a_0\)</span>):</p>
<p><span class="math display">\[
\begin{eqnarray}
  \sin\sum\limits_{i = 1}^{\infty} b_i x^i =
    \sin\left(\sum\limits_{i = 0}^{\infty} b_i x^i - b_0 \right) = \\
  = \cos b_0 \cdot \sin\sum\limits_{i = 0}^{\infty} b_i x^i -
    \sin b_0 \cdot \cos\sum\limits_{i = 0}^{\infty} b_i x^i = \\
  = \sqrt{1 - a_0^2} \cdot \sum\limits_{i = 0}^{\infty} a_i x^i -
    a_0 \cdot \sqrt{1 - \left(\sum\limits_{i = 0}^{\infty} a_i x^i\right)^2}.
\end{eqnarray}
\]</span></p>
<p>The full formula is done by adding <span class="math inline">\(b_0\)</span>:</p>
<p><span class="math display">\[
\begin{equation}
  \sum\limits_{i = 0}^{\infty} b_i x^i =
    \arcsin a_0 + \arcsin
       \left[
       \sqrt{1 - a_0^2} \cdot
       \sum\limits_{i = 0}^{\infty} a_i x^i -
       a_0 \cdot \sqrt{1 - \left(\sum\limits_{i = 0}^{\infty} a_i x^i\right)^2}
       \right].
\end{equation}
\]</span></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">instance</span> (<span class="dt">Floating</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Floating</span> (<span class="dt">S</span> a) <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>  <span class="fu">pi</span> <span class="ot">=</span> <span class="dt">S</span> <span class="fu">pi</span> <span class="dv">0</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="fu">exp</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> texp <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb12-4"><a href="#cb12-4"></a>  <span class="fu">exp</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="fu">exp</span> a <span class="op">^*</span> <span class="fu">exp</span> (<span class="dt">S</span> <span class="dv">0</span> x)</span>
<span id="cb12-5"><a href="#cb12-5"></a>  <span class="fu">log</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> tlog <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb12-6"><a href="#cb12-6"></a>  <span class="fu">log</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">log</span> a) <span class="dv">0</span> <span class="op">+</span> <span class="fu">log</span> (<span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> <span class="fu">fmap</span> (<span class="op">/</span> a) x)</span>
<span id="cb12-7"><a href="#cb12-7"></a>  <span class="fu">sin</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> tsin <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb12-8"><a href="#cb12-8"></a>  <span class="fu">sin</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="fu">sin</span> a <span class="op">^*</span> <span class="fu">cos</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="op">+</span> <span class="fu">cos</span> a <span class="op">^*</span> <span class="fu">sin</span> (<span class="dt">S</span> <span class="dv">0</span> x)</span>
<span id="cb12-9"><a href="#cb12-9"></a>  <span class="fu">cos</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> tcos <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb12-10"><a href="#cb12-10"></a>  <span class="fu">cos</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="fu">cos</span> a <span class="op">^*</span> <span class="fu">cos</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="op">-</span> <span class="fu">sin</span> a <span class="op">^*</span> <span class="fu">sin</span> (<span class="dt">S</span> <span class="dv">0</span> x)</span></code></pre></div>
<p>An interesting example is sqrt, as usual we want to find <span class="math inline">\(b_n\)</span> such that:</p>
<p><span class="math display">\[ \sum\limits_{n=0}^\infty b_nx^n \cdot \sum\limits_{n=0}^\infty b_nx^n = \sum\limits_{n=0}^n a_i x^n \]</span></p>
<p>Rewrite the formula in a head-tail form, where <span class="math inline">\(y\)</span> – is a tail of b, and <span class="math inline">\(p\)</span> – is a tail of incomming series:</p>
<p><span class="math display">\[ (b_0 + x * y) (b_ 0 + x * y) = a0 + x p\]</span></p>
<p><span class="math display">\[ b_0^2 + 2 x y + x^2 y = a0 + x p\]</span></p>
<p>by grouping elements with 0 and 1 power of <span class="math inline">\(x\)</span>, we find:</p>
<p><span class="math display">\[
\begin{equation}
  \left\lbrace
  \begin{matrix}
     b_0 &amp; = \sqrt{a_0} \\
     y &amp; = \frac{p-y^2}{2 \sqrt{a_0}}
  \end{matrix}
  \right.
\end{equation}
\]</span></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a>  <span class="fu">sqrt</span> (<span class="dt">S</span> <span class="dv">0</span> (<span class="dt">S</span> <span class="dv">0</span> x)) <span class="ot">=</span> <span class="dt">S</span> <span class="dv">0</span> (<span class="fu">sqrt</span> x)</span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="fu">sqrt</span> (<span class="dt">S</span> <span class="dv">0</span> _) <span class="ot">=</span> <span class="kw">let</span> sq <span class="ot">=</span> <span class="dt">S</span> (<span class="dv">0</span> <span class="op">/</span> <span class="dv">0</span>) sq <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> sq</span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="fu">sqrt</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="kw">let</span> sqa <span class="ot">=</span> <span class="fu">sqrt</span> a</span>
<span id="cb13-4"><a href="#cb13-4"></a>                     sqx <span class="ot">=</span> (x <span class="op">-</span> <span class="dt">S</span> <span class="dv">0</span> (sqx <span class="op">*</span> sqx)) <span class="op">/^</span> (<span class="dv">2</span> <span class="op">*</span> <span class="fu">sqrt</span> a)</span>
<span id="cb13-5"><a href="#cb13-5"></a>                 <span class="kw">in</span> <span class="dt">S</span> sqa sqx</span>
<span id="cb13-6"><a href="#cb13-6"></a>  <span class="fu">asin</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> tasin <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb13-7"><a href="#cb13-7"></a>  <span class="fu">asin</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="kw">let</span> <span class="dt">S</span> _ y <span class="ot">=</span> <span class="fu">sqrt</span> (<span class="dv">1</span> <span class="op">-</span> a <span class="op">*</span> a) <span class="op">^*</span> (<span class="dt">S</span> a x) <span class="op">-</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>                             a <span class="op">^*</span> <span class="fu">sqrt</span> (<span class="dv">1</span> <span class="op">-</span> (<span class="dt">S</span> a x) <span class="op">*</span> (<span class="dt">S</span> a x))</span>
<span id="cb13-9"><a href="#cb13-9"></a>                 <span class="kw">in</span> <span class="dt">S</span> (<span class="fu">asin</span> a) <span class="dv">0</span> <span class="op">+</span> <span class="fu">asin</span> (<span class="dt">S</span> <span class="dv">0</span> y)</span>
<span id="cb13-10"><a href="#cb13-10"></a>  <span class="fu">acos</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> tacos <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb13-11"><a href="#cb13-11"></a>  <span class="fu">acos</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="kw">let</span> <span class="dt">S</span> _ y <span class="ot">=</span> a <span class="op">^*</span> (<span class="dt">S</span> a x) <span class="op">-</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>                             <span class="fu">sqrt</span> (<span class="dv">1</span> <span class="op">-</span> a <span class="op">*</span> a) <span class="op">^*</span> <span class="fu">sqrt</span> (<span class="dv">1</span> <span class="op">-</span> (<span class="dt">S</span> a x) <span class="op">*</span> (<span class="dt">S</span> a x))</span>
<span id="cb13-13"><a href="#cb13-13"></a>                 <span class="kw">in</span> <span class="dt">S</span> (<span class="fu">acos</span> a) <span class="dv">0</span> <span class="op">+</span> <span class="fu">acos</span> (<span class="dt">S</span> <span class="dv">0</span> y)</span>
<span id="cb13-14"><a href="#cb13-14"></a>  <span class="fu">atan</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> tatan <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb13-15"><a href="#cb13-15"></a>  <span class="fu">atan</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="kw">let</span> <span class="dt">S</span> _ y <span class="ot">=</span> <span class="dt">S</span> <span class="dv">0</span> x <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> a <span class="op">^*</span> (<span class="dt">S</span> a x))</span>
<span id="cb13-16"><a href="#cb13-16"></a>                 <span class="kw">in</span> <span class="dt">S</span> (<span class="fu">atan</span> a) <span class="dv">0</span> <span class="op">+</span> <span class="fu">atan</span> (<span class="dt">S</span> <span class="dv">0</span> y)</span>
<span id="cb13-17"><a href="#cb13-17"></a>  <span class="fu">sinh</span> x <span class="ot">=</span> (<span class="fu">exp</span> x <span class="op">-</span> <span class="fu">exp</span> (<span class="op">-</span>x)) <span class="op">/^</span> <span class="dv">2</span></span>
<span id="cb13-18"><a href="#cb13-18"></a>  <span class="fu">cosh</span> x <span class="ot">=</span> (<span class="fu">exp</span> x <span class="op">+</span> <span class="fu">exp</span> (<span class="op">-</span>x)) <span class="op">/^</span> <span class="dv">2</span></span>
<span id="cb13-19"><a href="#cb13-19"></a>  <span class="fu">asinh</span> x <span class="ot">=</span> <span class="fu">log</span> (x <span class="op">+</span> <span class="fu">sqrt</span> (x <span class="op">*</span> x <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb13-20"><a href="#cb13-20"></a>  <span class="fu">acosh</span> x <span class="ot">=</span> <span class="fu">undefined</span> <span class="co">-- log (x + sqrt (x * x - 1))</span></span>
<span id="cb13-21"><a href="#cb13-21"></a>  <span class="fu">atanh</span> x <span class="ot">=</span> <span class="fu">log</span> ((<span class="dv">1</span> <span class="op">+</span> x) <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> x)) <span class="op">/^</span> <span class="dv">2</span></span></code></pre></div>
<p>## Library</p>
<p>Now we can define mathematic functions on the power series. The derivative:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="ot">diff ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb14-2"><a href="#cb14-2"></a>diff s <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">fromInteger</span> (fromList [<span class="dv">1</span><span class="op">..</span>]) <span class="op">^*^</span> stail s</span></code></pre></div>
<p>And the integral:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">integral ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb15-2"><a href="#cb15-2"></a>integral c  s <span class="ot">=</span> <span class="dt">S</span> c (s <span class="op">^*^</span> <span class="fu">fmap</span> (<span class="fu">recip</span><span class="op">.</span><span class="fu">fromInteger</span>) (fromList [<span class="dv">1</span><span class="op">..</span>]) )</span></code></pre></div>
<p>### Generic functions:</p>
<p>In order to inspect a stream we can introduce a helper function:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="ot">stake ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb16-2"><a href="#cb16-2"></a>stake <span class="dv">0</span> _       <span class="ot">=</span> []</span>
<span id="cb16-3"><a href="#cb16-3"></a>stake n (<span class="dt">S</span> a s) <span class="ot">=</span> a<span class="op">:</span>stake (n<span class="op">-</span><span class="dv">1</span>) s</span></code></pre></div>
<p>Here all functions will be prefixed with <code>s</code> however if you write a module for working with streams you may prefer to not add it and ask user to import module qualified.</p>
<p>Here is a function that builds a stream from the list (and the other way):</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="ot">fromList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb17-2"><a href="#cb17-2"></a>fromList (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">S</span> x (fromList xs) <span class="co">-- works only on infinite list</span></span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="ot">fromListNum ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb17-5"><a href="#cb17-5"></a>fromListNum [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>fromListNum (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">S</span> x (fromListNum xs)</span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="ot">toList ::</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb17-9"><a href="#cb17-9"></a>toList (<span class="dt">S</span> x xs) <span class="ot">=</span> x <span class="op">:</span> toList xs</span></code></pre></div>
<p>In order to write an usefull functions and series we will introduce a folding:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="ot">sscan ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> b <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb18-2"><a href="#cb18-2"></a>sscan f i (<span class="dt">S</span> x s) <span class="ot">=</span></span>
<span id="cb18-3"><a href="#cb18-3"></a> <span class="kw">let</span> k <span class="ot">=</span> f i x</span>
<span id="cb18-4"><a href="#cb18-4"></a> <span class="kw">in</span> <span class="dt">S</span> k (sscan f k s)</span></code></pre></div>
<p>Now lets introduce few functions using <code>sfold</code>. A function that will generate a sum of the Stream, i.e. having a stream <code>ssum &lt;a0:a1:a2:..&gt; = &lt;a0:a0+a1:a0+a1+a2:...&gt;</code></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">ssum ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb19-2"><a href="#cb19-2"></a>ssum <span class="ot">=</span> sscan (<span class="op">+</span>) <span class="dv">0</span></span></code></pre></div>
<p>Build a stream by iterating a function</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="ot">siterate ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb20-2"><a href="#cb20-2"></a>siterate f x <span class="ot">=</span> <span class="dt">S</span> x (siterate f (f x))</span></code></pre></div>
<p>Build a serie of powers: <span class="math inline">\(&lt;x,x^2,x^3,...&gt;\)</span></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a>spower x <span class="ot">=</span> <span class="dt">S</span> <span class="dv">1</span> (siterate (<span class="op">*</span>x) x)</span></code></pre></div>
<p>Unfold</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="ot">sunfold ::</span> (c <span class="ot">-&gt;</span> (c,a)) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb22-2"><a href="#cb22-2"></a>sunfold f k <span class="ot">=</span> <span class="kw">let</span> (k&#39;,a) <span class="ot">=</span> f k <span class="kw">in</span> <span class="dt">S</span> a (sunfold f k&#39;)</span></code></pre></div>
<p>Because we want to implement a teylor serie we want to have a serie of factorials</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="ot">sfac ::</span> (<span class="dt">Enum</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb23-2"><a href="#cb23-2"></a>sfac <span class="ot">=</span> sscan (<span class="op">*</span>) <span class="dv">1</span> (fromList [<span class="dv">1</span><span class="op">..</span>]) </span></code></pre></div>
<p>And now 1/factorials</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="ot">sdfac ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb24-2"><a href="#cb24-2"></a>sdfac <span class="ot">=</span> <span class="fu">fmap</span> (\x <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="op">/</span> (<span class="fu">fromIntegral</span> x)) sfac</span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="ot">szipWith ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> b <span class="ot">-&gt;</span> <span class="dt">S</span> c</span>
<span id="cb25-2"><a href="#cb25-2"></a>szipWith f (<span class="dt">S</span> a x) (<span class="dt">S</span> b y) <span class="ot">=</span> <span class="dt">S</span> (f a b) (szipWith f x y)</span></code></pre></div>
<p>This is an actual building of the Taylor serie:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a><span class="ot">build ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb26-2"><a href="#cb26-2"></a>build t s <span class="ot">=</span> ssum <span class="op">$</span> spower t <span class="op">^*^</span> s</span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a><span class="ot">shead ::</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb27-2"><a href="#cb27-2"></a>shead (<span class="dt">S</span> a s) <span class="ot">=</span> a</span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a><span class="ot">stail ::</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb28-2"><a href="#cb28-2"></a>stail (<span class="dt">S</span> a s) <span class="ot">=</span> s</span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a><span class="ot">sdropWhile ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb29-2"><a href="#cb29-2"></a>sdropWhile p s<span class="op">@</span>(<span class="dt">S</span> a xs)</span>
<span id="cb29-3"><a href="#cb29-3"></a>  <span class="op">|</span> p a <span class="ot">=</span> sdropWhile p xs</span>
<span id="cb29-4"><a href="#cb29-4"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> s</span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="ot">eps ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb30-2"><a href="#cb30-2"></a>eps e s <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> shead <span class="op">.</span> sdropWhile (\(x,y) <span class="ot">-&gt;</span> <span class="fu">abs</span> (x <span class="op">-</span> y) <span class="op">&gt;=</span> e)</span>
<span id="cb30-3"><a href="#cb30-3"></a>        <span class="op">$</span> szipWith (,) s (stail s)</span></code></pre></div>
<p>## Taylor series for some analytic functions</p>
<p>Here we defined examples for the functions with analytically known series at 0.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a><span class="ot">texp ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb31-2"><a href="#cb31-2"></a>texp <span class="ot">=</span> <span class="dt">S</span> <span class="dv">1</span> sdfac</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="ot">tlog ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb32-2"><a href="#cb32-2"></a>tlog <span class="ot">=</span> <span class="kw">let</span> go n s <span class="ot">=</span> <span class="dt">S</span> (s <span class="op">/</span> n) (go (n <span class="op">+</span> <span class="dv">1</span>) (<span class="op">-</span>s))</span>
<span id="cb32-3"><a href="#cb32-3"></a>       <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span> <span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a><span class="ot">tsin ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb33-2"><a href="#cb33-2"></a>tsin <span class="ot">=</span> <span class="kw">let</span> s <span class="ot">=</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">.</span> <span class="dt">S</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">$</span> s</span>
<span id="cb33-3"><a href="#cb33-3"></a>       <span class="kw">in</span> s <span class="op">^*^</span> texp</span></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="ot">tcos ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb34-2"><a href="#cb34-2"></a>tcos <span class="ot">=</span> <span class="kw">let</span> s <span class="ot">=</span> <span class="dt">S</span> <span class="dv">1</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">.</span> <span class="dt">S</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> s</span>
<span id="cb34-3"><a href="#cb34-3"></a>       <span class="kw">in</span> s <span class="op">^*^</span> texp</span></code></pre></div>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a><span class="ot">tasin ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb35-2"><a href="#cb35-2"></a>tasin <span class="ot">=</span> <span class="kw">let</span> go n <span class="ot">=</span> <span class="dt">S</span> (<span class="dv">1</span> <span class="op">/</span> n) (<span class="fu">fmap</span> (<span class="op">*</span> (n <span class="op">/</span> (n <span class="op">+</span> <span class="dv">1</span>))) <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> go (n <span class="op">+</span> <span class="dv">2</span>))</span>
<span id="cb35-3"><a href="#cb35-3"></a>        <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a><span class="ot">tacos ::</span> (<span class="dt">Eq</span> a, <span class="dt">Floating</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb36-2"><a href="#cb36-2"></a>tacos <span class="ot">=</span> <span class="fu">pi</span> <span class="op">/</span> <span class="dv">2</span> <span class="op">-</span> tasin</span></code></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a><span class="ot">tatan ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb37-2"><a href="#cb37-2"></a>tatan <span class="ot">=</span> <span class="kw">let</span> go s n <span class="ot">=</span> <span class="dt">S</span> (s <span class="op">/</span> n) <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> go (<span class="op">-</span>s) (n <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb37-3"><a href="#cb37-3"></a>        <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> go <span class="dv">1</span> <span class="dv">1</span></span></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a><span class="ot">tsinh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb38-2"><a href="#cb38-2"></a>tsinh <span class="ot">=</span> <span class="kw">let</span> s <span class="ot">=</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="op">$</span> s</span>
<span id="cb38-3"><a href="#cb38-3"></a>        <span class="kw">in</span> s <span class="op">^*^</span> texp</span></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="ot">tcosh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb39-2"><a href="#cb39-2"></a>tcosh <span class="ot">=</span> <span class="kw">let</span> s <span class="ot">=</span> <span class="dt">S</span> <span class="dv">1</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> s</span>
<span id="cb39-3"><a href="#cb39-3"></a>        <span class="kw">in</span> s <span class="op">^*^</span> texp</span></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a><span class="ot">tasinh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb40-2"><a href="#cb40-2"></a>tasinh <span class="ot">=</span> <span class="kw">let</span> go s n <span class="ot">=</span> <span class="dt">S</span> (s <span class="op">/</span> n) (<span class="fu">fmap</span> (<span class="op">*</span> (n <span class="op">/</span> (n <span class="op">+</span> <span class="dv">1</span>))) <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> go (<span class="op">-</span>s) (n <span class="op">+</span> <span class="dv">2</span>))</span>
<span id="cb40-3"><a href="#cb40-3"></a>         <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span> <span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a><span class="ot">tacosh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb41-2"><a href="#cb41-2"></a>tacosh <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a><span class="ot">tatanh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb42-2"><a href="#cb42-2"></a>tatanh <span class="ot">=</span> <span class="kw">let</span> go n <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">recip</span> n) <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> go (n <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb42-3"><a href="#cb42-3"></a>         <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span>)</span></code></pre></div>
<p>## TODO</p>
<p>Some things were not covered in this file, taylor series were not statically protected agains calling actions on the series build at the different points, so we assume that every Taylor serie is built at <span class="math inline">\(0\)</span>.</p>
<p>Not all functions from the Floating instance were implemented.</p>
<p>It’s possible to generalize <span class="math inline">\(asin/sin\)</span> approach for a wider class of functions, but it was not done yet.</p>]]></summary>
</entry>
<entry>
    <title>Playing with types: type level numbers</title>
    <link href="https://qnikst.github.io/posts/2014-08-07-playing-with-types.html" />
    <id>https://qnikst.github.io/posts/2014-08-07-playing-with-types.html</id>
    <published>2013-12-30T00:00:00Z</published>
    <updated>2013-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>As always I’m terribly sorry for my bad english, but writing the posts and having a feedback is the only reasonable way to improve it.</p>
</blockquote>
<p>This post describes an easy exercise that gives a feeling of use typelevel numbers. This post is a part of another work that hopefully will be covered in following posts.</p>
<p>If you want to know more about typelevel literals and friends you can take a look at the <a href="http://ponies.io/posts/2014-07-30-typelits.html">following post</a> it describes the theory much better than I can.</p>
<p>Intead of using type level Strings we will address numbers. In this post I want to create a datatype that will contain a number that is known <em>statically</em> (at compilation time) and which can be extracted from type at <em>runtime</em>.</p>
<p>The first part of the problem (having a number) in a type may be interesting if you want to distiguish types assosiated with different numbers.</p>
<p>For simplicity we will take <a href="https://hackage.haskell.org/package/tagged-0.7.2/docs/Data-Tagged.html">Data.Tagged.Tagged</a> type from <code>tagged</code> package. However it’s possible to create our own type as I did at the beggining (just I did a first time).</p>
<p>We add helper methods that allow us to extract infomation about the type-parameter from the value:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">toProxy ::</span> <span class="dt">Tagged</span> n a  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n</span>
<span id="cb1-2"><a href="#cb1-2"></a>toProxy _ <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>And add a constrictor helper that allow to create a type with information about number that is provided by us.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">mkT ::</span> proxy n <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tagged</span> n a</span>
<span id="cb2-2"><a href="#cb2-2"></a>mkT _ a <span class="ot">=</span> <span class="dt">Tagged</span> a</span></code></pre></div>
<p>Just check that we can create a fancy values:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> <span class="op">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Nothing</span>) <span class="dv">8</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Nothing</span>) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> <span class="dt">&#39;Nothing</span> a</span></code></pre></div>
<h1 id="naturals">Naturals</h1>
<p>From this point we can start real fun. At first lest create a value with natural type parameter:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> <span class="op">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> <span class="dv">3</span> a</span></code></pre></div>
<p>Now we want to be able to use this information at runtime. Let’s introduce a new method that will use <code>natVal</code> function:</p>
<pre class="haskel"><code>natVal :: forall n proxy. KnownNat n =&gt; proxy n -&gt; Integer` </code></pre>
<p>take a type that acts as a type proxy and returns the integer assosiated with a type.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">useT ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Tagged</span> n a <span class="ot">-&gt;</span> a</span>
<span id="cb6-2"><a href="#cb6-2"></a>useT t<span class="op">@</span>(<span class="dt">Tagged</span> a) <span class="ot">=</span> <span class="fu">fromIntegral</span> (natVal (toProxy t)) <span class="op">+</span> a</span></code></pre></div>
<p>Here we are:</p>
<ol type="1">
<li><p>extracting type information by calling <code>toProxy</code></p></li>
<li><p>extracting natural number from a proxy by calling <code>natVal</code></p></li>
<li><p>returning a calculated results</p></li>
</ol>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> useT <span class="op">$</span> mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="dv">11</span></span></code></pre></div>
<h1 id="positive-rational">Positive rational</h1>
<p>On the next step we will introduce a code that works for natural numbers, by definition rational number is <code>a % b</code>, where <code>a \in Z</code> and <code>b \in N</code>. Lets lift this information to a type level by introducing a typelevel rational:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">data</span> (<span class="op">:%%</span>) a b</span></code></pre></div>
<p>And introduce type extraction mechanisms</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">-- | extract numerator type</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="fu">numerator</span><span class="ot"> ::</span> proxy (n <span class="op">:%%</span> m) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n</span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="fu">numerator</span> _ <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="co">-- | Extract denomenator type </span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="ot">denomenator ::</span> proxy (n <span class="op">:%%</span> m)  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> m</span>
<span id="cb9-7"><a href="#cb9-7"></a>denomenator _ <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>Today we don’t conver math operations over the type-parameters, this may be a topic for another post. So now we may be quite happy as we can create values tagged by something that looks like a rational number.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> <span class="op">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="op">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="op">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (<span class="dv">3</span> <span class="op">:%%</span> <span class="dv">8</span>) a</span></code></pre></div>
<p>Now we can write a function that will use information about the type at runtime:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">useTF ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (n <span class="op">:%%</span> m) a <span class="ot">-&gt;</span> a</span>
<span id="cb11-2"><a href="#cb11-2"></a>useTF t<span class="op">@</span>(<span class="dt">Tagged</span> a) <span class="ot">=</span> v <span class="op">+</span> a</span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="kw">where</span> v <span class="ot">=</span> <span class="fu">fromRational</span> <span class="op">$</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>               natVal (<span class="fu">numerator</span> <span class="op">$</span> toProxy t) <span class="op">:%</span> natVal (denomenator <span class="op">$</span> toProxy t)</span></code></pre></div>
<p>Lets check:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> useTF <span class="op">$</span> mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="op">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="fl">8.375</span></span></code></pre></div>
<h1 id="positive-real.">Positive real.</h1>
<p>Now we want to solve the following problem: it’s not easy to write types for ratio, the reason that for a complex cases we need somehow to find the ratio that fits. Also we want to support real numbers. Having in mind the fact that real values are not supported on the typelevel, we may be quite happy with Rational approximation.</p>
<p>In order to solve those 2 problems we need:</p>
<ol type="1">
<li><p>real values support</p></li>
<li><p>ability to write code easily</p></li>
</ol>
<p>We will introduce a TH function that will find a good approximation and create required type:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">mkFloatProxy ::</span> <span class="dt">RealFrac</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>mkFloatProxy x <span class="ot">=</span> [<span class="op">|</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="op">$</span>(nk a) <span class="op">:%%</span> <span class="op">$</span>(nk b)) <span class="op">|</span>]</span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="kw">where</span> (a <span class="op">:%</span> b) <span class="ot">=</span> <span class="fu">toRational</span> x</span>
<span id="cb13-4"><a href="#cb13-4"></a>          nk x <span class="ot">=</span> sigT (litT (numTyLit x)) (<span class="dt">ConT</span> <span class="op">$</span> mkName <span class="st">&quot;Nat&quot;</span>)</span></code></pre></div>
<p>the magic that we have in <code>nk x</code> we need to create a type parameter of kind <code>Nat</code>. Now we can write a code like:</p>
<blockquote>
<p>test = mkT $(mkFloatProxy pi) 7.0</p>
</blockquote>
<p>This is quite nice, next steps may be support of negative values, using SomeNat and operations on values.</p>]]></summary>
</entry>
<entry>
    <title>О stockdb</title>
    <link href="https://qnikst.github.io/posts/2013-12-30-haskell-laziness.html" />
    <id>https://qnikst.github.io/posts/2013-12-30-haskell-laziness.html</id>
    <published>2013-12-30T00:00:00Z</published>
    <updated>2013-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>(Старый пост взятый из исходников блога, так что он может содержать несколько устаревшие данные, кроме бенчмарков сделаных в августе 2014)</p>
<p>Недавно я столкнулся с задачей оптимизации программы написанной Максом Лапшиным (<span class="citation" data-cites="maxlapshin">@maxlapshin</span>). Программу говорят, что уже смотрели и другие программисты, но все же я решился потратить время и посмотреть, что там не так.</p>
<p>Первое, что мне первое бросилось в глаза это то, что одно из основных свойств языка “ленивость” совсем не использовалось, в связи с этим я собираюсь акцентировать внимание именно на этом аспекте.</p>
<p>Что позволяет ленивость:</p>
<pre><code>1. Возможность не вычислять значения, которые не используются

2. Возможность создания эффективных персистентных структур данных (см. Окасаки)

3. Возможность создания итеративных вычислений</code></pre>
<p>Естественно, все это дается не бесплатно:</p>
<pre><code>1. Ленивость приводит к оверхеду по памяти, т.к. нужно хранить больше информации

2. Ленивость может приводить к повторным вычислениям в многопоточных программах

3. Ленивость может приводить к “утечкам”, т.е. случаям, когда вместо результато
   создаются структуры описывающие отложенные вычисления “thunk” и их накапливается
   очень большое количество. Часто этот эффект называют memory leak, хотя лично
   мне не нравится данный термин, поскольку обычно он используется для описания
   неиспользуемой, но не освобожденной памяти.</code></pre>
<p>Особенно неприятной является третья проблема, как но её решение, в очень многих случаях, заключается в применении следующего правила:</p>
<blockquote>
<p>Не использовать ленивые поля в стуктурах данных, если это специально не требуется.</p>
</blockquote>
<h2 id="строгость-структур-данных">Строгость структур данных</h2>
<p>В этом случае если вы не знаете, нужна ли вам ленивость, делайте поле строгим. Так же если переиспользование не нужно или данные по размеру меньше, чем указатель, то можно их сразу распаковать {-# UNPACK #-} это снимет один уровень индирекции.</p>
<p>Вместо списков зачастую выгоднее иметь вектора, что уменьшает уровень индирекции и ускоряет работу с ними, особенно это выгодно в случае, если размер вектора известен или он создается целиком и больше не изменяется.</p>
<p>Стоит отметить, что для данной задачи оптимизации не привносят много плюсов, поскольку создаваемые стуктуры никак не используются.</p>
<h2 id="неправильные-библиотеки">“Неправильные” библиотеки</h2>
<p>В коде использовалась очень неэффективная библиотека binary-strict, хотя абсолютно никакой необходимости использовать как строгие байтстроки, так и эту библиотеку не было. В общем-то, в этом была основная проблема и замена библиотеки на binary и binary-bits дало максимальную часть прироста скорости.</p>
<p>Так же работа на уровне бит для всего разбора это слишком дорого, поскольку битовые операции требуются только для разбора diff записей. Поэтому четкое разделение runBitGet и runGet сильно помогает для разделение операций, так же сделать часть операций полиморфными по монаде.</p>
<p>Следующй шаг это выделение всего что можно в Applicative синтаксис, что хоть в данном случае и не приводит к заметному ускорению, но упрощает код. Итеративный подход</p>
<p>Следующий момент в использовании reverse/snoc подхода при создании списков, данный метод является монолитным, т.е. если мы начинаем вычисление, то оно доводится до конца. Но в большинстве случаев этого не хочется, т.к. во-первых не все данные могут быть использованы во-вторых итеративный подход позволяет обрабатывать данные по частям, не держа их все в памяти если это не необходимо. Поскольку haskell язык ленивый, то вместо reverse/snoc, можно использовать go/snoc, где go создает хвост списка.</p>
<p>Поэтому код</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a>parsePayload&#39; <span class="dv">0</span> acc <span class="ot">=</span> <span class="fu">return</span> (<span class="fu">reverse</span> acc)</span>
<span id="cb3-2"><a href="#cb3-2"></a>parsePayload&#39; count acc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  stock <span class="ot">&lt;-</span> readRow previous</span>
<span id="cb3-4"><a href="#cb3-4"></a>  parsePayload&#39; (count <span class="op">-</span> <span class="dv">1</span>) (stock <span class="op">:</span> acc)</span></code></pre></div>
<p>можно переписать как:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>parsePayload&#39; <span class="dv">0</span> <span class="ot">=</span> <span class="fu">return</span> []</span>
<span id="cb4-2"><a href="#cb4-2"></a>parsePayload&#39; count <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  l <span class="ot">&lt;-</span> readRow</span>
<span id="cb4-4"><a href="#cb4-4"></a>  ls <span class="ot">&lt;-</span> parsePayload&#39; (count<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="fu">return</span> <span class="op">$!</span> l<span class="op">:</span>ls</span></code></pre></div>
<p>На самом деле данный код не сильно лучше предыдущего варианта, поскольку тоже является монолитным, но он приведен здесь как промежуточный шаг, и для того, чтобы рассмотреть отличия. В первом случае мы сначала создаем весь список O(N) по памяти и сложности и потом разворачиваем, соответсвенно при том же порядке сложности мы получаем вдвое большую константу, при этом используется куча. Во-втором варианте увеличение костанты не происходит, но вместо кучи используется стек, что имеет свои минусы. Так же в случае ленивой монады, т.е. когда вместо результата мы возвращаем действие производящее результат мы получаем уже инетаривный результат (правда к монаде Get это не относится).</p>
<p>Дальнейшее улучшение может быть произведено за счет того, что нам не нужно возвращать все данные в монаде, а достаточно обрабатывать одну запись и выходить, при помощи метода runGetOrFail.</p>
<p>На самом деле нужно идти дальше и делать composable операции создавая сначала поток объектов и diff-ов и объединяя их отдельной операцией. Но об этом в другой раз, если у меня дойдут руки до написания полноценной библиотеки для работы с такими файлами.</p>
<h2 id="код-и-результаты">Код и результаты:</h2>
<p>Код можно найти на <a href="https://github.com/maxlapshin/stockdb-hs">github</a>, ветку с изменениями примерно там же.</p>
<p>В оригинальную программу требуется добавить модификацию позволяющую считывать нужное количество записей, а не только 10000:</p>
<pre><code>diff --git a/stockdb.hs b/stockdb.hs
index 75fa7da..8ecf2e1 100644
--- a/stockdb.hs
+++ b/stockdb.hs
@@ -81,7 +81,7 @@ runEither (Left e)  = fail e
 readStocks :: BS.ByteString -&gt; Either String [Stock]
 readStocks = parsePayload . BS.drop (289 * 4) . skipHeaders where
     parsePayload payload = BG.runBitGet payload $
-        parsePayload&#39; 10000 (fail &quot;First row must be full&quot;) []
+        parsePayload&#39; 167544 (fail &quot;First row must be full&quot;) []
     parsePayload&#39; 0 previous acc = return (reverse acc)
     parsePayload&#39; count previous acc = do
         stock &lt;- readRow previous</code></pre>
<p>Время работы оригинальной программы:</p>
<pre><code>qnikst@localhost ~/workspace/myself/stockdb-hs $ \time -v ./stockdb out.stock-2
167544
     Command being timed: &quot;./stockdb out.stock-2&quot;
     User time (seconds): 13.96
     System time (seconds): 1.00
     Percent of CPU this job got: 99%
     Elapsed (wall clock) time (h:mm:ss or m:ss): 0:14.98
     Average shared text size (kbytes): 0
     Average unshared data size (kbytes): 0
     Average stack size (kbytes): 0
     Average total size (kbytes): 0
     Maximum resident set size (kbytes): 15146224
     Average resident set size (kbytes): 0
     Major (requiring I/O) page faults: 0
     Minor (reclaiming a frame) page faults: 945203
     Voluntary context switches: 1
     Involuntary context switches: 1550
     Swaps: 0
     File system inputs: 0
     File system outputs: 0
     Socket messages sent: 0
     Socket messages received: 0
     Signals delivered: 0
     Page size (bytes): 4096
     Exit status: 0</code></pre>
<p>Время работы обновленной программы</p>
<pre><code>167544
     Command being timed: &quot;./stockdb out.stock-2&quot;
     User time (seconds): 5.11
     System time (seconds): 0.27
     Percent of CPU this job got: 99%
     Elapsed (wall clock) time (h:mm:ss or m:ss): 0:05.39
     Average shared text size (kbytes): 0
     Average unshared data size (kbytes): 0
     Average stack size (kbytes): 0
     Average total size (kbytes): 0
     Maximum resident set size (kbytes): 783664
     Average resident set size (kbytes): 0
     Major (requiring I/O) page faults: 0
     Minor (reclaiming a frame) page faults: 233956
     Voluntary context switches: 1
     Involuntary context switches: 542
     Swaps: 0
     File system inputs: 0
     File system outputs: 0
     Socket messages sent: 0
     Socket messages received: 0
     Signals delivered: 0
     Page size (bytes): 4096
     Exit status: 0</code></pre>
<p>Итого ускорение посчти в 3 раза по скорости, а потребление мапяти уменьшилось в 20 раз.</p>]]></summary>
</entry>
<entry>
    <title>Basic pathfinding</title>
    <link href="https://qnikst.github.io/posts/2013-09-08-pathfinding.html" />
    <id>https://qnikst.github.io/posts/2013-09-08-pathfinding.html</id>
    <published>2013-09-08T00:00:00Z</published>
    <updated>2013-09-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div style="float:right">
<strong>Updates:</strong><br />2013-09-09: fixes by <span class="citation" data-cites="qrilka">@qrilka</span>
</div>
<p>In this post I’ll review basic approach to pathfinding using functional approach. It possible that this post doesn’t contain the best approach and all other solutions are welcome.</p>
<div class="row">
<div class="span8">
<p>On the right you can see example of a simple map.</p>
<p>Here is a list of imports. I need it because this is pure lhs file that can be <a href="/posts/2013-09-08-pathfinding.lhs">downloaded</a> and executed in ghci, so you can skip it.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">import</span>           <span class="dt">Data.List</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">import</span>           <span class="dt">Data.Monoid</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span>           <span class="dt">Data.Map</span> (<span class="dt">Map</span>)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span>           <span class="dt">Data.Set</span> (<span class="dt">Set</span>)</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">import</span>           <span class="dt">Data.Function</span></span></code></pre></div>
<p>We will solve simple task of finding the shortest path from one location to another (from 5 to 1). As a first step lets introduce some basic types. Most of them are just type synonyms:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">type</span> <span class="dt">Loc</span>     <span class="ot">=</span> <span class="dt">Int</span>                      <span class="co">-- Location</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">type</span> <span class="dt">Dist</span>    <span class="ot">=</span> <span class="dt">Int</span>                      <span class="co">-- Distance</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">type</span> <span class="dt">History</span> <span class="ot">=</span> [<span class="dt">Loc</span>]                    <span class="co">-- History</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">type</span> <span class="dt">LMap</span>    <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">Loc</span> [(<span class="dt">Loc</span>,<span class="dt">Dist</span>)]     <span class="co">-- map</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">-- here is example of the map</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="ot">testMap ::</span> <span class="dt">LMap</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>testMap <span class="ot">=</span> Map.fromList [(<span class="dv">1</span>,[(<span class="dv">2</span>,<span class="dv">5</span>),(<span class="dv">3</span>,<span class="dv">40</span>),(<span class="dv">5</span>,<span class="dv">100</span>)])</span>
<span id="cb2-8"><a href="#cb2-8"></a>                       ,(<span class="dv">2</span>,[(<span class="dv">1</span>,<span class="dv">5</span>),(<span class="dv">3</span>,<span class="dv">10</span>),(<span class="dv">4</span>,<span class="dv">30</span>)])</span>
<span id="cb2-9"><a href="#cb2-9"></a>                       ,(<span class="dv">3</span>,[(<span class="dv">1</span>,<span class="dv">40</span>),(<span class="dv">2</span>,<span class="dv">10</span>),(<span class="dv">5</span>,<span class="dv">20</span>),(<span class="dv">4</span>,<span class="dv">10</span>)])</span>
<span id="cb2-10"><a href="#cb2-10"></a>                       ,(<span class="dv">4</span>,[(<span class="dv">2</span>,<span class="dv">30</span>),(<span class="dv">3</span>,<span class="dv">10</span>),(<span class="dv">5</span>,<span class="dv">5</span>)])</span>
<span id="cb2-11"><a href="#cb2-11"></a>                       ,(<span class="dv">5</span>,[(<span class="dv">1</span>,<span class="dv">100</span>),(<span class="dv">3</span>,<span class="dv">20</span>),(<span class="dv">4</span>,<span class="dv">5</span>)])</span>
<span id="cb2-12"><a href="#cb2-12"></a>                       ]</span></code></pre></div>
<br />
</div>
<div class="span4">
<img src="/images/posts/pathfinding/1.png" class="img-polaroid"/>
</div>
</div>
<p>## Basic algorithm</p>
<p>The basic idea of our solution is: ‘we need to create a list of the locations that is reachable from initial location sorted by distance’. You can this about this solution like we move in all possible directions at the same time. Then we can filter out final destination and find history related to the correct solution.</p>
<p>Terms: <code>frontier</code> - a list of possible locations with distance from the starting point, sorted by ascending distance.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">type</span> <span class="dt">Frontier0</span> <span class="ot">=</span> [(<span class="dt">Loc</span>, <span class="dt">Dist</span>)]</span></code></pre></div>
<p>So algorithm of generating result list will look like:</p>
<ol start="0" type="1">
<li>Add starting point with zero distance to the <code>frontier</code>.</li>
<li>Take the first location from the frontier. It will be our next <code>current location</code>.</li>
<li><code>p1</code> &lt;- get list of the locations reachable from the <code>current location</code> in one step.</li>
<li><code>p2</code> &lt;- sum distance to the current distance with the distance from the <code>current location</code> to each possible location from <code>p1</code>. Now we have a list of possible locations with distances from the starting point.</li>
<li>Add list of the new possible locations (<code>p2</code>) to the <code>frontier</code>.</li>
<li>goto 1.</li>
</ol>
<p>This algorithm will create a list of the possible destinations from the current point. The key of the algorithm is that frontier should be sorted by distance, so every time we will take closest position. It will guarantee that our algorithm will not diverge.</p>
<p>As you’ll see the solution will be a direct translation of literal description to the code. And that is a very nice property of haskell.</p>
<p>Here are few images describing process:</p>
<div class="row">
<div class="span4">
<img src="/images/posts/pathfinding/2.png" class="img-polaroid"/>
</div>
<div class="span8">
<p>Here is an image of the current state after step 0.</p>
<p>We added <code>5</code> to the frontier and then take it as a <code>current location</code>.</p>
<p>Now we have 3 new locations reachable: <code>1</code>, <code>3</code> and <code>4</code> (marked with red).</p>
And <code>4</code> with distance 5 will be moved to the result list (dashed). <br />
</div>
</div>
<div class="row">
<div class="span4">
<img src="/images/posts/pathfinding/3.png" class="img-polaroid"/>
</div>
<div class="span8">
<p>Here is next step.</p>
<p>We took <code>4</code> as a new current element.</p>
<p>We found 2 new reachabe locations: <code>2</code> and <code>3</code>.</p>
<p>We added current distance (5) to distances to the current locations and add them to the frontier.</p>
<code>&lt;&gt;</code> is a function that will merge and sort 2 lists. You can see result of the merge shown with dashed lines. <br />
</div>
</div>
<p>## Additional types.</p>
<p>Now we can review types that we will use.</p>
<p>### Candidate</p>
<p>All elements in a resulting set and a frontier are possible canditas for a solution, so they need to contain all temporary information (Distance) and information that we will need when we’ll filter out this solution (History). So we need to introduce a newtype for a candate, we use newtype here because we will need to redefine some properties otherwise we could use a tuple <code>(,,)</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">newtype</span> <span class="dt">Candidate</span> <span class="ot">=</span> <span class="dt">Candidate</span> (<span class="dt">Loc</span>,<span class="dt">Dist</span>,<span class="dt">History</span>) <span class="kw">deriving</span> <span class="dt">Eq</span>   <span class="co">-- possible solution</span></span></code></pre></div>
<p>And helper functions:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">candidateLoc ::</span> <span class="dt">Candidate</span> <span class="ot">-&gt;</span> <span class="dt">Loc</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>candidateLoc (<span class="dt">Candidate</span> (x,_,_)) <span class="ot">=</span> x</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="ot">candidateHist ::</span> <span class="dt">Candidate</span> <span class="ot">-&gt;</span> <span class="dt">History</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>candidateHist (<span class="dt">Candidate</span> (_,_,x)) <span class="ot">=</span> x</span></code></pre></div>
<p>### Ascending list</p>
<p>As we have seen in the algorithm resulting list and frontier are ascending lists. So we may introduce special type that will preserve this property. This will help us to avoid additional mistakes, and can help with undestanding of our solution. This type is isomorphic to the List, however we can’t just use a newtype as we shouldn’t unpack pure list from the AscList:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">data</span> <span class="dt">AscList</span> a <span class="ot">=</span> (<span class="op">:&lt;</span>) a (<span class="dt">AscList</span> a) <span class="op">|</span> <span class="dt">Nil</span></span></code></pre></div>
<p>It’s easy to see that AscList forms a monoid with regard to <code>concat</code> operation, so we can use this information:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">AscList</span> a) <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="fu">mappend</span> <span class="dt">Nil</span> b <span class="ot">=</span> b</span>
<span id="cb7-4"><a href="#cb7-4"></a>  <span class="fu">mappend</span> a <span class="dt">Nil</span> <span class="ot">=</span> a</span>
<span id="cb7-5"><a href="#cb7-5"></a>  <span class="fu">mappend</span> a&#39;<span class="op">@</span>(a <span class="op">:&lt;</span> as) b&#39;<span class="op">@</span>(b <span class="op">:&lt;</span> bs)</span>
<span id="cb7-6"><a href="#cb7-6"></a>     <span class="op">|</span> a <span class="op">&lt;</span> b <span class="ot">=</span> a <span class="op">:&lt;</span> (as <span class="op">&lt;&gt;</span> b&#39;)</span>
<span id="cb7-7"><a href="#cb7-7"></a>     <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> b <span class="op">:&lt;</span> (a&#39; <span class="op">&lt;&gt;</span> bs)</span></code></pre></div>
<p>Introduce two helper functions:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">-- | create ascending list from arbitrary list</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ot">fromList ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">AscList</span> a</span>
<span id="cb8-3"><a href="#cb8-3"></a>fromList <span class="ot">=</span> <span class="fu">mconcat</span> <span class="op">.</span> <span class="fu">map</span> singleton </span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="co">-- | convert value to Ascending List</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="ot">singleton ::</span> a <span class="ot">-&gt;</span> <span class="dt">AscList</span> a</span>
<span id="cb8-7"><a href="#cb8-7"></a>singleton x <span class="ot">=</span> x <span class="op">:&lt;</span> <span class="dt">Nil</span></span></code></pre></div>
<p>In order to use Candidates in an AscList we need to introduce ordering on the Candidates:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Candidate</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="fu">compare</span> (<span class="dt">Candidate</span> (_,d1,_)) (<span class="dt">Candidate</span> (_,d2,_)) <span class="ot">=</span> <span class="fu">compare</span> d1 d2</span></code></pre></div>
<p>Now we can guarantee that lists are properly ordered.</p>
<p>### Builder seed.</p>
<p>In order to create list we will use <code>unfoldr :: (b -&gt; Maybe (a, b)) -&gt; b -&gt; [a]</code> combinator. On each step we will create one new element and return new seed. So we will need to store frontier in the seed. Additionaly we will use one optimization: we will store a list of visited locations (that exists in result array) and we will filter out locations that we have visited, so we need to store a set of location. So resulting type will look like:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">type</span> <span class="dt">Visited</span> <span class="ot">=</span> <span class="dt">Set</span> <span class="dt">Loc</span>                  <span class="co">-- visited locations</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">type</span> <span class="dt">Seed</span> <span class="ot">=</span> (<span class="dt">AscList</span> <span class="dt">Candidate</span>,<span class="dt">Visited</span>) <span class="co">-- seed of the algorithm</span></span></code></pre></div>
<p>## Solver</p>
<p>Now we are ready to introduce our solver:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">solve ::</span> <span class="dt">LMap</span>       <span class="co">-- ^ map</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>      <span class="ot">-&gt;</span> <span class="dt">Loc</span>        <span class="co">-- ^ finish location</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>      <span class="ot">-&gt;</span> <span class="dt">Loc</span>        <span class="co">-- ^ start location</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>      <span class="ot">-&gt;</span> <span class="dt">History</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>solve mp finish <span class="ot">=</span> <span class="fu">reverse</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>                <span class="op">.</span> (finish<span class="op">:</span>)     <span class="co">-- we need to add finish place to the list</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>                <span class="op">.</span> candidateHist <span class="co">-- we are interested in history only</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>                <span class="op">.</span> <span class="fu">head</span>          <span class="co">-- we need only first solution</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>                <span class="op">.</span> <span class="fu">filter</span> ((<span class="op">==</span>finish) <span class="op">.</span> candidateLoc)  <span class="co">-- take last result</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>                <span class="op">.</span> unfoldr go    <span class="co">-- generate list of candidates using frontier</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>                <span class="op">.</span> initial       <span class="co">-- initialize frontier using starting point</span></span>
<span id="cb11-12"><a href="#cb11-12"></a> <span class="kw">where</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>    initial i <span class="ot">=</span> (singleton <span class="op">$</span> <span class="dt">Candidate</span> (i,<span class="dv">0</span>,[]),Set.empty)</span></code></pre></div>
<p>In go we need to guarantee that current seed in greater (using Candidate’s ordering) that any other element in list. We can guarantee it because:</p>
<ol start="0" type="1">
<li>when we have no elements in list we use first candidate with zero distance</li>
<li>all elements in frontier has length &gt; than current location. because we use AscList.</li>
<li>all possible locations from current location &gt; than current location as their distance is (current location distance + x, where x ≥ 0).</li>
</ol>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="ot">    go ::</span> <span class="dt">Seed</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Candidate</span>,<span class="dt">Seed</span>)</span>
<span id="cb12-2"><a href="#cb12-2"></a>    go (<span class="dt">Nil</span>,_) <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    go ((<span class="dt">Candidate</span> (x,d,h) <span class="op">:&lt;</span> xs),visited) <span class="ot">=</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>       <span class="kw">case</span> Map.lookup x mp <span class="kw">of</span>  <span class="co">-- read possible locations from map</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>         <span class="dt">Nothing</span> <span class="ot">-&gt;</span> go (xs,visited)       <span class="co">-- if thre is no destinaction proceed with next element</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>         <span class="dt">Just</span> ls <span class="ot">-&gt;</span> <span class="kw">let</span> ls&#39;   <span class="ot">=</span> fromList  <span class="co">-- generate AscList from current position</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>                              <span class="op">.</span> <span class="fu">map</span> (\(yl,yd) <span class="ot">-&gt;</span> <span class="dt">Candidate</span> (yl,yd<span class="op">+</span>d,x<span class="op">:</span>h))  <span class="co">-- increment distance (see 2.)</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>                              <span class="op">.</span> <span class="fu">filter</span> ((<span class="ot">`Set.notMember`</span> visited) <span class="op">.</span> <span class="fu">fst</span>) <span class="op">$</span> ls <span class="co">-- remove elements that we have visited</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>                    <span class="kw">in</span> <span class="dt">Just</span> ( <span class="dt">Candidate</span> (x,d,h)</span>
<span id="cb12-10"><a href="#cb12-10"></a>                              , (ls&#39; <span class="op">&lt;&gt;</span> xs, Set.insert x visited))</span></code></pre></div>
<p>Yachoo! we have a solver. However it will work badly on the big maps and we need to use more advanced methods, like A<up>*</up>. But we need to fix Candidate ordering function.</p>
<p>I’ve heard that it is possible to use comonad approach to solve this problem however I couldn’t find any example of this approach.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a>test <span class="ot">=</span> solve testMap <span class="dv">5</span> <span class="dv">1</span></span></code></pre></div>
<p>as a result we will have [5,4,3,2,1]. That is correct solution.</p>]]></summary>
</entry>

</feed>
