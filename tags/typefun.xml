<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - Post tagged typefun</title>
    <link href="https://qnikst.github.io/tags/typefun.xml" rel="self" />
    <link href="https://qnikst.github.io" />
    <id>https://qnikst.github.io/tags/typefun.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2013-12-30T00:00:00Z</updated>
    <entry>
    <title>Playing with types: type level numbers</title>
    <link href="https://qnikst.github.io/posts/2014-08-07-playing-with-types.html" />
    <id>https://qnikst.github.io/posts/2014-08-07-playing-with-types.html</id>
    <published>2013-12-30T00:00:00Z</published>
    <updated>2013-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>As always I’m terribly sorry for my bad english, but writing the posts and having a feedback is the only reasonable way to improve it.</p>
</blockquote>
<p>This post describes an easy exercise that gives a feeling of use typelevel numbers. This post is a part of another work that hopefully will be covered in following posts.</p>
<p>If you want to know more about typelevel literals and friends you can take a look at the <a href="http://ponies.io/posts/2014-07-30-typelits.html">following post</a> it describes the theory much better than I can.</p>
<p>Intead of using type level Strings we will address numbers. In this post I want to create a datatype that will contain a number that is known <em>statically</em> (at compilation time) and which can be extracted from type at <em>runtime</em>.</p>
<p>The first part of the problem (having a number) in a type may be interesting if you want to distiguish types assosiated with different numbers.</p>
<p>For simplicity we will take <a href="https://hackage.haskell.org/package/tagged-0.7.2/docs/Data-Tagged.html">Data.Tagged.Tagged</a> type from <code>tagged</code> package. However it’s possible to create our own type as I did at the beggining (just I did a first time).</p>
<p>We add helper methods that allow us to extract infomation about the type-parameter from the value:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">toProxy ::</span> <span class="dt">Tagged</span> n a  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n</div>
<div class="sourceLine" id="2" data-line-number="2">toProxy _ <span class="fu">=</span> <span class="dt">Proxy</span></div></code></pre>
<p>And add a constrictor helper that allow to create a type with information about number that is provided by us.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">mkT ::</span> proxy n <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tagged</span> n a</div>
<div class="sourceLine" id="2" data-line-number="2">mkT _ a <span class="fu">=</span> <span class="dt">Tagged</span> a</div></code></pre>
<p>Just check that we can create a fancy values:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Nothing</span>) <span class="dv">8</span></div>
<div class="sourceLine" id="2" data-line-number="2">mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Nothing</span>) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> <span class="ch">&#39;Nothing a</span></div></code></pre>
<h1 id="naturals">Naturals</h1>
<p>From this point we can start real fun. At first lest create a value with natural type parameter:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span></div>
<div class="sourceLine" id="2" data-line-number="2">mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> <span class="dv">3</span> a</div></code></pre>
<p>Now we want to be able to use this information at runtime. Let’s introduce a new method that will use <code>natVal</code> function:</p>
<pre class="haskel"><code>natVal :: forall n proxy. KnownNat n =&gt; proxy n -&gt; Integer` </code></pre>
<p>take a type that acts as a type proxy and returns the integer assosiated with a type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">useT ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Tagged</span> n a <span class="ot">-&gt;</span> a</div>
<div class="sourceLine" id="2" data-line-number="2">useT t<span class="fu">@</span>(<span class="dt">Tagged</span> a) <span class="fu">=</span> fromIntegral (natVal (toProxy t)) <span class="fu">+</span> a</div></code></pre>
<p>Here we are:</p>
<ol style="list-style-type: decimal">
<li><p>extracting type information by calling <code>toProxy</code></p></li>
<li><p>extracting natural number from a proxy by calling <code>natVal</code></p></li>
<li><p>returning a calculated results</p></li>
</ol>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> useT <span class="fu">$</span> mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="dv">11</span></div></code></pre>
<h1 id="positive-rational">Positive rational</h1>
<p>On the next step we will introduce a code that works for natural numbers, by definition rational number is <code>a % b</code>, where <code>a \in Z</code> and <code>b \in N</code>. Lets lift this information to a type level by introducing a typelevel rational:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="kw">data</span> (<span class="fu">:%%</span>) a b</div></code></pre>
<p>And introduce type extraction mechanisms</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="co">-- | extract numerator type</span></div>
<div class="sourceLine" id="2" data-line-number="2">numerator<span class="ot"> ::</span> proxy (n <span class="fu">:%%</span> m) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n</div>
<div class="sourceLine" id="3" data-line-number="3">numerator _ <span class="fu">=</span> <span class="dt">Proxy</span></div>
<div class="sourceLine" id="4" data-line-number="4"></div>
<div class="sourceLine" id="5" data-line-number="5"><span class="co">-- | Extract denomenator type </span></div>
<div class="sourceLine" id="6" data-line-number="6"><span class="ot">denomenator ::</span> proxy (n <span class="fu">:%%</span> m)  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> m</div>
<div class="sourceLine" id="7" data-line-number="7">denomenator _ <span class="fu">=</span> <span class="dt">Proxy</span></div></code></pre>
<p>Today we don’t conver math operations over the type-parameters, this may be a topic for another post. So now we may be quite happy as we can create values tagged by something that looks like a rational number.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span></div>
<div class="sourceLine" id="2" data-line-number="2">mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>) a</div></code></pre>
<p>Now we can write a function that will use information about the type at runtime:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">useTF ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (n <span class="fu">:%%</span> m) a <span class="ot">-&gt;</span> a</div>
<div class="sourceLine" id="2" data-line-number="2">useTF t<span class="fu">@</span>(<span class="dt">Tagged</span> a) <span class="fu">=</span> v <span class="fu">+</span> a</div>
<div class="sourceLine" id="3" data-line-number="3">  <span class="kw">where</span> v <span class="fu">=</span> fromRational <span class="fu">$</span></div>
<div class="sourceLine" id="4" data-line-number="4">               natVal (numerator <span class="fu">$</span> toProxy t) <span class="fu">:%</span> natVal (denomenator <span class="fu">$</span> toProxy t)</div></code></pre>
<p>Lets check:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> useTF <span class="fu">$</span> mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="fl">8.375</span></div></code></pre>
<h1 id="positive-real.">Positive real.</h1>
<p>Now we want to solve the following problem: it’s not easy to write types for ratio, the reason that for a complex cases we need somehow to find the ratio that fits. Also we want to support real numbers. Having in mind the fact that real values are not supported on the typelevel, we may be quite happy with Rational approximation.</p>
<p>In order to solve those 2 problems we need:</p>
<ol style="list-style-type: decimal">
<li><p>real values support</p></li>
<li><p>ability to write code easily</p></li>
</ol>
<p>We will introduce a TH function that will find a good approximation and create required type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">mkFloatProxy ::</span> <span class="dt">RealFrac</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></div>
<div class="sourceLine" id="2" data-line-number="2">mkFloatProxy x <span class="fu">=</span> [<span class="fu">|</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="fu">$</span>(nk a) <span class="fu">:%%</span> <span class="fu">$</span>(nk b)) <span class="fu">|</span>]</div>
<div class="sourceLine" id="3" data-line-number="3">  <span class="kw">where</span> (a <span class="fu">:%</span> b) <span class="fu">=</span> toRational x</div>
<div class="sourceLine" id="4" data-line-number="4">          nk x <span class="fu">=</span> sigT (litT (numTyLit x)) (<span class="dt">ConT</span> <span class="fu">$</span> mkName <span class="st">&quot;Nat&quot;</span>)</div></code></pre>
<p>the magic that we have in <code>nk x</code> we need to create a type parameter of kind <code>Nat</code>. Now we can write a code like:</p>
<blockquote>
<p>test = mkT $(mkFloatProxy pi) 7.0</p>
</blockquote>
<p>This is quite nice, next steps may be support of negative values, using SomeNat and operations on values.</p>]]></summary>
</entry>

</feed>
