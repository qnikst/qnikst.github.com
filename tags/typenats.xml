<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - Post tagged typenats</title>
    <link href="https://qnikst.github.io/tags/typenats.xml" rel="self" />
    <link href="https://qnikst.github.io" />
    <id>https://qnikst.github.io/tags/typenats.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2014-12-16T00:00:00Z</updated>
    <entry>
    <title>Approaches to carry a proof for typelevel natural</title>
    <link href="https://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" />
    <id>https://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html</id>
    <published>2014-12-16T00:00:00Z</published>
    <updated>2014-12-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>For time ago Bas van Dijk asked a question on glasgow-haskell-users mailing list about <a href="https://www.haskell.org/pipermail/glasgow-haskell-users/2014-November/025451.html">proving the properties of type-level natural numbers obtained by user</a>. That lead to an interesting discussion, that you can read in the list archives.</p>
<p>The problem was that we want to impose a constraint on some typelevel natural and then read value from user and guarantee that we have that constraint. For such constraint we took (&lt;=255).</p>
<p>Here is a file that describe few approaches to solve this problem.</p>
<p>At first we need to use a HUGE list of pragmas.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE DataKinds #-}</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE GADTs #-}</span></div>
<div class="sourceLine" id="3" data-line-number="3"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TypeOperators #-}</span></div>
<div class="sourceLine" id="4" data-line-number="4"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></div>
<div class="sourceLine" id="5" data-line-number="5"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE KindSignatures #-}</span></div>
<div class="sourceLine" id="6" data-line-number="6"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span></div>
<div class="sourceLine" id="7" data-line-number="7"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ViewPatterns #-}</span></div>
<div class="sourceLine" id="8" data-line-number="8"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE PolyKinds #-}</span></div>
<div class="sourceLine" id="9" data-line-number="9"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TypeFamilies #-}</span></div>
<div class="sourceLine" id="10" data-line-number="10"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></div>
<div class="sourceLine" id="11" data-line-number="11"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></div>
<div class="sourceLine" id="12" data-line-number="12"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE RankNTypes #-}</span></div>
<div class="sourceLine" id="13" data-line-number="13"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></div>
<div class="sourceLine" id="14" data-line-number="14"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></div></code></pre>
<p>And relax compiler options a bit.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="ot">{-# OPTIONS_GHC -ftype-function-depth=1024 #-}</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span> <span class="ot">{-# OPTIONS_GHC -fcontext-stack=1024 #-}</span></div>
<div class="sourceLine" id="3" data-line-number="3"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="4" data-line-number="4"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">GHC.TypeLits</span></div>
<div class="sourceLine" id="5" data-line-number="5"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">GHC.Exts</span> </div>
<div class="sourceLine" id="6" data-line-number="6"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Proxy</span></div>
<div class="sourceLine" id="7" data-line-number="7"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Constraint</span></div>
<div class="sourceLine" id="8" data-line-number="8"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Type.Bool</span></div>
<div class="sourceLine" id="9" data-line-number="9"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Type.Equality</span></div>
<div class="sourceLine" id="10" data-line-number="10"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">System.Environment</span></div>
<div class="sourceLine" id="11" data-line-number="11"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">Unsafe.Coerce</span></div>
<div class="sourceLine" id="12" data-line-number="12"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Singletons</span></div>
<div class="sourceLine" id="13" data-line-number="13"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">Control.Monad</span></div></code></pre>
<h2 id="attempt-1-tagged-value">Attempt-1: Tagged value</h2>
<p>We can keep a proof together with value, so we can introduce a new type:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Proof</span> n  (<span class="ot">c ::</span> <span class="dt">Constraint</span>) <span class="kw">where</span> <span class="dt">Proof</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof</span> n c</div></code></pre>
<p>In mailing list I provide following code:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt; fromSomeError ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof</span> n (n <span class="fu">&lt;=</span> <span class="dv">255</span>))</div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span> fromSomeError (<span class="dt">SomeNat</span> p)</div>
<div class="sourceLine" id="3" data-line-number="3"><span class="ot">&gt;</span>    <span class="fu">|</span> natVal p <span class="fu">&lt;=</span> <span class="dv">255</span> <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Proof</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n))</div>
<div class="sourceLine" id="4" data-line-number="4"><span class="ot">&gt;</span>    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span></div></code></pre>
<p>This is obviously a bug as we check natVal p, but return Proxy n. And correct version fails, as there is no way to simply inject a constraint.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="co">{-</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="co">&gt; fromSome :: SomeNat -&gt; Maybe (Proof n (n &lt;= 255))</span></div>
<div class="sourceLine" id="3" data-line-number="3"><span class="co">&gt; fromSome (SomeNat p)</span></div>
<div class="sourceLine" id="4" data-line-number="4"><span class="co">&gt;   | natVal p &lt;= 255 = Just (Proof p)</span></div>
<div class="sourceLine" id="5" data-line-number="5"><span class="co">&gt;   | otherwise = Nothing</span></div>
<div class="sourceLine" id="6" data-line-number="6"><span class="co">&gt; -}</span></div></code></pre>
<pre><code> Proof.lhs:53:37:
    Could not deduce (n1 ~ n)
    from the context (KnownNat n1)
    bound by a pattern with constructor
        SomeNat :: forall (n :: Nat). KnownNat n =&gt; Proxy n -&gt; SomeNat,
	in an equation for ‘fromSome’
	at Proof.lhs:52:13-21</code></pre>
<h2 id="attempt-2-type-carrier">Attempt-2: Type carrier</h2>
<p>Now we want to have the following constraint on out Nat</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Proof2</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span>   <span class="dt">Proof2</span><span class="ot"> ::</span> c n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c</div></code></pre>
<p>In order to have a ‘curried’ version of our constaint we can introduce a type family</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="kw">type</span> family <span class="dt">LessThan255</span><span class="ot"> n ::</span> <span class="dt">Constraint</span> <span class="kw">where</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span>     <span class="dt">LessThan255</span> f <span class="fu">=</span> (f <span class="fu">&lt;=</span> <span class="dv">255</span>)</div></code></pre>
<p>Now lets try to create a proof from known natural:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="co">{-</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="co">&gt; strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255</span></div>
<div class="sourceLine" id="3" data-line-number="3"><span class="co">&gt; strange = Proof2</span></div>
<div class="sourceLine" id="4" data-line-number="4"><span class="co">&gt; -}</span></div></code></pre>
<p><sub><sub><sub><sub><sub><sub><sub>~</sub></sub></sub></sub></sub></sub></sub> Proof.lhs:89:13: Could not deduce (LessThan255 n) arising from a use of ‘Proof2’ from the context (LessThan255 n) bound by the type signature for strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255 <sub><sub><sub><sub><sub><sub>~</sub></sub></sub></sub></sub></sub>~</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt; strange ::</span> (<span class="dt">LessThan255</span> <span class="fu">~</span> c, c n) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c</div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span> strange <span class="fu">=</span> <span class="dt">Proof2</span></div></code></pre>
<p>Previous attempt to build function failed, but this one works. I don’t know if it’s related to non-injectivity or a bug.. I can report it :)</p>
<p>When I realized this problem, I have stopped.</p>
<p>Update. As Richard Eisenberg says:</p>
<pre><code>By the way, the bug in the Proof2 version is a bug in GHC 7.8.3
(only in .3 -- not in .2 or in the soon-to-be .4) that allows you
to write unsaturated type families that don&#39;t work.
Saying `LessThan255` without a parameter should be a syntax error,
but that check was accidentally turned off for 7.8.3, leading to a bogus type error.</code></pre>
<h2 id="attempt-3-carry-a-contraint-in-a-datatype">Attempt-3: carry a contraint in a datatype</h2>
<p>Now let’s keep our ‘constraint’ in a datatype, here we have 2 proxy, one for datatype, and one for value, also a KnownNat constraint that we want to use later:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Proof3</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span>   <span class="dt">Proof3</span><span class="ot"> ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c</div></code></pre>
<p>We can introduce a Show instance</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Proof3</span> c) <span class="kw">where</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span>   show (<span class="dt">Proof3</span> _ k) <span class="fu">=</span> show <span class="fu">$</span> natVal k</div></code></pre>
<p>And now we can introduce a LessThen constraint as a datatype:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">LessThan255D</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="kw">where</span> <span class="dt">LessThan255D</span><span class="ot"> ::</span> (n <span class="fu">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">LessThan255D</span> n</div></code></pre>
<p>We can convert type level constrant to data easily:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt; c2d ::</span> <span class="dt">LessThan255</span> n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">LessThan255D</span> n</div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span> c2d _ <span class="fu">=</span> <span class="dt">LessThan255D</span></div></code></pre>
<p>But what about a proof, ideally we want to have following code:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="co">{-</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="co">&gt; fromSome3 :: SomeNat -&gt; Maybe (Proof3 LessThan255D)</span></div>
<div class="sourceLine" id="3" data-line-number="3"><span class="co">&gt; fromSome3 (SomeNat p)</span></div>
<div class="sourceLine" id="4" data-line-number="4"><span class="co">&gt;    | natVal p &lt; natVal t255 = Just (Proof3 LessThan255D p)</span></div>
<div class="sourceLine" id="5" data-line-number="5"><span class="co">&gt;    | otherwise = Nothing</span></div>
<div class="sourceLine" id="6" data-line-number="6"><span class="co">&gt;    where t255 = Proxy :: Proxy 255</span></div>
<div class="sourceLine" id="7" data-line-number="7"><span class="co">&gt; -}</span></div></code></pre>
<pre><code>Proof.lhs:138:46:
  Could not deduce ((n &lt;=? 255) ~ &#39;True)
  from the context (KnownNat n)</code></pre>
<p>It doesn’t work simply because value level check doesn’t guarantee typelevel properties.</p>
<p>One way to solve it is to use unsafeCoerce: the idea is to use a proof for the value we know, and then coerce a type of a proof to the type of the proof related to the users value:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt; fromSome3 ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span> fromSome3 (<span class="dt">SomeNat</span> p)</div>
<div class="sourceLine" id="3" data-line-number="3"><span class="ot">&gt;</span>    <span class="fu">|</span> natVal p <span class="fu">&lt;</span> natVal t255 <span class="fu">=</span> <span class="dt">Just</span> (fake (c2d t255) p)</div>
<div class="sourceLine" id="4" data-line-number="4"><span class="ot">&gt;</span>    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span></div>
<div class="sourceLine" id="5" data-line-number="5"><span class="ot">&gt;</span>    <span class="kw">where</span> t255 <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span></div>
<div class="sourceLine" id="6" data-line-number="6"><span class="ot">&gt;          fake ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c p <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c</div>
<div class="sourceLine" id="7" data-line-number="7"><span class="ot">&gt;</span>          fake k p <span class="fu">=</span> <span class="dt">Proof3</span> (unsafeCoerce<span class="ot"> k ::</span> c n) p</div></code></pre>
<p>It’s a nice solution, it’s unsafe as typechecker does not check that our predicate <code>(natVal (p::Proxy n) &lt; natVal (t255::Proxy 255))</code> implies the safety of a coerce from <code>LessThan255 ~ 255 -&gt; LessThan255 ~ p</code>.</p>
<p>There is one more solution that is really typesafe, but has a big complexity, and require a bounded set of values:</p>
<p>We can try to check is equal to one specific value from the set.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt; guessProof ::</span> (<span class="dt">KnownNat</span> n, n <span class="fu">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span> guessProof (<span class="dt">SomeNat</span> p) n <span class="fu">=</span> <span class="kw">case</span> sameNat p n <span class="kw">of</span></div>
<div class="sourceLine" id="3" data-line-number="3"><span class="ot">&gt;</span>     <span class="dt">Just</span> _  <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> n</div>
<div class="sourceLine" id="4" data-line-number="4"><span class="ot">&gt;</span>     <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></div></code></pre>
<p>Now we can build all set of values that are good:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="kw">type</span> family <span class="dt">Guesses</span> (<span class="ot">n::</span><span class="dt">Nat</span>)<span class="ot"> ::</span> [<span class="dt">Nat</span>] <span class="kw">where</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span>    <span class="dt">Guesses</span> <span class="dv">0</span> <span class="fu">=</span> <span class="ch">&#39;[0]</span></div>
<div class="sourceLine" id="3" data-line-number="3"><span class="ot">&gt;</span>    <span class="dt">Guesses</span> n <span class="fu">=</span> n <span class="ch">&#39;: Guesses (n-1)</span></div></code></pre>
<p>And write a code that will check all possible values:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="kw">class</span> <span class="dt">GuessProof</span> (<span class="ot">n ::</span> [<span class="dt">Nat</span>]) <span class="kw">where</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;   proof ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</div>
<div class="sourceLine" id="3" data-line-number="3"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="4" data-line-number="4"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">GuessProof</span> <span class="ch">&#39;[] where</span></div>
<div class="sourceLine" id="5" data-line-number="5"><span class="ot">&gt;</span>   proof _ _ <span class="fu">=</span> <span class="dt">Nothing</span></div>
<div class="sourceLine" id="6" data-line-number="6"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="7" data-line-number="7"><span class="ot">&gt;</span> <span class="kw">instance</span> (<span class="dt">KnownNat</span> n, n <span class="fu">&lt;=</span> <span class="dv">255</span>, <span class="dt">GuessProof</span> ns) <span class="ot">=&gt;</span> <span class="dt">GuessProof</span> (n <span class="ch">&#39;: ns) where</span></div>
<div class="sourceLine" id="8" data-line-number="8"><span class="ot">&gt;</span>   proof s p <span class="fu">=</span> guessProof s (inner p) <span class="ot">`mplus`</span> proof s (next p)</div>
<div class="sourceLine" id="9" data-line-number="9"><span class="ot">&gt;</span>    <span class="kw">where</span><span class="ot"> inner ::</span> <span class="dt">Proxy</span> (n <span class="ch">&#39;: ns) -&gt; Proxy (n::Nat)</span></div>
<div class="sourceLine" id="10" data-line-number="10"><span class="ot">&gt;</span>          inner _ <span class="fu">=</span> <span class="dt">Proxy</span></div>
<div class="sourceLine" id="11" data-line-number="11"><span class="ot">&gt;          next ::</span> <span class="dt">Proxy</span> (n <span class="ch">&#39;: ns) -&gt; Proxy (ns::[Nat])</span></div>
<div class="sourceLine" id="12" data-line-number="12"><span class="ot">&gt;</span>          next _ <span class="fu">=</span> <span class="dt">Proxy</span></div></code></pre>
<p>It’s not very usable, have a bad complexity and require to change ghc options but it works and it’s safe.</p>
<p>Now let’s test our code:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt; f2 ::</span> (c <span class="fu">~</span> (n <span class="fu">&lt;=</span> <span class="dv">255</span>)) <span class="ot">=&gt;</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span> f2 (<span class="dt">Proof3</span> n p) <span class="fu">=</span> print <span class="fu">$</span> natVal p</div></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt; test1 ::</span> <span class="dt">IO</span> ()</div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span> test1 <span class="fu">=</span> <span class="kw">do</span></div>
<div class="sourceLine" id="3" data-line-number="3"><span class="ot">&gt;</span>     n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></div>
<div class="sourceLine" id="4" data-line-number="4"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="5" data-line-number="5"><span class="ot">&gt;</span>     <span class="kw">case</span> someNatVal n <span class="kw">of</span></div>
<div class="sourceLine" id="6" data-line-number="6"><span class="ot">&gt;</span>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Input is not a natural number!&quot;</span></div>
<div class="sourceLine" id="7" data-line-number="7"><span class="ot">&gt;</span>       <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> fromSome3 sn <span class="kw">of</span></div>
<div class="sourceLine" id="8" data-line-number="8"><span class="ot">&gt;</span>                    <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p</div>
<div class="sourceLine" id="9" data-line-number="9"><span class="ot">&gt;</span>                    _ <span class="ot">-&gt;</span> error <span class="st">&quot;Input if larger than 255&quot;</span></div></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt; test2 ::</span> <span class="dt">IO</span> ()</div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span> test2 <span class="fu">=</span> <span class="kw">do</span></div>
<div class="sourceLine" id="3" data-line-number="3"><span class="ot">&gt;</span>   n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></div>
<div class="sourceLine" id="4" data-line-number="4"><span class="ot">&gt;</span>   <span class="kw">case</span> someNatVal n <span class="kw">of</span></div>
<div class="sourceLine" id="5" data-line-number="5"><span class="ot">&gt;</span>       <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Input is not a natural number!&quot;</span></div>
<div class="sourceLine" id="6" data-line-number="6"><span class="ot">&gt;</span>       <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> proof sn (g (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span>)) <span class="kw">of</span></div>
<div class="sourceLine" id="7" data-line-number="7"><span class="ot">&gt;</span>                    <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p</div>
<div class="sourceLine" id="8" data-line-number="8"><span class="ot">&gt;</span>                    _ <span class="ot">-&gt;</span> error <span class="st">&quot;Input if larger than 255&quot;</span></div>
<div class="sourceLine" id="9" data-line-number="9"><span class="ot">&gt;</span>   <span class="kw">where</span></div>
<div class="sourceLine" id="10" data-line-number="10"><span class="ot">&gt;     g ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="dt">Guesses</span> n)</div>
<div class="sourceLine" id="11" data-line-number="11"><span class="ot">&gt;</span>     g _ <span class="fu">=</span> <span class="dt">Proxy</span></div></code></pre>
<h2 id="attempt-5-singletons">Attempt 5: Singletons</h2>
<p>This is not the only solution, one more solution was provided by Richard Eisenberg I have not found it in mailing list archives so including it here.</p>
<p>The idea is that we may use less effective representation for typelevel naturals, i.e. unary naturals we can build a proof using singletons:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TemplateHaskell, DataKinds, PolyKinds, TypeFamilies,</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;              ScopedTypeVariables, TypeOperators, UndecidableInstances,</span></div>
<div class="sourceLine" id="3" data-line-number="3"><span class="ot">&gt;              GADTs, RankNTypes #-}</span></div>
<div class="sourceLine" id="4" data-line-number="4"><span class="ot">&gt;</span> <span class="ot">{-# OPTIONS_GHC -ftype-function-depth=300 -fcontext-stack=300 #-}</span></div>
<div class="sourceLine" id="5" data-line-number="5"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="6" data-line-number="6"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Singletons.TH</span></div>
<div class="sourceLine" id="7" data-line-number="7"><span class="ot">&gt;</span> <span class="kw">import</span> <span class="dt">GHC.TypeLits</span> <span class="kw">hiding</span> ( <span class="dt">Nat</span> )</div>
<div class="sourceLine" id="8" data-line-number="8"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="9" data-line-number="9"><span class="ot">&gt;</span> <span class="fu">$</span>(singletons [d|</div>
<div class="sourceLine" id="10" data-line-number="10">&gt;   data Nat = Zero | Succ Nat</div>
<div class="sourceLine" id="11" data-line-number="11">&gt; </div>
<div class="sourceLine" id="12" data-line-number="12">&gt;   leNat :: Nat -&gt; Nat -&gt; Bool</div>
<div class="sourceLine" id="13" data-line-number="13">&gt;   leNat Zero     _        = True</div>
<div class="sourceLine" id="14" data-line-number="14">&gt;   leNat (Succ _) Zero     = False</div>
<div class="sourceLine" id="15" data-line-number="15">&gt;   leNat (Succ a) (Succ b) = a `leNat` b</div>
<div class="sourceLine" id="16" data-line-number="16">&gt;   |])</div>
<div class="sourceLine" id="17" data-line-number="17"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="18" data-line-number="18"><span class="ot">&gt;</span> <span class="co">-- | Singletons&#39;s &#39;withSomeSing&#39; is what we want, but a bug in 7.8.3 doesn&#39;t</span></div>
<div class="sourceLine" id="19" data-line-number="19"><span class="ot">&gt;</span> <span class="co">-- let it work without a specialized type for &#39;Nat&#39;s</span></div>
<div class="sourceLine" id="20" data-line-number="20"><span class="ot">&gt; withSomeNat ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> (forall (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="fu">.</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</div>
<div class="sourceLine" id="21" data-line-number="21"><span class="ot">&gt;</span> withSomeNat <span class="fu">=</span> withSomeSing</div>
<div class="sourceLine" id="22" data-line-number="22"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="23" data-line-number="23"><span class="ot">&gt;</span> <span class="co">-- | Conveniently generate unary naturals</span></div>
<div class="sourceLine" id="24" data-line-number="24"><span class="ot">&gt;</span> <span class="kw">type</span> family <span class="dt">U</span> n <span class="kw">where</span></div>
<div class="sourceLine" id="25" data-line-number="25"><span class="ot">&gt;</span>   <span class="dt">U</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Zero</span></div>
<div class="sourceLine" id="26" data-line-number="26"><span class="ot">&gt;</span>   <span class="dt">U</span> n <span class="fu">=</span> <span class="dt">Succ</span> (<span class="dt">U</span> (n<span class="fu">-</span><span class="dv">1</span>))</div>
<div class="sourceLine" id="27" data-line-number="27"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="28" data-line-number="28"><span class="ot">&gt; toNat ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Nat</span></div>
<div class="sourceLine" id="29" data-line-number="29"><span class="ot">&gt;</span> toNat n <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">0</span>      <span class="fu">=</span> <span class="dt">Nothing</span></div>
<div class="sourceLine" id="30" data-line-number="30"><span class="ot">&gt;</span>         <span class="fu">|</span> otherwise  <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> go n</div>
<div class="sourceLine" id="31" data-line-number="31"><span class="ot">&gt;</span>   <span class="kw">where</span></div>
<div class="sourceLine" id="32" data-line-number="32"><span class="ot">&gt;</span>     go <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Zero</span></div>
<div class="sourceLine" id="33" data-line-number="33"><span class="ot">&gt;</span>     go n <span class="fu">=</span> <span class="dt">Succ</span> (go (n<span class="fu">-</span><span class="dv">1</span>))</div>
<div class="sourceLine" id="34" data-line-number="34"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="35" data-line-number="35"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Bound</span> <span class="fu">=</span> <span class="dt">U</span> <span class="dv">255</span></div>
<div class="sourceLine" id="36" data-line-number="36"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="37" data-line-number="37"><span class="ot">&gt;</span> <span class="co">-- easier to test in GHCi than a proper &#39;main&#39;</span></div>
<div class="sourceLine" id="38" data-line-number="38"><span class="ot">&gt; go ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</div>
<div class="sourceLine" id="39" data-line-number="39"><span class="ot">&gt;</span> go n <span class="fu">=</span></div>
<div class="sourceLine" id="40" data-line-number="40"><span class="ot">&gt;</span>    <span class="kw">case</span> toNat n <span class="kw">of</span></div>
<div class="sourceLine" id="41" data-line-number="41"><span class="ot">&gt;</span>      <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Input is not a natural number!&quot;</span></div>
<div class="sourceLine" id="42" data-line-number="42"><span class="ot">&gt;</span>      <span class="dt">Just</span> nat <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> withSomeNat nat <span class="fu">$</span> \ snat <span class="ot">-&gt;</span></div>
<div class="sourceLine" id="43" data-line-number="43"><span class="ot">&gt;</span>        <span class="kw">case</span> snat <span class="ot">`sLeNat`</span> (<span class="ot">sing ::</span> <span class="dt">Sing</span> <span class="dt">Bound</span>) <span class="kw">of</span></div>
<div class="sourceLine" id="44" data-line-number="44"><span class="ot">&gt;</span>          <span class="dt">STrue</span>  <span class="ot">-&gt;</span> f snat</div>
<div class="sourceLine" id="45" data-line-number="45"><span class="ot">&gt;</span>          <span class="dt">SFalse</span> <span class="ot">-&gt;</span> <span class="st">&quot;Didn&#39;t work&quot;</span></div>
<div class="sourceLine" id="46" data-line-number="46"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="47" data-line-number="47"><span class="ot">&gt; f ::</span> forall proxy (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="fu">.</span> (n <span class="ot">`LeNat`</span> <span class="dt">Bound</span>) <span class="fu">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> proxy n <span class="ot">-&gt;</span> <span class="dt">String</span></div>
<div class="sourceLine" id="48" data-line-number="48"><span class="ot">&gt;</span> f _ <span class="fu">=</span> <span class="st">&quot;It worked!&quot;</span></div></code></pre>
<h2 id="attempt-6-using-luquid-haskell">Attempt 6: Using Luquid haskell</h2>
<p>Ranjit Jhala, provided a great solution for liquid haskell, that could be found either by <a href="http://goto.ucsd.edu:8090/index.html#?demo=permalink%2F1418064183.hs">url</a> or here:</p>
<hr />
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="2" data-line-number="2"><span class="ot">&gt;</span> <span class="co">{-@ LIQUID &quot;--no-termination&quot; @-}</span></div>
<div class="sourceLine" id="3" data-line-number="3"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="4" data-line-number="4"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Nat255</span> <span class="kw">where</span></div>
<div class="sourceLine" id="5" data-line-number="5"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="6" data-line-number="6"><span class="ot">&gt;</span> <span class="co">-- | Define a predicate for valid integers</span></div>
<div class="sourceLine" id="7" data-line-number="7"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="8" data-line-number="8"><span class="ot">&gt;</span> <span class="co">{-@ predicate IsValid X = 0 &lt;= X &amp;&amp; X &lt; 255 @-}</span></div>
<div class="sourceLine" id="9" data-line-number="9"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="10" data-line-number="10"><span class="ot">&gt;</span> <span class="co">-- | Use the predicate to define a refinement type (subset) of valid integers</span></div>
<div class="sourceLine" id="11" data-line-number="11"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="12" data-line-number="12"><span class="ot">&gt;</span> <span class="co">{-@ type Valid = {v:Int | IsValid v}        @-}</span></div>
<div class="sourceLine" id="13" data-line-number="13"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="14" data-line-number="14"><span class="ot">&gt;</span> <span class="co">-- | A function that checks whether a given Int is indeed valid</span></div>
<div class="sourceLine" id="15" data-line-number="15"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="16" data-line-number="16"><span class="ot">&gt;</span> <span class="co">{-@ isValid   :: n:Int -&gt; {v:Bool | Prop v &lt;=&gt; IsValid n} @-}</span></div>
<div class="sourceLine" id="17" data-line-number="17"><span class="ot">&gt;</span> isValid n     <span class="fu">=</span> <span class="dv">0</span> <span class="fu">&lt;=</span> n <span class="fu">&amp;&amp;</span> n <span class="fu">&lt;</span> (<span class="dv">255</span><span class="ot"> ::</span> <span class="dt">Int</span>)</div>
<div class="sourceLine" id="18" data-line-number="18"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="19" data-line-number="19"><span class="ot">&gt;</span> <span class="co">-- | A function that can only be called with Valid Ints.</span></div>
<div class="sourceLine" id="20" data-line-number="20"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="21" data-line-number="21"><span class="ot">&gt;</span> <span class="co">{-@ workWithValidNumber :: Valid -&gt; IO () @-}</span> </div>
<div class="sourceLine" id="22" data-line-number="22"><span class="ot">&gt;</span> workWithValidNumber n <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;This is a valid number&quot;</span> <span class="fu">++</span> show (<span class="ot">n ::</span> <span class="dt">Int</span>)</div>
<div class="sourceLine" id="23" data-line-number="23"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="24" data-line-number="24"><span class="ot">&gt;</span> <span class="co">-- | This is fine...</span></div>
<div class="sourceLine" id="25" data-line-number="25"><span class="ot">&gt;</span> ok    <span class="fu">=</span> workWithValidNumber <span class="dv">12</span></div>
<div class="sourceLine" id="26" data-line-number="26"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="27" data-line-number="27"><span class="ot">&gt;</span> <span class="co">-- | ... But this is not.        </span></div>
<div class="sourceLine" id="28" data-line-number="28"><span class="ot">&gt;</span> notOk <span class="fu">=</span> workWithValidNumber <span class="dv">257</span></div>
<div class="sourceLine" id="29" data-line-number="29"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="30" data-line-number="30"><span class="ot">&gt;</span> <span class="co">-- | Finally the top level loop that inputs a number, tests it </span></div>
<div class="sourceLine" id="31" data-line-number="31"><span class="ot">&gt;</span> <span class="co">--   and calls `workWithValidNumber` if the number is valid.</span></div>
<div class="sourceLine" id="32" data-line-number="32"><span class="ot">&gt;</span> </div>
<div class="sourceLine" id="33" data-line-number="33"><span class="ot">&gt;</span> loop <span class="fu">=</span> <span class="kw">do</span> putStrLn <span class="st">&quot;Enter Number between 0 and 255&quot;</span></div>
<div class="sourceLine" id="34" data-line-number="34"><span class="ot">&gt;</span>           n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Int</span></div>
<div class="sourceLine" id="35" data-line-number="35"><span class="ot">&gt;</span>           <span class="kw">if</span> isValid n</div>
<div class="sourceLine" id="36" data-line-number="36"><span class="ot">&gt;</span>              <span class="kw">then</span> workWithValidNumber n</div>
<div class="sourceLine" id="37" data-line-number="37"><span class="ot">&gt;</span>              <span class="kw">else</span> putStrLn <span class="st">&quot;Humph, bad input, try again!&quot;</span> <span class="fu">&gt;&gt;</span> loop</div></code></pre>
<p>I hope you have enjoyed reading this.</p>]]></summary>
</entry>
<entry>
    <title>Playing with types: type level numbers</title>
    <link href="https://qnikst.github.io/posts/2014-08-07-playing-with-types.html" />
    <id>https://qnikst.github.io/posts/2014-08-07-playing-with-types.html</id>
    <published>2013-12-30T00:00:00Z</published>
    <updated>2013-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>As always I’m terribly sorry for my bad english, but writing the posts and having a feedback is the only reasonable way to improve it.</p>
</blockquote>
<p>This post describes an easy exercise that gives a feeling of use typelevel numbers. This post is a part of another work that hopefully will be covered in following posts.</p>
<p>If you want to know more about typelevel literals and friends you can take a look at the <a href="http://ponies.io/posts/2014-07-30-typelits.html">following post</a> it describes the theory much better than I can.</p>
<p>Intead of using type level Strings we will address numbers. In this post I want to create a datatype that will contain a number that is known <em>statically</em> (at compilation time) and which can be extracted from type at <em>runtime</em>.</p>
<p>The first part of the problem (having a number) in a type may be interesting if you want to distiguish types assosiated with different numbers.</p>
<p>For simplicity we will take <a href="https://hackage.haskell.org/package/tagged-0.7.2/docs/Data-Tagged.html">Data.Tagged.Tagged</a> type from <code>tagged</code> package. However it’s possible to create our own type as I did at the beggining (just I did a first time).</p>
<p>We add helper methods that allow us to extract infomation about the type-parameter from the value:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">toProxy ::</span> <span class="dt">Tagged</span> n a  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n</div>
<div class="sourceLine" id="2" data-line-number="2">toProxy _ <span class="fu">=</span> <span class="dt">Proxy</span></div></code></pre>
<p>And add a constrictor helper that allow to create a type with information about number that is provided by us.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">mkT ::</span> proxy n <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tagged</span> n a</div>
<div class="sourceLine" id="2" data-line-number="2">mkT _ a <span class="fu">=</span> <span class="dt">Tagged</span> a</div></code></pre>
<p>Just check that we can create a fancy values:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Nothing</span>) <span class="dv">8</span></div>
<div class="sourceLine" id="2" data-line-number="2">mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Nothing</span>) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> <span class="ch">&#39;Nothing a</span></div></code></pre>
<h1 id="naturals">Naturals</h1>
<p>From this point we can start real fun. At first lest create a value with natural type parameter:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span></div>
<div class="sourceLine" id="2" data-line-number="2">mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> <span class="dv">3</span> a</div></code></pre>
<p>Now we want to be able to use this information at runtime. Let’s introduce a new method that will use <code>natVal</code> function:</p>
<pre class="haskel"><code>natVal :: forall n proxy. KnownNat n =&gt; proxy n -&gt; Integer` </code></pre>
<p>take a type that acts as a type proxy and returns the integer assosiated with a type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">useT ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Tagged</span> n a <span class="ot">-&gt;</span> a</div>
<div class="sourceLine" id="2" data-line-number="2">useT t<span class="fu">@</span>(<span class="dt">Tagged</span> a) <span class="fu">=</span> fromIntegral (natVal (toProxy t)) <span class="fu">+</span> a</div></code></pre>
<p>Here we are:</p>
<ol style="list-style-type: decimal">
<li><p>extracting type information by calling <code>toProxy</code></p></li>
<li><p>extracting natural number from a proxy by calling <code>natVal</code></p></li>
<li><p>returning a calculated results</p></li>
</ol>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> useT <span class="fu">$</span> mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="dv">11</span></div></code></pre>
<h1 id="positive-rational">Positive rational</h1>
<p>On the next step we will introduce a code that works for natural numbers, by definition rational number is <code>a % b</code>, where <code>a \in Z</code> and <code>b \in N</code>. Lets lift this information to a type level by introducing a typelevel rational:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="kw">data</span> (<span class="fu">:%%</span>) a b</div></code></pre>
<p>And introduce type extraction mechanisms</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="co">-- | extract numerator type</span></div>
<div class="sourceLine" id="2" data-line-number="2">numerator<span class="ot"> ::</span> proxy (n <span class="fu">:%%</span> m) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n</div>
<div class="sourceLine" id="3" data-line-number="3">numerator _ <span class="fu">=</span> <span class="dt">Proxy</span></div>
<div class="sourceLine" id="4" data-line-number="4"></div>
<div class="sourceLine" id="5" data-line-number="5"><span class="co">-- | Extract denomenator type </span></div>
<div class="sourceLine" id="6" data-line-number="6"><span class="ot">denomenator ::</span> proxy (n <span class="fu">:%%</span> m)  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> m</div>
<div class="sourceLine" id="7" data-line-number="7">denomenator _ <span class="fu">=</span> <span class="dt">Proxy</span></div></code></pre>
<p>Today we don’t conver math operations over the type-parameters, this may be a topic for another post. So now we may be quite happy as we can create values tagged by something that looks like a rational number.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span></div>
<div class="sourceLine" id="2" data-line-number="2">mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>) a</div></code></pre>
<p>Now we can write a function that will use information about the type at runtime:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">useTF ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (n <span class="fu">:%%</span> m) a <span class="ot">-&gt;</span> a</div>
<div class="sourceLine" id="2" data-line-number="2">useTF t<span class="fu">@</span>(<span class="dt">Tagged</span> a) <span class="fu">=</span> v <span class="fu">+</span> a</div>
<div class="sourceLine" id="3" data-line-number="3">  <span class="kw">where</span> v <span class="fu">=</span> fromRational <span class="fu">$</span></div>
<div class="sourceLine" id="4" data-line-number="4">               natVal (numerator <span class="fu">$</span> toProxy t) <span class="fu">:%</span> natVal (denomenator <span class="fu">$</span> toProxy t)</div></code></pre>
<p>Lets check:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> useTF <span class="fu">$</span> mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="fu">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span></div>
<div class="sourceLine" id="2" data-line-number="2"><span class="fl">8.375</span></div></code></pre>
<h1 id="positive-real.">Positive real.</h1>
<p>Now we want to solve the following problem: it’s not easy to write types for ratio, the reason that for a complex cases we need somehow to find the ratio that fits. Also we want to support real numbers. Having in mind the fact that real values are not supported on the typelevel, we may be quite happy with Rational approximation.</p>
<p>In order to solve those 2 problems we need:</p>
<ol style="list-style-type: decimal">
<li><p>real values support</p></li>
<li><p>ability to write code easily</p></li>
</ol>
<p>We will introduce a TH function that will find a good approximation and create required type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><div class="sourceLine" id="1" data-line-number="1"><span class="ot">mkFloatProxy ::</span> <span class="dt">RealFrac</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></div>
<div class="sourceLine" id="2" data-line-number="2">mkFloatProxy x <span class="fu">=</span> [<span class="fu">|</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="fu">$</span>(nk a) <span class="fu">:%%</span> <span class="fu">$</span>(nk b)) <span class="fu">|</span>]</div>
<div class="sourceLine" id="3" data-line-number="3">  <span class="kw">where</span> (a <span class="fu">:%</span> b) <span class="fu">=</span> toRational x</div>
<div class="sourceLine" id="4" data-line-number="4">          nk x <span class="fu">=</span> sigT (litT (numTyLit x)) (<span class="dt">ConT</span> <span class="fu">$</span> mkName <span class="st">&quot;Nat&quot;</span>)</div></code></pre>
<p>the magic that we have in <code>nk x</code> we need to create a type parameter of kind <code>Nat</code>. Now we can write a code like:</p>
<blockquote>
<p>test = mkT $(mkFloatProxy pi) 7.0</p>
</blockquote>
<p>This is quite nice, next steps may be support of negative values, using SomeNat and operations on values.</p>]]></summary>
</entry>

</feed>
