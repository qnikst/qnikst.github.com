<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - Post tagged typenats</title>
    <link href="https://qnikst.github.io/tags/typenats.xml" rel="self" />
    <link href="https://qnikst.github.io" />
    <id>https://qnikst.github.io/tags/typenats.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2014-12-16T00:00:00Z</updated>
    <entry>
    <title>Approaches to carry a proof for typelevel natural</title>
    <link href="https://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html" />
    <id>https://qnikst.github.io/posts/2014-12-16-fun-with-typelevel-naturals.markdown.html</id>
    <published>2014-12-16T00:00:00Z</published>
    <updated>2014-12-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>For time ago Bas van Dijk asked a question on glasgow-haskell-users mailing list about <a href="https://www.haskell.org/pipermail/glasgow-haskell-users/2014-November/025451.html">proving the properties of type-level natural numbers obtained by user</a>. That lead to an interesting discussion, that you can read in the list archives.</p>
<p>The problem was that we want to impose a constraint on some typelevel natural and then read value from user and guarantee that we have that constraint. For such constraint we took (&lt;=255).</p>
<p>Here is a file that describe few approaches to solve this problem.</p>
<p>At first we need to use a HUGE list of pragmas.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="ot">{-# LANGUAGE ViewPatterns #-}</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span></code></pre></div>
<p>And relax compiler options a bit.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">{-# OPTIONS_GHC -ftype-function-depth=1024 #-}</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="ot">{-# OPTIONS_GHC -fcontext-stack=1024 #-}</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span> </span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">import</span> <span class="dt">Data.Constraint</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="kw">import</span> <span class="dt">Data.Type.Bool</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">import</span> <span class="dt">System.Environment</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="kw">import</span> <span class="dt">Unsafe.Coerce</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="kw">import</span> <span class="dt">Data.Singletons</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span></code></pre></div>
<h2 id="attempt-1-tagged-value">Attempt-1: Tagged value</h2>
<p>We can keep a proof together with value, so we can introduce a new type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">Proof</span> n  (<span class="ot">c ::</span> <span class="dt">Constraint</span>) <span class="kw">where</span> <span class="dt">Proof</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof</span> n c</span></code></pre></div>
<p>In mailing list I provide following code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">fromSomeError ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof</span> n (n <span class="op">&lt;=</span> <span class="dv">255</span>))</span>
<span id="cb4-2"><a href="#cb4-2"></a>fromSomeError (<span class="dt">SomeNat</span> p)</span>
<span id="cb4-3"><a href="#cb4-3"></a>   <span class="op">|</span> natVal p <span class="op">&lt;=</span> <span class="dv">255</span> <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Proof</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> n))</span>
<span id="cb4-4"><a href="#cb4-4"></a>   <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>This is obviously a bug as we check natVal p, but return Proxy n. And correct version fails, as there is no way to simply inject a constraint.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">{-</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co">fromSome :: SomeNat -&gt; Maybe (Proof n (n &lt;= 255))</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">fromSome (SomeNat p)</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co">  | natVal p &lt;= 255 = Just (Proof p)</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">  | otherwise = Nothing</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">-}</span></span></code></pre></div>
<pre><code> Proof.lhs:53:37:
    Could not deduce (n1 ~ n)
    from the context (KnownNat n1)
    bound by a pattern with constructor
        SomeNat :: forall (n :: Nat). KnownNat n =&gt; Proxy n -&gt; SomeNat,
	in an equation for ‘fromSome’
	at Proof.lhs:52:13-21</code></pre>
<h2 id="attempt-2-type-carrier">Attempt-2: Type carrier</h2>
<p>Now we want to have the following constraint on out Nat</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">data</span> <span class="dt">Proof2</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="dt">Proof2</span><span class="ot"> ::</span> c n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c</span></code></pre></div>
<p>In order to have a ‘curried’ version of our constaint we can introduce a type family</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">LessThan255</span><span class="ot"> n ::</span> <span class="dt">Constraint</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="dt">LessThan255</span> f <span class="ot">=</span> (f <span class="op">&lt;=</span> <span class="dv">255</span>)</span></code></pre></div>
<p>Now lets try to create a proof from known natural:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">{-</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co">strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co">strange = Proof2</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co">-}</span></span></code></pre></div>
<p>~~~~~~~~~~~~~~~ Proof.lhs:89:13: Could not deduce (LessThan255 n) arising from a use of ‘Proof2’ from the context (LessThan255 n) bound by the type signature for strange :: (LessThan255 n) =&gt; Proxy n -&gt; Proof2 LessThan255 ~~~~~~~~~~~~~~</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">strange ::</span> (<span class="dt">LessThan255</span> <span class="op">~</span> c, c n) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof2</span> c</span>
<span id="cb10-2"><a href="#cb10-2"></a>strange <span class="ot">=</span> <span class="dt">Proof2</span></span></code></pre></div>
<p>Previous attempt to build function failed, but this one works. I don’t know if it’s related to non-injectivity or a bug.. I can report it :)</p>
<p>When I realized this problem, I have stopped.</p>
<p>Update. As Richard Eisenberg says:</p>
<pre><code>By the way, the bug in the Proof2 version is a bug in GHC 7.8.3
(only in .3 -- not in .2 or in the soon-to-be .4) that allows you
to write unsaturated type families that don&#39;t work.
Saying `LessThan255` without a parameter should be a syntax error,
but that check was accidentally turned off for 7.8.3, leading to a bogus type error.</code></pre>
<h2 id="attempt-3-carry-a-contraint-in-a-datatype">Attempt-3: carry a contraint in a datatype</h2>
<p>Now let’s keep our ‘constraint’ in a datatype, here we have 2 proxy, one for datatype, and one for value, also a KnownNat constraint that we want to use later:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">data</span> <span class="dt">Proof3</span><span class="ot"> ::</span> (<span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>  <span class="dt">Proof3</span><span class="ot"> ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c</span></code></pre></div>
<p>We can introduce a Show instance</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Proof3</span> c) <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="fu">show</span> (<span class="dt">Proof3</span> _ k) <span class="ot">=</span> <span class="fu">show</span> <span class="op">$</span> natVal k</span></code></pre></div>
<p>And now we can introduce a LessThen constraint as a datatype:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">data</span> <span class="dt">LessThan255D</span> (<span class="ot">n::</span><span class="dt">Nat</span>) <span class="kw">where</span> <span class="dt">LessThan255D</span><span class="ot"> ::</span> (n <span class="op">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">LessThan255D</span> n</span></code></pre></div>
<p>We can convert type level constrant to data easily:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">c2d ::</span> <span class="dt">LessThan255</span> n <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">LessThan255D</span> n</span>
<span id="cb15-2"><a href="#cb15-2"></a>c2d _ <span class="ot">=</span> <span class="dt">LessThan255D</span></span></code></pre></div>
<p>But what about a proof, ideally we want to have following code:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="co">{-</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="co">fromSome3 :: SomeNat -&gt; Maybe (Proof3 LessThan255D)</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co">fromSome3 (SomeNat p)</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="co">   | natVal p &lt; natVal t255 = Just (Proof3 LessThan255D p)</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="co">   | otherwise = Nothing</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="co">   where t255 = Proxy :: Proxy 255</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="co">-}</span></span></code></pre></div>
<pre><code>Proof.lhs:138:46:
  Could not deduce ((n &lt;=? 255) ~ &#39;True)
  from the context (KnownNat n)</code></pre>
<p>It doesn’t work simply because value level check doesn’t guarantee typelevel properties.</p>
<p>One way to solve it is to use unsafeCoerce: the idea is to use a proof for the value we know, and then coerce a type of a proof to the type of the proof related to the users value:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="ot">fromSome3 ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</span>
<span id="cb18-2"><a href="#cb18-2"></a>fromSome3 (<span class="dt">SomeNat</span> p)</span>
<span id="cb18-3"><a href="#cb18-3"></a>   <span class="op">|</span> natVal p <span class="op">&lt;</span> natVal t255 <span class="ot">=</span> <span class="dt">Just</span> (fake (c2d t255) p)</span>
<span id="cb18-4"><a href="#cb18-4"></a>   <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>   <span class="kw">where</span> t255 <span class="ot">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="ot">         fake ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> c p <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proof3</span> c</span>
<span id="cb18-7"><a href="#cb18-7"></a>         fake k p <span class="ot">=</span> <span class="dt">Proof3</span> (unsafeCoerce<span class="ot"> k ::</span> c n) p</span></code></pre></div>
<p>It’s a nice solution, it’s unsafe as typechecker does not check that our predicate <code>(natVal (p::Proxy n) &lt; natVal (t255::Proxy 255))</code> implies the safety of a coerce from <code>LessThan255 ~ 255 -&gt; LessThan255 ~ p</code>.</p>
<p>There is one more solution that is really typesafe, but has a big complexity, and require a bounded set of values:</p>
<p>We can try to check is equal to one specific value from the set.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">guessProof ::</span> (<span class="dt">KnownNat</span> n, n <span class="op">&lt;=</span> <span class="dv">255</span>) <span class="ot">=&gt;</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</span>
<span id="cb19-2"><a href="#cb19-2"></a>guessProof (<span class="dt">SomeNat</span> p) n <span class="ot">=</span> <span class="kw">case</span> sameNat p n <span class="kw">of</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="dt">Just</span> _  <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> n</span>
<span id="cb19-4"><a href="#cb19-4"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>Now we can build all set of values that are good:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Guesses</span> (<span class="ot">n::</span><span class="dt">Nat</span>)<span class="ot"> ::</span> [<span class="dt">Nat</span>] <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>   <span class="dt">Guesses</span> <span class="dv">0</span> <span class="ot">=</span> &#39;[<span class="dv">0</span>]</span>
<span id="cb20-3"><a href="#cb20-3"></a>   <span class="dt">Guesses</span> n <span class="ot">=</span> n &#39;<span class="op">:</span> <span class="dt">Guesses</span> (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>And write a code that will check all possible values:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">class</span> <span class="dt">GuessProof</span> (<span class="ot">n ::</span> [<span class="dt">Nat</span>]) <span class="kw">where</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="ot">  proof ::</span> <span class="dt">SomeNat</span> <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Proof3</span> <span class="dt">LessThan255D</span>)</span>
<span id="cb21-3"><a href="#cb21-3"></a></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="kw">instance</span> <span class="dt">GuessProof</span> &#39;[] <span class="kw">where</span></span>
<span id="cb21-5"><a href="#cb21-5"></a>  proof _ _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb21-6"><a href="#cb21-6"></a></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="kw">instance</span> (<span class="dt">KnownNat</span> n, n <span class="op">&lt;=</span> <span class="dv">255</span>, <span class="dt">GuessProof</span> ns) <span class="ot">=&gt;</span> <span class="dt">GuessProof</span> (n &#39;<span class="op">:</span> ns) <span class="kw">where</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>  proof s p <span class="ot">=</span> guessProof s (inner p) <span class="ot">`mplus`</span> proof s (next p)</span>
<span id="cb21-9"><a href="#cb21-9"></a>   <span class="kw">where</span><span class="ot"> inner ::</span> <span class="dt">Proxy</span> (n &#39;<span class="op">:</span> ns) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="ot">n::</span><span class="dt">Nat</span>)</span>
<span id="cb21-10"><a href="#cb21-10"></a>         inner _ <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="ot">         next ::</span> <span class="dt">Proxy</span> (n &#39;<span class="op">:</span> ns) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="ot">ns::</span>[<span class="dt">Nat</span>])</span>
<span id="cb21-12"><a href="#cb21-12"></a>         next _ <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>It’s not very usable, have a bad complexity and require to change ghc options but it works and it’s safe.</p>
<p>Now let’s test our code:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="ot">f2 ::</span> (c <span class="op">~</span> (n <span class="op">&lt;=</span> <span class="dv">255</span>)) <span class="ot">=&gt;</span> <span class="dt">Proof3</span> <span class="dt">LessThan255D</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb22-2"><a href="#cb22-2"></a>f2 (<span class="dt">Proof3</span> n p) <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> natVal p</span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="ot">test1 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb23-2"><a href="#cb23-2"></a>test1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>    n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></span>
<span id="cb23-4"><a href="#cb23-4"></a></span>
<span id="cb23-5"><a href="#cb23-5"></a>    <span class="kw">case</span> someNatVal n <span class="kw">of</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Input is not a natural number!&quot;</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>      <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> fromSome3 sn <span class="kw">of</span></span>
<span id="cb23-8"><a href="#cb23-8"></a>                   <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p</span>
<span id="cb23-9"><a href="#cb23-9"></a>                   _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Input if larger than 255&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="ot">test2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb24-2"><a href="#cb24-2"></a>test2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>  n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>  <span class="kw">case</span> someNatVal n <span class="kw">of</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Input is not a natural number!&quot;</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>      <span class="dt">Just</span> sn <span class="ot">-&gt;</span> <span class="kw">case</span> proof sn (g (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">255</span>)) <span class="kw">of</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>                   <span class="dt">Just</span> p <span class="ot">-&gt;</span> f2 p</span>
<span id="cb24-8"><a href="#cb24-8"></a>                   _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Input if larger than 255&quot;</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>  <span class="kw">where</span></span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="ot">    g ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (<span class="dt">Guesses</span> n)</span>
<span id="cb24-11"><a href="#cb24-11"></a>    g _ <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<h2 id="attempt-5-singletons">Attempt 5: Singletons</h2>
<p>This is not the only solution, one more solution was provided by Richard Eisenberg I have not found it in mailing list archives so including it here.</p>
<p>The idea is that we may use less effective representation for typelevel naturals, i.e. unary naturals we can build a proof using singletons:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell, DataKinds, PolyKinds, TypeFamilies,</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="ot">             ScopedTypeVariables, TypeOperators, UndecidableInstances,</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="ot">             GADTs, RankNTypes #-}</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="ot">{-# OPTIONS_GHC -ftype-function-depth=300 -fcontext-stack=300 #-}</span></span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="kw">import</span> <span class="dt">Data.Singletons.TH</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> <span class="kw">hiding</span> ( <span class="dt">Nat</span> )</span>
<span id="cb25-8"><a href="#cb25-8"></a></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="op">$</span>(singletons [d|</span>
<span id="cb25-10"><a href="#cb25-10"></a>  data Nat = Zero | Succ Nat</span>
<span id="cb25-11"><a href="#cb25-11"></a></span>
<span id="cb25-12"><a href="#cb25-12"></a>  leNat :: Nat -&gt; Nat -&gt; Bool</span>
<span id="cb25-13"><a href="#cb25-13"></a>  leNat Zero     _        = True</span>
<span id="cb25-14"><a href="#cb25-14"></a>  leNat (Succ _) Zero     = False</span>
<span id="cb25-15"><a href="#cb25-15"></a>  leNat (Succ a) (Succ b) = a `leNat` b</span>
<span id="cb25-16"><a href="#cb25-16"></a>  |])</span>
<span id="cb25-17"><a href="#cb25-17"></a></span>
<span id="cb25-18"><a href="#cb25-18"></a><span class="co">-- | Singletons&#39;s &#39;withSomeSing&#39; is what we want, but a bug in 7.8.3 doesn&#39;t</span></span>
<span id="cb25-19"><a href="#cb25-19"></a><span class="co">-- let it work without a specialized type for &#39;Nat&#39;s</span></span>
<span id="cb25-20"><a href="#cb25-20"></a><span class="ot">withSomeNat ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> (<span class="kw">forall</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="op">.</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb25-21"><a href="#cb25-21"></a>withSomeNat <span class="ot">=</span> withSomeSing</span>
<span id="cb25-22"><a href="#cb25-22"></a></span>
<span id="cb25-23"><a href="#cb25-23"></a><span class="co">-- | Conveniently generate unary naturals</span></span>
<span id="cb25-24"><a href="#cb25-24"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">U</span> n <span class="kw">where</span></span>
<span id="cb25-25"><a href="#cb25-25"></a>  <span class="dt">U</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb25-26"><a href="#cb25-26"></a>  <span class="dt">U</span> n <span class="ot">=</span> <span class="dt">Succ</span> (<span class="dt">U</span> (n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb25-27"><a href="#cb25-27"></a></span>
<span id="cb25-28"><a href="#cb25-28"></a><span class="ot">toNat ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Nat</span></span>
<span id="cb25-29"><a href="#cb25-29"></a>toNat n <span class="op">|</span> n <span class="op">&lt;</span> <span class="dv">0</span>      <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb25-30"><a href="#cb25-30"></a>        <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> go n</span>
<span id="cb25-31"><a href="#cb25-31"></a>  <span class="kw">where</span></span>
<span id="cb25-32"><a href="#cb25-32"></a>    go <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb25-33"><a href="#cb25-33"></a>    go n <span class="ot">=</span> <span class="dt">Succ</span> (go (n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb25-34"><a href="#cb25-34"></a></span>
<span id="cb25-35"><a href="#cb25-35"></a><span class="kw">type</span> <span class="dt">Bound</span> <span class="ot">=</span> <span class="dt">U</span> <span class="dv">255</span></span>
<span id="cb25-36"><a href="#cb25-36"></a></span>
<span id="cb25-37"><a href="#cb25-37"></a><span class="co">-- easier to test in GHCi than a proper &#39;main&#39;</span></span>
<span id="cb25-38"><a href="#cb25-38"></a><span class="ot">go ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb25-39"><a href="#cb25-39"></a>go n <span class="ot">=</span></span>
<span id="cb25-40"><a href="#cb25-40"></a>   <span class="kw">case</span> toNat n <span class="kw">of</span></span>
<span id="cb25-41"><a href="#cb25-41"></a>     <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;Input is not a natural number!&quot;</span></span>
<span id="cb25-42"><a href="#cb25-42"></a>     <span class="dt">Just</span> nat <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="op">$</span> withSomeNat nat <span class="op">$</span> \ snat <span class="ot">-&gt;</span></span>
<span id="cb25-43"><a href="#cb25-43"></a>       <span class="kw">case</span> snat <span class="ot">`sLeNat`</span> (<span class="ot">sing ::</span> <span class="dt">Sing</span> <span class="dt">Bound</span>) <span class="kw">of</span></span>
<span id="cb25-44"><a href="#cb25-44"></a>         <span class="dt">STrue</span>  <span class="ot">-&gt;</span> f snat</span>
<span id="cb25-45"><a href="#cb25-45"></a>         <span class="dt">SFalse</span> <span class="ot">-&gt;</span> <span class="st">&quot;Didn&#39;t work&quot;</span></span>
<span id="cb25-46"><a href="#cb25-46"></a></span>
<span id="cb25-47"><a href="#cb25-47"></a><span class="ot">f ::</span> <span class="kw">forall</span> proxy (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="op">.</span> (n <span class="ot">`LeNat`</span> <span class="dt">Bound</span>) <span class="op">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> proxy n <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb25-48"><a href="#cb25-48"></a>f _ <span class="ot">=</span> <span class="st">&quot;It worked!&quot;</span></span></code></pre></div>
<h2 id="attempt-6-using-luquid-haskell">Attempt 6: Using Luquid haskell</h2>
<p>Ranjit Jhala, provided a great solution for liquid haskell, that could be found either by <a href="http://goto.ucsd.edu:8090/index.html#?demo=permalink%2F1418064183.hs">url</a> or here:</p>
<hr />
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="co">{-@ LIQUID &quot;--no-termination&quot; @-}</span></span>
<span id="cb26-3"><a href="#cb26-3"></a></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="kw">module</span> <span class="dt">Nat255</span> <span class="kw">where</span></span>
<span id="cb26-5"><a href="#cb26-5"></a></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="co">-- | Define a predicate for valid integers</span></span>
<span id="cb26-7"><a href="#cb26-7"></a></span>
<span id="cb26-8"><a href="#cb26-8"></a><span class="co">{-@ predicate IsValid X = 0 &lt;= X &amp;&amp; X &lt; 255 @-}</span></span>
<span id="cb26-9"><a href="#cb26-9"></a></span>
<span id="cb26-10"><a href="#cb26-10"></a><span class="co">-- | Use the predicate to define a refinement type (subset) of valid integers</span></span>
<span id="cb26-11"><a href="#cb26-11"></a></span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="co">{-@ type Valid = {v:Int | IsValid v}        @-}</span></span>
<span id="cb26-13"><a href="#cb26-13"></a></span>
<span id="cb26-14"><a href="#cb26-14"></a><span class="co">-- | A function that checks whether a given Int is indeed valid</span></span>
<span id="cb26-15"><a href="#cb26-15"></a></span>
<span id="cb26-16"><a href="#cb26-16"></a><span class="co">{-@ isValid   :: n:Int -&gt; {v:Bool | Prop v &lt;=&gt; IsValid n} @-}</span></span>
<span id="cb26-17"><a href="#cb26-17"></a>isValid n     <span class="ot">=</span> <span class="dv">0</span> <span class="op">&lt;=</span> n <span class="op">&amp;&amp;</span> n <span class="op">&lt;</span> (<span class="dv">255</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb26-18"><a href="#cb26-18"></a></span>
<span id="cb26-19"><a href="#cb26-19"></a><span class="co">-- | A function that can only be called with Valid Ints.</span></span>
<span id="cb26-20"><a href="#cb26-20"></a></span>
<span id="cb26-21"><a href="#cb26-21"></a><span class="co">{-@ workWithValidNumber :: Valid -&gt; IO () @-}</span> </span>
<span id="cb26-22"><a href="#cb26-22"></a>workWithValidNumber n <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;This is a valid number&quot;</span> <span class="op">++</span> <span class="fu">show</span> (<span class="ot">n ::</span> <span class="dt">Int</span>)</span>
<span id="cb26-23"><a href="#cb26-23"></a></span>
<span id="cb26-24"><a href="#cb26-24"></a><span class="co">-- | This is fine...</span></span>
<span id="cb26-25"><a href="#cb26-25"></a>ok    <span class="ot">=</span> workWithValidNumber <span class="dv">12</span></span>
<span id="cb26-26"><a href="#cb26-26"></a></span>
<span id="cb26-27"><a href="#cb26-27"></a><span class="co">-- | ... But this is not.        </span></span>
<span id="cb26-28"><a href="#cb26-28"></a>notOk <span class="ot">=</span> workWithValidNumber <span class="dv">257</span></span>
<span id="cb26-29"><a href="#cb26-29"></a></span>
<span id="cb26-30"><a href="#cb26-30"></a><span class="co">-- | Finally the top level loop that inputs a number, tests it </span></span>
<span id="cb26-31"><a href="#cb26-31"></a><span class="co">--   and calls `workWithValidNumber` if the number is valid.</span></span>
<span id="cb26-32"><a href="#cb26-32"></a></span>
<span id="cb26-33"><a href="#cb26-33"></a>loop <span class="ot">=</span> <span class="kw">do</span> <span class="fu">putStrLn</span> <span class="st">&quot;Enter Number between 0 and 255&quot;</span></span>
<span id="cb26-34"><a href="#cb26-34"></a>          n <span class="ot">&lt;- readLn ::</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb26-35"><a href="#cb26-35"></a>          <span class="kw">if</span> isValid n</span>
<span id="cb26-36"><a href="#cb26-36"></a>             <span class="kw">then</span> workWithValidNumber n</span>
<span id="cb26-37"><a href="#cb26-37"></a>             <span class="kw">else</span> <span class="fu">putStrLn</span> <span class="st">&quot;Humph, bad input, try again!&quot;</span> <span class="op">&gt;&gt;</span> loop</span></code></pre></div>
<p>I hope you have enjoyed reading this.</p>]]></summary>
</entry>
<entry>
    <title>Playing with types: type level numbers</title>
    <link href="https://qnikst.github.io/posts/2014-08-07-playing-with-types.html" />
    <id>https://qnikst.github.io/posts/2014-08-07-playing-with-types.html</id>
    <published>2013-12-30T00:00:00Z</published>
    <updated>2013-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>As always I’m terribly sorry for my bad english, but writing the posts and having a feedback is the only reasonable way to improve it.</p>
</blockquote>
<p>This post describes an easy exercise that gives a feeling of use typelevel numbers. This post is a part of another work that hopefully will be covered in following posts.</p>
<p>If you want to know more about typelevel literals and friends you can take a look at the <a href="http://ponies.io/posts/2014-07-30-typelits.html">following post</a> it describes the theory much better than I can.</p>
<p>Intead of using type level Strings we will address numbers. In this post I want to create a datatype that will contain a number that is known <em>statically</em> (at compilation time) and which can be extracted from type at <em>runtime</em>.</p>
<p>The first part of the problem (having a number) in a type may be interesting if you want to distiguish types assosiated with different numbers.</p>
<p>For simplicity we will take <a href="https://hackage.haskell.org/package/tagged-0.7.2/docs/Data-Tagged.html">Data.Tagged.Tagged</a> type from <code>tagged</code> package. However it’s possible to create our own type as I did at the beggining (just I did a first time).</p>
<p>We add helper methods that allow us to extract infomation about the type-parameter from the value:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">toProxy ::</span> <span class="dt">Tagged</span> n a  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n</span>
<span id="cb1-2"><a href="#cb1-2"></a>toProxy _ <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>And add a constrictor helper that allow to create a type with information about number that is provided by us.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">mkT ::</span> proxy n <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tagged</span> n a</span>
<span id="cb2-2"><a href="#cb2-2"></a>mkT _ a <span class="ot">=</span> <span class="dt">Tagged</span> a</span></code></pre></div>
<p>Just check that we can create a fancy values:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> <span class="op">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Nothing</span>) <span class="dv">8</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Nothing</span>) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> <span class="dt">&#39;Nothing</span> a</span></code></pre></div>
<h1 id="naturals">Naturals</h1>
<p>From this point we can start real fun. At first lest create a value with natural type parameter:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> <span class="op">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> <span class="dv">3</span> a</span></code></pre></div>
<p>Now we want to be able to use this information at runtime. Let’s introduce a new method that will use <code>natVal</code> function:</p>
<pre class="haskel"><code>natVal :: forall n proxy. KnownNat n =&gt; proxy n -&gt; Integer` </code></pre>
<p>take a type that acts as a type proxy and returns the integer assosiated with a type.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">useT ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Tagged</span> n a <span class="ot">-&gt;</span> a</span>
<span id="cb6-2"><a href="#cb6-2"></a>useT t<span class="op">@</span>(<span class="dt">Tagged</span> a) <span class="ot">=</span> <span class="fu">fromIntegral</span> (natVal (toProxy t)) <span class="op">+</span> a</span></code></pre></div>
<p>Here we are:</p>
<ol type="1">
<li><p>extracting type information by calling <code>toProxy</code></p></li>
<li><p>extracting natural number from a proxy by calling <code>natVal</code></p></li>
<li><p>returning a calculated results</p></li>
</ol>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> useT <span class="op">$</span> mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">3</span>) <span class="dv">8</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="dv">11</span></span></code></pre></div>
<h1 id="positive-rational">Positive rational</h1>
<p>On the next step we will introduce a code that works for natural numbers, by definition rational number is <code>a % b</code>, where <code>a \in Z</code> and <code>b \in N</code>. Lets lift this information to a type level by introducing a typelevel rational:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">data</span> (<span class="op">:%%</span>) a b</span></code></pre></div>
<p>And introduce type extraction mechanisms</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">-- | extract numerator type</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="fu">numerator</span><span class="ot"> ::</span> proxy (n <span class="op">:%%</span> m) <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n</span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="fu">numerator</span> _ <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="co">-- | Extract denomenator type </span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="ot">denomenator ::</span> proxy (n <span class="op">:%%</span> m)  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> m</span>
<span id="cb9-7"><a href="#cb9-7"></a>denomenator _ <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>Today we don’t conver math operations over the type-parameters, this may be a topic for another post. So now we may be quite happy as we can create values tagged by something that looks like a rational number.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> <span class="op">:</span>t mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="op">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="op">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (<span class="dv">3</span> <span class="op">:%%</span> <span class="dv">8</span>) a</span></code></pre></div>
<p>Now we can write a function that will use information about the type at runtime:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">useTF ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (n <span class="op">:%%</span> m) a <span class="ot">-&gt;</span> a</span>
<span id="cb11-2"><a href="#cb11-2"></a>useTF t<span class="op">@</span>(<span class="dt">Tagged</span> a) <span class="ot">=</span> v <span class="op">+</span> a</span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="kw">where</span> v <span class="ot">=</span> <span class="fu">fromRational</span> <span class="op">$</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>               natVal (<span class="fu">numerator</span> <span class="op">$</span> toProxy t) <span class="op">:%</span> natVal (denomenator <span class="op">$</span> toProxy t)</span></code></pre></div>
<p>Lets check:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> useTF <span class="op">$</span> mkT (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">3</span> <span class="op">:%%</span> <span class="dv">8</span>)) <span class="dv">8</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="fl">8.375</span></span></code></pre></div>
<h1 id="positive-real.">Positive real.</h1>
<p>Now we want to solve the following problem: it’s not easy to write types for ratio, the reason that for a complex cases we need somehow to find the ratio that fits. Also we want to support real numbers. Having in mind the fact that real values are not supported on the typelevel, we may be quite happy with Rational approximation.</p>
<p>In order to solve those 2 problems we need:</p>
<ol type="1">
<li><p>real values support</p></li>
<li><p>ability to write code easily</p></li>
</ol>
<p>We will introduce a TH function that will find a good approximation and create required type:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">mkFloatProxy ::</span> <span class="dt">RealFrac</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>mkFloatProxy x <span class="ot">=</span> [<span class="op">|</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="op">$</span>(nk a) <span class="op">:%%</span> <span class="op">$</span>(nk b)) <span class="op">|</span>]</span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="kw">where</span> (a <span class="op">:%</span> b) <span class="ot">=</span> <span class="fu">toRational</span> x</span>
<span id="cb13-4"><a href="#cb13-4"></a>          nk x <span class="ot">=</span> sigT (litT (numTyLit x)) (<span class="dt">ConT</span> <span class="op">$</span> mkName <span class="st">&quot;Nat&quot;</span>)</span></code></pre></div>
<p>the magic that we have in <code>nk x</code> we need to create a type parameter of kind <code>Nat</code>. Now we can write a code like:</p>
<blockquote>
<p>test = mkT $(mkFloatProxy pi) 7.0</p>
</blockquote>
<p>This is quite nice, next steps may be support of negative values, using SomeNat and operations on values.</p>]]></summary>
</entry>

</feed>
