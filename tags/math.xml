<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Qnikst blog RSS feed - Post tagged math</title>
    <link href="https://qnikst.github.io/tags/math.xml" rel="self" />
    <link href="https://qnikst.github.io" />
    <id>https://qnikst.github.io/tags/math.xml</id>
    <author>
        <name>Alexander Vershilov</name>
        <email>alexander.vershilov@gmail.com</email>
    </author>
    <updated>2014-08-18T00:00:00Z</updated>
    <entry>
    <title>Compositional methods for numerical ODE integrators</title>
    <link href="https://qnikst.github.io/posts/2014-08-18-compositional-methods.html" />
    <id>https://qnikst.github.io/posts/2014-08-18-compositional-methods.html</id>
    <published>2014-08-18T00:00:00Z</published>
    <updated>2014-08-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>We show a way to improve properties of a ODE integrators, by introducing a composition of the methods with a different steps.</p>
<!--more-->
<p>This post is based on the work of the Ernst Harrier [<a href="http://www.springer.com/mathematics/computational+science+%26+engineering/book/978-3-540-30663-4">1</a>] and doesn’t contain any additional research work.</p>
<p>Here we want to solve a system of equations that can we written as:</p>
<p><span class="math display">\[ \dot{y} = f(y). \]</span></p>
<p>In order to solve it we are introducing a mapping from an old state at <span class="math inline">\(t0\)</span> to a new one at <span class="math inline">\(t_1 = t_0 + dt\)</span>:</p>
<p><span class="math display">\[\Phi_h: y_{n} \rightarrow  y_{n+1}\]</span></p>
<p>In order to increase the order of the solution while preserving some desirable properties of the base method we may prepare a compositional method:</p>
<p><span class="math display">\[\Psi_h = \Phi_{\gamma_1h} \circ \ldots \circ \Phi_{\gamma_nh},\]</span></p>
<p>where <span class="math inline">\(\gamma_i\)</span> is a coefficient from <span class="math inline">\(\mathbb R\)</span>. This approach was studied by Suzuki, Yoshina, McLackcan in 1990th. Here we compose a base method at a different points in time.</p>
<p>We have a theorem about this approach to compositional methods.</p>
<p><em>Theorem</em></p>
<blockquote>
<p>Let <span class="math inline">\(\Phi_h\)</span> be a one-step method of order <span class="math inline">\(p\)</span>. If</p>
<p><span class="math display">\[
\begin{eqnarray}
\gamma_1 + \ldots + \gamma_s = 1 \\
\gamma_1^{p+1} + \ldots + \gamma_s^{p+1} = 0 \\
\end{eqnarray}
\]</span> then the compositional method <span class="math inline">\(\Psi_h\)</span> is at least of the order <span class="math inline">\(p+1\)</span>.</p>
</blockquote>
<p>This gives theorem gives us a nice way to improve properties of the existing method. The question now is how to find a good coefficients <span class="math inline">\(\gamma_i\)</span>.</p>
<p>The first notice is that equations does not have a real solution for the odd <span class="math inline">\(p\)</span>, so we can improve only solutions with even <span class="math inline">\(p\)</span>.</p>
<p>The smallest number <span class="math inline">\(s\)</span> where a solution in reals exists is <span class="math inline">\(3\)</span>. And coefficients are defined as:</p>
<p><span class="math display">\[ \gamma_1 = \gamma_3 = \frac{1}{2 - 2^{\frac{1}{p+1}}} \]</span></p>
<p><span class="math display">\[ \gamma_2 = - \frac{2^{\frac{1}{p+1}}}{2 - 2^{\frac{1}{p+1}}} \]</span></p>
<p>This method is called tripple jump. Lets check how does it work.</p>
<p>At first we will introduce a coefficients</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">g1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>g1 p <span class="ot">=</span>  <span class="dv">1</span> <span class="op">/</span> (<span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>(<span class="fu">fromIntegral</span> p<span class="op">+</span><span class="dv">1</span>)))</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="ot">g2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>g2 p <span class="ot">=</span> <span class="op">-</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>(<span class="fu">fromIntegral</span> p<span class="op">+</span><span class="dv">1</span>)) <span class="op">/</span> ( <span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>(<span class="fu">fromIntegral</span> p<span class="op">+</span><span class="dv">1</span>)))</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="ot">g3 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>g3 <span class="ot">=</span> g1</span></code></pre></div>
<p>Having a method of an order 2 (for example standard Runge-Kutta method) we may use a composition a points defined by <span class="math inline">\(\gamma_i\)</span> with <span class="math inline">\(p=2\)</span>. Let step be a <span class="math inline">\(dt = 1\)</span> for simplicity.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="op">&gt;</span><span class="ot"> t ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="op">&gt;</span> t p dt <span class="ot">=</span> <span class="fu">map</span> (<span class="op">*</span>dt) [g1 p, g2 p, g3 p]</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> t <span class="dv">2</span> <span class="dv">1</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>[<span class="fl">1.3512071919596578</span>,<span class="op">-</span><span class="fl">1.7024143839193153</span>,<span class="fl">1.3512071919596578</span>]</span></code></pre></div>
<p>We have 3 points. If we will take a compositional method <span class="math inline">\(\Psi\)</span> in the points we got then we will have a method of order <span class="math inline">\(3\)</span>. However if you method is symmetric then it’s order is <span class="math inline">\(4\)</span> and we can apply a tripple jump once again to our composed method.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="op">&gt;</span><span class="ot"> ut ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="op">&gt;</span> ut p xs <span class="ot">=</span> xs <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> t (p<span class="op">+</span><span class="dv">2</span>) x)</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> ut <span class="dv">4</span> (t <span class="dv">2</span> <span class="dv">1</span>)</span>
<span id="cb3-5"><a href="#cb3-5"></a>[<span class="fl">1.5081944151591316</span>,<span class="op">-</span><span class="fl">1.665181638358605</span>,<span class="fl">1.5081944151591316</span>,<span class="op">-</span><span class="fl">1.900205890992877</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>,<span class="fl">2.097997398066439</span>,<span class="op">-</span><span class="fl">1.900205890992877</span>,<span class="fl">1.5081944151591316</span>,<span class="op">-</span><span class="fl">1.665181638358605</span>,<span class="fl">1.5081944151591316</span>]</span></code></pre></div>
<p>This is a coefficients for a compositional method of order <span class="math inline">\(5\)</span>, (<span class="math inline">\(6\)</span> due to symmetry. Applying tripple jump nce again:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> ut <span class="dv">6</span> \<span class="op">$</span> ut <span class="dv">4</span> (t <span class="dv">2</span> <span class="dv">1</span>)</span>
<span id="cb4-2"><a href="#cb4-2"></a>[<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">1.77070200653487</span>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">1.8100975778074668</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>,<span class="fl">1.955013517256328</span>,<span class="op">-</span><span class="fl">1.8100975778074668</span>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">1.77070200653487</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">2.0655753110586246</span>,<span class="fl">2.2309447311243717</span>,<span class="op">-</span><span class="fl">2.0655753110586246</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>,<span class="fl">2.2805800406433505</span>,<span class="op">-</span><span class="fl">2.4631626832202618</span>,<span class="fl">2.2805800406433505</span>,<span class="op">-</span><span class="fl">2.0655753110586246</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>,<span class="fl">2.2309447311243717</span>,<span class="op">-</span><span class="fl">2.0655753110586246</span>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">1.77070200653487</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">1.8100975778074668</span>,<span class="fl">1.955013517256328</span>,<span class="op">-</span><span class="fl">1.8100975778074668</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">1.77070200653487</span>,<span class="fl">1.639448210847001</span>]</span></code></pre></div>
<p>this is a compositional method of order 8.</p>
<p>To see a places where function will be evaluated we can use:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> <span class="fu">scanl</span> (<span class="op">+</span>) <span class="dv">0</span> <span class="op">$</span> ut <span class="dv">6</span> <span class="op">$</span> ut <span class="dv">4</span> (t <span class="dv">2</span> <span class="dv">1</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a>[<span class="fl">0.0</span>,<span class="fl">1.639448210847001</span>,<span class="op">-</span><span class="fl">0.131253795687869</span>,<span class="fl">1.508194415159132</span>,<span class="op">-</span><span class="fl">0.30190316264833483</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>,<span class="fl">1.6531103546079933</span>,<span class="op">-</span><span class="fl">0.15698722319947356</span>,<span class="fl">1.4824609876475274</span>,<span class="op">-</span><span class="fl">0.28824101888734255</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>,<span class="fl">1.3512071919596584</span>,<span class="op">-</span><span class="fl">0.7143681190989661</span>,<span class="fl">1.5165766120254056</span>,<span class="op">-</span><span class="fl">0.548998699033219</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>,<span class="fl">1.7315813416101316</span>,<span class="op">-</span><span class="fl">0.7315813416101302</span>,<span class="fl">1.5489986990332203</span>,<span class="op">-</span><span class="fl">0.5165766120254043</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>,<span class="fl">1.7143681190989675</span>,<span class="op">-</span><span class="fl">0.3512071919596571</span>,<span class="fl">1.2882410188873439</span>,<span class="op">-</span><span class="fl">0.4824609876475261</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>,<span class="fl">1.156987223199475</span>,<span class="op">-</span><span class="fl">0.6531103546079919</span>,<span class="fl">1.3019031626483362</span>,<span class="op">-</span><span class="fl">0.5081944151591307</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>,<span class="fl">1.1312537956878703</span>,<span class="op">-</span><span class="fl">0.6394482108469997</span>,<span class="fl">1.0000000000000013</span>]</span></code></pre></div>
<p>This way we may obtain a method of any order by the price of a terrible zig-zag of the step points.</p>
<p>Another approach to a compositional method is using Suzuki`s Fractals.</p>
<p>The same schema exists for Suzuki`s Fractals, however how we have a diffierent coefficients:</p>
<p><span class="math display">\[
\begin{eqnarray}
  \gamma_1 = \gamma_2 = \gamma_4 = \gamma_5 = \frac{1}{4-4^{\frac{1}{p+1}}} \\
  \gamma_3 = - \frac{4^{\frac{1}{p+1}}}{4-4^{\frac{1}{p+1}}}
\end{eqnarray}
\]</span></p>
<p>However <span class="math inline">\(t\)</span> and <span class="math inline">\(ut\)</span> methods looks quite ugly and we may want to improve this situation.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)</span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb6-15"><a href="#cb6-15"></a></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="co">-- Coefficients</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="ot">g1 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>g1 p <span class="ot">=</span>  <span class="dv">1</span> <span class="op">/</span> (<span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>(<span class="fu">fromIntegral</span> p<span class="op">+</span><span class="dv">1</span>)))</span>
<span id="cb6-19"><a href="#cb6-19"></a></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="ot">g2 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>g2 p <span class="ot">=</span> <span class="op">-</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>(<span class="fu">fromIntegral</span> p<span class="op">+</span><span class="dv">1</span>)) <span class="op">/</span> ( <span class="dv">2</span> <span class="op">-</span> <span class="dv">2</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span>(<span class="fu">fromIntegral</span> p<span class="op">+</span><span class="dv">1</span>)))</span>
<span id="cb6-22"><a href="#cb6-22"></a></span>
<span id="cb6-23"><a href="#cb6-23"></a><span class="ot">g3 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb6-24"><a href="#cb6-24"></a>g3 <span class="ot">=</span> g1</span>
<span id="cb6-25"><a href="#cb6-25"></a></span>
<span id="cb6-26"><a href="#cb6-26"></a><span class="co">-- Description of the method</span></span>
<span id="cb6-27"><a href="#cb6-27"></a><span class="kw">data</span> <span class="dt">RK2</span> <span class="ot">=</span> <span class="dt">RK2</span></span>
<span id="cb6-28"><a href="#cb6-28"></a></span>
<span id="cb6-29"><a href="#cb6-29"></a><span class="co">-- Description of the method order</span></span>
<span id="cb6-30"><a href="#cb6-30"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Order</span><span class="ot"> a ::</span> <span class="dt">Nat</span></span>
<span id="cb6-31"><a href="#cb6-31"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Order</span> <span class="dt">RK2</span> <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb6-32"><a href="#cb6-32"></a></span>
<span id="cb6-33"><a href="#cb6-33"></a><span class="co">-- Description of symmetric properties of the method</span></span>
<span id="cb6-34"><a href="#cb6-34"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">IsSymmetric</span><span class="ot"> a ::</span> <span class="dt">Constraint</span></span>
<span id="cb6-35"><a href="#cb6-35"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">IsSymmetric</span> <span class="dt">RK2</span> <span class="ot">=</span> ()</span>
<span id="cb6-36"><a href="#cb6-36"></a></span>
<span id="cb6-37"><a href="#cb6-37"></a><span class="co">-- One level composition</span></span>
<span id="cb6-38"><a href="#cb6-38"></a><span class="ot">buildComposePoints ::</span> <span class="kw">forall</span> p <span class="op">.</span> <span class="dt">KnownNat</span> (<span class="dt">Order</span> p)</span>
<span id="cb6-39"><a href="#cb6-39"></a>                   <span class="ot">=&gt;</span> p <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb6-40"><a href="#cb6-40"></a>buildComposePoints p dt <span class="ot">=</span> <span class="fu">map</span> (<span class="op">*</span>dt) [g1 o, g2 o, g3 o]</span>
<span id="cb6-41"><a href="#cb6-41"></a>  <span class="kw">where</span></span>
<span id="cb6-42"><a href="#cb6-42"></a>    o <span class="ot">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Order</span> p))</span>
<span id="cb6-43"><a href="#cb6-43"></a></span>
<span id="cb6-44"><a href="#cb6-44"></a><span class="co">-- Composition for the symmetric method</span></span>
<span id="cb6-45"><a href="#cb6-45"></a><span class="ot">buildComposePointsSym ::</span> <span class="kw">forall</span> p n <span class="op">.</span> (<span class="dt">UpdateCompose</span> (<span class="dt">Order</span> p <span class="op">+</span> <span class="dv">2</span>) n, <span class="dt">IsSymmetric</span> p, <span class="dt">KnownNat</span> (<span class="dt">Order</span> p), <span class="dt">KnownNat</span> n)</span>
<span id="cb6-46"><a href="#cb6-46"></a>                      <span class="ot">=&gt;</span> p <span class="ot">-&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb6-47"><a href="#cb6-47"></a>buildComposePointsSym p pn dt <span class="ot">=</span> update (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> ((<span class="dt">Order</span> p) <span class="op">+</span> <span class="dv">2</span>)) pn (buildComposePoints p dt)</span>
<span id="cb6-48"><a href="#cb6-48"></a></span>
<span id="cb6-49"><a href="#cb6-49"></a><span class="kw">class</span> <span class="dt">UpdateCompose</span> (<span class="ot">k ::</span> <span class="dt">Nat</span>) (<span class="ot">v::</span><span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb6-50"><a href="#cb6-50"></a><span class="ot">  update ::</span> <span class="dt">Proxy</span> k <span class="ot">-&gt;</span> <span class="dt">Proxy</span> v <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb6-51"><a href="#cb6-51"></a></span>
<span id="cb6-52"><a href="#cb6-52"></a><span class="kw">class</span> <span class="dt">UpdateComposeCase</span> (<span class="ot">leq ::</span> <span class="dt">Bool</span>) (<span class="ot">k ::</span> <span class="dt">Nat</span>) (<span class="ot">v ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb6-53"><a href="#cb6-53"></a><span class="ot">  updateCase ::</span> <span class="dt">Proxy</span> leq <span class="ot">-&gt;</span> <span class="dt">Proxy</span> k <span class="ot">-&gt;</span> <span class="dt">Proxy</span> v <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb6-54"><a href="#cb6-54"></a></span>
<span id="cb6-55"><a href="#cb6-55"></a><span class="kw">instance</span> <span class="dt">UpdateComposeCase</span> (k <span class="op">&lt;=?</span> v) k v <span class="ot">=&gt;</span> <span class="dt">UpdateCompose</span> k v <span class="kw">where</span></span>
<span id="cb6-56"><a href="#cb6-56"></a>  update <span class="ot">=</span> updateCase (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (k <span class="op">&lt;=?</span> v))</span>
<span id="cb6-57"><a href="#cb6-57"></a></span>
<span id="cb6-58"><a href="#cb6-58"></a><span class="kw">instance</span> <span class="dt">UpdateComposeCase</span> <span class="dt">False</span> k v <span class="kw">where</span></span>
<span id="cb6-59"><a href="#cb6-59"></a>  updateCase _ _ _ <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb6-60"><a href="#cb6-60"></a>  </span>
<span id="cb6-61"><a href="#cb6-61"></a><span class="kw">instance</span> (<span class="dt">KnownNat</span> k, <span class="dt">UpdateCompose</span> (k<span class="op">+</span><span class="dv">2</span>) v) <span class="ot">=&gt;</span> <span class="dt">UpdateComposeCase</span> <span class="dt">True</span> k v <span class="kw">where</span></span>
<span id="cb6-62"><a href="#cb6-62"></a>  updateCase _ k v ds <span class="ot">=</span> update (plus2 k) v (ds <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> <span class="fu">map</span> (<span class="op">*</span>x) [g1 o, g2 o, g3 o])</span>
<span id="cb6-63"><a href="#cb6-63"></a>    <span class="kw">where</span></span>
<span id="cb6-64"><a href="#cb6-64"></a>      o <span class="ot">=</span> natVal k</span>
<span id="cb6-65"><a href="#cb6-65"></a><span class="ot">      plus2 ::</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">Proxy</span> (n<span class="op">+</span><span class="dv">2</span>)</span>
<span id="cb6-66"><a href="#cb6-66"></a>      plus2 _ <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>]]></summary>
</entry>
<entry>
    <title>Formal Power series in haskell</title>
    <link href="https://qnikst.github.io/posts/2014-08-11-series.markdown.html" />
    <id>https://qnikst.github.io/posts/2014-08-11-series.markdown.html</id>
    <published>2014-08-12T00:00:00Z</published>
    <updated>2014-08-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Code and math in this post is done with the great help of Korolyov V. This post is written as a literate haskell file so it’s possible to copy it in a text file and run it in ghci. All sources can be found in <a href="https://github.com/qnikst/haskell-fun/tree/master/series">haskell-fun</a> repository.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">import</span> <span class="dt">Control.Monad.Fix</span></span></code></pre></div>
<p>We want to implement a with formal series expansion using haskell. Formal series can be expressed as follows:</p>
<p><span class="math display">\[ f(x) = \sum\limits_{i=0}^\infty a_ix^i \]</span></p>
<p>And also address a Taylor series as an example. For a function <span class="math inline">\(f\)</span> we can expand it an any given point <span class="math inline">\(x_0\)</span>, then:</p>
<p><span class="math display">\[ f(x) = f(x_0) + \sum_{k=1}\frac{f^{(k)}}{k!}(x-x_0)^k \]</span></p>
<p>Here we wanto to introduce a data structure that is capable for representation of such series. For such datastructure we have 2 main candidates:</p>
<ol type="1">
<li><p>List - a datastructure with two constructors that represent a possibly infinite single-linked list.</p></li>
<li><p>Stream - a datastructure with one constructor that represent an infinite stream of values.</p></li>
</ol>
<p>We may want to select a list because this way we may represent a finite series (as some functions have all coefficients equal to <span class="math inline">\(0\)</span> starting at some point, or if function diverge than all element will be represented as machine zero starting at some point). But we decide to use ‘Stream’ data type in order not to have a branching in functions.</p>
<p>It’s possible to use an existing library for <code>Stream</code> – <a href="https://hackage.haskell.org/package/Stream">Stream package</a>. However here we decide to implement our own data type for educational purposes. However if this module will grow to a real library the implementation likely will be changed to the one from the common package.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span> <span class="dt">S</span> a <span class="ot">=</span> <span class="dt">S</span> <span class="op">!</span>a (<span class="dt">S</span> a)</span></code></pre></div>
<p>## Instances</p>
<p>Having a data structure we may define a set of instances.</p>
<p>### Functor</p>
<p>Series is a Functor:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">S</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>   <span class="fu">fmap</span> f (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="dt">S</span> (f a) (<span class="fu">fmap</span> f x)</span></code></pre></div>
<p>An interesting note that <span class="math inline">\(fmap ~ (f :: a \to b)\)</span> moves a function that is represented by a serie from <span class="math inline">\(a \to a\)</span> to <span class="math inline">\(b \to b\)</span> that may not be a desired behaviour when <span class="math inline">\(a \neq b\)</span>.</p>
<p>### Num</p>
<p>In order to use series in calculations we need to define a <code>Num</code> instance. But befor we will introduce few helpers:</p>
<p>A product of scalar and series:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">(^*) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb4-2"><a href="#cb4-2"></a>(<span class="op">^*</span>) a <span class="ot">=</span> <span class="fu">fmap</span> (<span class="op">*</span>a)</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">(*^) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb5-2"><a href="#cb5-2"></a>(<span class="op">*^</span>) <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">^*</span>)</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">(/^) ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb6-2"><a href="#cb6-2"></a>(<span class="op">/^</span>) s a <span class="ot">=</span> <span class="fu">fmap</span> (<span class="op">/</span> a) s</span></code></pre></div>
<p>And pointwise product for future (see Library section for szipWith implementation):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">(^*^) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb7-2"><a href="#cb7-2"></a>(<span class="op">^*^</span>) <span class="ot">=</span> szipWith (<span class="op">*</span>)</span></code></pre></div>
<p>Now we may give a ‘Num’ instance:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Num</span> (<span class="dt">S</span> a) <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>  (<span class="dt">S</span> a x) <span class="op">+</span> (<span class="dt">S</span> b y) <span class="ot">=</span> <span class="dt">S</span> (a <span class="op">+</span> b) (x <span class="op">+</span> y)</span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="fu">abs</span> s <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">abs</span> s</span>
<span id="cb8-4"><a href="#cb8-4"></a>  <span class="fu">negate</span> s <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">negate</span> s</span>
<span id="cb8-5"><a href="#cb8-5"></a>  <span class="fu">signum</span> s <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">signum</span> s</span>
<span id="cb8-6"><a href="#cb8-6"></a>  (<span class="dt">S</span> a x) <span class="op">*</span> (<span class="dt">S</span> b y) <span class="ot">=</span> <span class="dt">S</span> (a <span class="op">*</span> b) (a <span class="op">^*</span> y <span class="op">+</span>  b <span class="op">^*</span> x <span class="op">+</span> <span class="dt">S</span> <span class="dv">0</span> (x <span class="op">*</span> y))</span>
<span id="cb8-7"><a href="#cb8-7"></a>  <span class="fu">fromInteger</span> x <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">fromInteger</span> x) <span class="dv">0</span></span></code></pre></div>
<p>Here are 2 tricky parts, first one is implementation of <code>*</code> second one is implementation of <code>fromInteger</code>. For <code>*</code> we need to think of an expansion like of polymonial, i.e. <span class="math inline">\(S a b = a + b \cdot p\)</span>. Then we can write the following:</p>
<p><span class="math display">\[
\begin{aligned}
 (S~a~x) \cdot (S~b~y) &amp;= (a + x p) \cdot (b + y p) = \\
  &amp;= (a b + a y p + b x p + x y p^2) = \\
  &amp;= S~(a b)~(a y + b x + x y p)     = \\
  &amp;= S~(a b)~(fmap~(*a)~y + fmap~(*b)~x + S~0~(x * y))
\end{aligned}
\]</span></p>
<p>There are 2 possible implementations for fromInteger:</p>
<ol type="1">
<li><p><code>fromInteger x = S (fromInteger x) (fromInteger x)</code></p></li>
<li><p><code>fromInteger x = S (fromInteger x) 0</code></p></li>
</ol>
<p>For <code>fromInteger</code> we need to select an implemention such that <span class="math inline">\(fromInteger 1 * a == a\)</span> <span class="math inline">\(fromInteger 0 + a = a\)</span> <span class="math inline">\(fromInteger 0 * a == 0\)</span> for any <span class="math inline">\(a\)</span>. So then we see that we can select only the second one, otherwise properties for <span class="math inline">\(1\)</span> will not hold.</p>
<p>### Fractional</p>
<p>Now we can add a simple Fractional instance.</p>
<p>We say that <span class="math inline">\((S\,b\,y) = \cfrac{1}{(S\, a\, x)}\)</span> iff <span class="math inline">\((S\, b\, y)\)</span> is the solution of equation <span class="math inline">\((S\,b\,y)\,\cdot\,(S\,a\,x) = 1\)</span>. So the following intance is the result of this system of equations:</p>
<p><span class="math display">\[
\begin{aligned}
  b_0 a_0 &amp; = 1,\\
  b_0 a_1 + b_1 a_0 &amp; = 0,\\
  b_0 a_2 + b_1 a_1 + a_2 a_0 &amp; = 0,\\
  \ldots
\end{aligned}
\]</span></p>
<p>These equations can be resursively solved by moving the last term from left-side convolutions to the right side, and dividing by <span class="math inline">\((-a_0)\)</span>. Moreover the rest of terms on the left are convolutions too, then as now series <span class="math inline">\(a\)</span> convolve with the tail of series <span class="math inline">\(b\)</span>. That fact may be used for compact of definition of recursive equations:</p>
<p><span class="math display">\[
\begin{aligned}
  b_0 &amp; = \cfrac{1}{a_0},\\
  b_i &amp; = \cfrac{-1}{a_0} \sum\limits_{j = 0}^{i - 1} b_{j} a_{j + 1}.
\end{aligned}
\]</span></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">instance</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Fractional</span> (<span class="dt">S</span> a) <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="fu">recip</span> (<span class="dt">S</span> a x) <span class="ot">=</span> fix <span class="op">$</span> <span class="fu">fmap</span> (<span class="op">/</span> (<span class="op">-</span>a)) <span class="op">.</span> <span class="dt">S</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">.</span> (<span class="op">*</span> x)</span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="fu">fromRational</span> x <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">fromRational</span> x) <span class="dv">0</span></span></code></pre></div>
<p>Formulas for composition and inversion. Only series with zeroed head can be composed or reversed. Composition is handled according to Horner’s method:</p>
<p><span class="math display">\[
\begin{aligned}
  f(x) &amp;= \sum\limits_{i=0}^{\infty} a_i x^i =
           a_0 + x \sum\limits_{i=0}^{\infty} a_{i+1} x^i,\\
  g(x) &amp;= \sum\limits_{j=1}^{\infty} b_j x^j =
           x \sum\limits_{j=0}^{\infty} b_{j+1} x^j, \\
  f(g(x)) &amp;= a_0 + g(x) \sum\limits_{i=0}^{\infty} a_{i+1} g(x)^i = \\
          &amp;= a_0 + x \left(\sum\limits_{j=0}^{\infty} b_{j+1} x^j\right)
              \left(\sum\limits_{i=0}^{\infty} a_{i+1} g(x)^i\right).
\end{aligned}
\]</span></p>
<p>The product of two series can be treated recursively, so:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">compose ::</span> (<span class="dt">Num</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb10-2"><a href="#cb10-2"></a>compose (<span class="dt">S</span> a x) (<span class="dt">S</span> <span class="dv">0</span> y) <span class="ot">=</span> <span class="dt">S</span> a (y <span class="op">*</span> compose x (<span class="dt">S</span> <span class="dv">0</span> y))</span>
<span id="cb10-3"><a href="#cb10-3"></a>compose _ _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;compose: Non-zero head&quot;</span></span></code></pre></div>
<p>Inversion can be done by the following formula:</p>
<p><span class="math display">\[
\begin{eqnarray}
  f(g(x)) &amp; = x, \\
  a_1 g(x) + a_2 g^2(x) + \ldots &amp; = x, \\
  g(x) (a_1 + a_2 g(x) + \ldots) &amp; = x, \\
  b_1 x + b_2 x^2 + \ldots &amp; = \cfrac{x}{a_1 + a_2 g(x) + \ldots}, \\
  b_1 + b_2 x + \ldots &amp; = \cfrac{1}{a_1 + a_2 g(x) + \ldots}.
\end{eqnarray}
\]</span></p>
<p>The last equality gives the recursive rule:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">inverse ::</span> (<span class="dt">Fractional</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb11-2"><a href="#cb11-2"></a>inverse (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> <span class="kw">let</span> y <span class="ot">=</span> <span class="dt">S</span> <span class="dv">0</span> (<span class="fu">recip</span> <span class="op">$</span> compose x y) <span class="kw">in</span> y</span>
<span id="cb11-3"><a href="#cb11-3"></a>inverse _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;inverse: Non-zero head&quot;</span></span></code></pre></div>
<p>According to general theory elementary special functions cannot be evaluated on the non-zero headed series. We try to handle this situaton by breaking the series into two parts: the head and the zero-headed tail.</p>
<p>The head is treated by classic functions, the tail is treated by composing argument series with classical series of elementary functions, and the combination is done by ad-hoc formulas. The first example of the ad-hoc formula:</p>
<p><span class="math display">\[
\begin{eqnarray}
  \sin \sum\limits_{i = 0}^{\infty} a_i x^i =
       \sin (a_0 + \sum\limits_{i = 1}^{\infty} a_i x^i) =
  \sin a_0 \cdot \cos \sum\limits_{i = 1}^{\infty} a_i x^i +
       \cos a_0 \cdot \sin \sum\limits_{i = 1}^{\infty} a_i x^i.
\end{eqnarray}
\]</span></p>
<p>Here <span class="math inline">\(\cos a_0\)</span> and <span class="math inline">\(\sin a_0\)</span> are sine and cosine of scalar. And the sine/cosine of zero-headed series can be calculated by composition of the argument with well-known series of sine/cosine.</p>
<p>The second example. Let’s look at the <span class="math inline">\(\arcsin\)</span>, definitions:</p>
<p><span class="math display">\[
\begin{eqnarray}
  \sum\limits_{i = 0}^{\infty} b_i x^i = \arcsin \sum\limits_{i = 0}^{\infty} a_i x^i,\\
  \sin\sum\limits_{i = 0}^{\infty} b_i x^i = \sum\limits_{i = 0}^{\infty} a_i x^i.
\end{eqnarray}
\]</span></p>
<p>And solution for an ad-hoc formula is obtained as follows (using the fact <span class="math inline">\(b_0 = \arcsin a_0\)</span>):</p>
<p><span class="math display">\[
\begin{eqnarray}
  \sin\sum\limits_{i = 1}^{\infty} b_i x^i =
    \sin\left(\sum\limits_{i = 0}^{\infty} b_i x^i - b_0 \right) = \\
  = \cos b_0 \cdot \sin\sum\limits_{i = 0}^{\infty} b_i x^i -
    \sin b_0 \cdot \cos\sum\limits_{i = 0}^{\infty} b_i x^i = \\
  = \sqrt{1 - a_0^2} \cdot \sum\limits_{i = 0}^{\infty} a_i x^i -
    a_0 \cdot \sqrt{1 - \left(\sum\limits_{i = 0}^{\infty} a_i x^i\right)^2}.
\end{eqnarray}
\]</span></p>
<p>The full formula is done by adding <span class="math inline">\(b_0\)</span>:</p>
<p><span class="math display">\[
\begin{equation}
  \sum\limits_{i = 0}^{\infty} b_i x^i =
    \arcsin a_0 + \arcsin
       \left[
       \sqrt{1 - a_0^2} \cdot
       \sum\limits_{i = 0}^{\infty} a_i x^i -
       a_0 \cdot \sqrt{1 - \left(\sum\limits_{i = 0}^{\infty} a_i x^i\right)^2}
       \right].
\end{equation}
\]</span></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">instance</span> (<span class="dt">Floating</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Floating</span> (<span class="dt">S</span> a) <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>  <span class="fu">pi</span> <span class="ot">=</span> <span class="dt">S</span> <span class="fu">pi</span> <span class="dv">0</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="fu">exp</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> texp <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb12-4"><a href="#cb12-4"></a>  <span class="fu">exp</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="fu">exp</span> a <span class="op">^*</span> <span class="fu">exp</span> (<span class="dt">S</span> <span class="dv">0</span> x)</span>
<span id="cb12-5"><a href="#cb12-5"></a>  <span class="fu">log</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> tlog <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb12-6"><a href="#cb12-6"></a>  <span class="fu">log</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">log</span> a) <span class="dv">0</span> <span class="op">+</span> <span class="fu">log</span> (<span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> <span class="fu">fmap</span> (<span class="op">/</span> a) x)</span>
<span id="cb12-7"><a href="#cb12-7"></a>  <span class="fu">sin</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> tsin <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb12-8"><a href="#cb12-8"></a>  <span class="fu">sin</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="fu">sin</span> a <span class="op">^*</span> <span class="fu">cos</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="op">+</span> <span class="fu">cos</span> a <span class="op">^*</span> <span class="fu">sin</span> (<span class="dt">S</span> <span class="dv">0</span> x)</span>
<span id="cb12-9"><a href="#cb12-9"></a>  <span class="fu">cos</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> tcos <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb12-10"><a href="#cb12-10"></a>  <span class="fu">cos</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="fu">cos</span> a <span class="op">^*</span> <span class="fu">cos</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="op">-</span> <span class="fu">sin</span> a <span class="op">^*</span> <span class="fu">sin</span> (<span class="dt">S</span> <span class="dv">0</span> x)</span></code></pre></div>
<p>An interesting example is sqrt, as usual we want to find <span class="math inline">\(b_n\)</span> such that:</p>
<p><span class="math display">\[ \sum\limits_{n=0}^\infty b_nx^n \cdot \sum\limits_{n=0}^\infty b_nx^n = \sum\limits_{n=0}^n a_i x^n \]</span></p>
<p>Rewrite the formula in a head-tail form, where <span class="math inline">\(y\)</span> – is a tail of b, and <span class="math inline">\(p\)</span> – is a tail of incomming series:</p>
<p><span class="math display">\[ (b_0 + x * y) (b_ 0 + x * y) = a0 + x p\]</span></p>
<p><span class="math display">\[ b_0^2 + 2 x y + x^2 y = a0 + x p\]</span></p>
<p>by grouping elements with 0 and 1 power of <span class="math inline">\(x\)</span>, we find:</p>
<p><span class="math display">\[
\begin{equation}
  \left\lbrace
  \begin{matrix}
     b_0 &amp; = \sqrt{a_0} \\
     y &amp; = \frac{p-y^2}{2 \sqrt{a_0}}
  \end{matrix}
  \right.
\end{equation}
\]</span></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a>  <span class="fu">sqrt</span> (<span class="dt">S</span> <span class="dv">0</span> (<span class="dt">S</span> <span class="dv">0</span> x)) <span class="ot">=</span> <span class="dt">S</span> <span class="dv">0</span> (<span class="fu">sqrt</span> x)</span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="fu">sqrt</span> (<span class="dt">S</span> <span class="dv">0</span> _) <span class="ot">=</span> <span class="kw">let</span> sq <span class="ot">=</span> <span class="dt">S</span> (<span class="dv">0</span> <span class="op">/</span> <span class="dv">0</span>) sq <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> sq</span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="fu">sqrt</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="kw">let</span> sqa <span class="ot">=</span> <span class="fu">sqrt</span> a</span>
<span id="cb13-4"><a href="#cb13-4"></a>                     sqx <span class="ot">=</span> (x <span class="op">-</span> <span class="dt">S</span> <span class="dv">0</span> (sqx <span class="op">*</span> sqx)) <span class="op">/^</span> (<span class="dv">2</span> <span class="op">*</span> <span class="fu">sqrt</span> a)</span>
<span id="cb13-5"><a href="#cb13-5"></a>                 <span class="kw">in</span> <span class="dt">S</span> sqa sqx</span>
<span id="cb13-6"><a href="#cb13-6"></a>  <span class="fu">asin</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> tasin <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb13-7"><a href="#cb13-7"></a>  <span class="fu">asin</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="kw">let</span> <span class="dt">S</span> _ y <span class="ot">=</span> <span class="fu">sqrt</span> (<span class="dv">1</span> <span class="op">-</span> a <span class="op">*</span> a) <span class="op">^*</span> (<span class="dt">S</span> a x) <span class="op">-</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>                             a <span class="op">^*</span> <span class="fu">sqrt</span> (<span class="dv">1</span> <span class="op">-</span> (<span class="dt">S</span> a x) <span class="op">*</span> (<span class="dt">S</span> a x))</span>
<span id="cb13-9"><a href="#cb13-9"></a>                 <span class="kw">in</span> <span class="dt">S</span> (<span class="fu">asin</span> a) <span class="dv">0</span> <span class="op">+</span> <span class="fu">asin</span> (<span class="dt">S</span> <span class="dv">0</span> y)</span>
<span id="cb13-10"><a href="#cb13-10"></a>  <span class="fu">acos</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> tacos <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb13-11"><a href="#cb13-11"></a>  <span class="fu">acos</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="kw">let</span> <span class="dt">S</span> _ y <span class="ot">=</span> a <span class="op">^*</span> (<span class="dt">S</span> a x) <span class="op">-</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>                             <span class="fu">sqrt</span> (<span class="dv">1</span> <span class="op">-</span> a <span class="op">*</span> a) <span class="op">^*</span> <span class="fu">sqrt</span> (<span class="dv">1</span> <span class="op">-</span> (<span class="dt">S</span> a x) <span class="op">*</span> (<span class="dt">S</span> a x))</span>
<span id="cb13-13"><a href="#cb13-13"></a>                 <span class="kw">in</span> <span class="dt">S</span> (<span class="fu">acos</span> a) <span class="dv">0</span> <span class="op">+</span> <span class="fu">acos</span> (<span class="dt">S</span> <span class="dv">0</span> y)</span>
<span id="cb13-14"><a href="#cb13-14"></a>  <span class="fu">atan</span> (<span class="dt">S</span> <span class="dv">0</span> x) <span class="ot">=</span> tatan <span class="ot">`compose`</span> <span class="dt">S</span> <span class="dv">0</span> x</span>
<span id="cb13-15"><a href="#cb13-15"></a>  <span class="fu">atan</span> (<span class="dt">S</span> a x) <span class="ot">=</span> <span class="kw">let</span> <span class="dt">S</span> _ y <span class="ot">=</span> <span class="dt">S</span> <span class="dv">0</span> x <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> a <span class="op">^*</span> (<span class="dt">S</span> a x))</span>
<span id="cb13-16"><a href="#cb13-16"></a>                 <span class="kw">in</span> <span class="dt">S</span> (<span class="fu">atan</span> a) <span class="dv">0</span> <span class="op">+</span> <span class="fu">atan</span> (<span class="dt">S</span> <span class="dv">0</span> y)</span>
<span id="cb13-17"><a href="#cb13-17"></a>  <span class="fu">sinh</span> x <span class="ot">=</span> (<span class="fu">exp</span> x <span class="op">-</span> <span class="fu">exp</span> (<span class="op">-</span>x)) <span class="op">/^</span> <span class="dv">2</span></span>
<span id="cb13-18"><a href="#cb13-18"></a>  <span class="fu">cosh</span> x <span class="ot">=</span> (<span class="fu">exp</span> x <span class="op">+</span> <span class="fu">exp</span> (<span class="op">-</span>x)) <span class="op">/^</span> <span class="dv">2</span></span>
<span id="cb13-19"><a href="#cb13-19"></a>  <span class="fu">asinh</span> x <span class="ot">=</span> <span class="fu">log</span> (x <span class="op">+</span> <span class="fu">sqrt</span> (x <span class="op">*</span> x <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb13-20"><a href="#cb13-20"></a>  <span class="fu">acosh</span> x <span class="ot">=</span> <span class="fu">undefined</span> <span class="co">-- log (x + sqrt (x * x - 1))</span></span>
<span id="cb13-21"><a href="#cb13-21"></a>  <span class="fu">atanh</span> x <span class="ot">=</span> <span class="fu">log</span> ((<span class="dv">1</span> <span class="op">+</span> x) <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> x)) <span class="op">/^</span> <span class="dv">2</span></span></code></pre></div>
<p>## Library</p>
<p>Now we can define mathematic functions on the power series. The derivative:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="ot">diff ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb14-2"><a href="#cb14-2"></a>diff s <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">fromInteger</span> (fromList [<span class="dv">1</span><span class="op">..</span>]) <span class="op">^*^</span> stail s</span></code></pre></div>
<p>And the integral:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">integral ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb15-2"><a href="#cb15-2"></a>integral c  s <span class="ot">=</span> <span class="dt">S</span> c (s <span class="op">^*^</span> <span class="fu">fmap</span> (<span class="fu">recip</span><span class="op">.</span><span class="fu">fromInteger</span>) (fromList [<span class="dv">1</span><span class="op">..</span>]) )</span></code></pre></div>
<p>### Generic functions:</p>
<p>In order to inspect a stream we can introduce a helper function:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="ot">stake ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb16-2"><a href="#cb16-2"></a>stake <span class="dv">0</span> _       <span class="ot">=</span> []</span>
<span id="cb16-3"><a href="#cb16-3"></a>stake n (<span class="dt">S</span> a s) <span class="ot">=</span> a<span class="op">:</span>stake (n<span class="op">-</span><span class="dv">1</span>) s</span></code></pre></div>
<p>Here all functions will be prefixed with <code>s</code> however if you write a module for working with streams you may prefer to not add it and ask user to import module qualified.</p>
<p>Here is a function that builds a stream from the list (and the other way):</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="ot">fromList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb17-2"><a href="#cb17-2"></a>fromList (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">S</span> x (fromList xs) <span class="co">-- works only on infinite list</span></span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="ot">fromListNum ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb17-5"><a href="#cb17-5"></a>fromListNum [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>fromListNum (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">S</span> x (fromListNum xs)</span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="ot">toList ::</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb17-9"><a href="#cb17-9"></a>toList (<span class="dt">S</span> x xs) <span class="ot">=</span> x <span class="op">:</span> toList xs</span></code></pre></div>
<p>In order to write an usefull functions and series we will introduce a folding:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="ot">sscan ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> b <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb18-2"><a href="#cb18-2"></a>sscan f i (<span class="dt">S</span> x s) <span class="ot">=</span></span>
<span id="cb18-3"><a href="#cb18-3"></a> <span class="kw">let</span> k <span class="ot">=</span> f i x</span>
<span id="cb18-4"><a href="#cb18-4"></a> <span class="kw">in</span> <span class="dt">S</span> k (sscan f k s)</span></code></pre></div>
<p>Now lets introduce few functions using <code>sfold</code>. A function that will generate a sum of the Stream, i.e. having a stream <code>ssum &lt;a0:a1:a2:..&gt; = &lt;a0:a0+a1:a0+a1+a2:...&gt;</code></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">ssum ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb19-2"><a href="#cb19-2"></a>ssum <span class="ot">=</span> sscan (<span class="op">+</span>) <span class="dv">0</span></span></code></pre></div>
<p>Build a stream by iterating a function</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="ot">siterate ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb20-2"><a href="#cb20-2"></a>siterate f x <span class="ot">=</span> <span class="dt">S</span> x (siterate f (f x))</span></code></pre></div>
<p>Build a serie of powers: <span class="math inline">\(&lt;x,x^2,x^3,...&gt;\)</span></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a>spower x <span class="ot">=</span> <span class="dt">S</span> <span class="dv">1</span> (siterate (<span class="op">*</span>x) x)</span></code></pre></div>
<p>Unfold</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="ot">sunfold ::</span> (c <span class="ot">-&gt;</span> (c,a)) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb22-2"><a href="#cb22-2"></a>sunfold f k <span class="ot">=</span> <span class="kw">let</span> (k&#39;,a) <span class="ot">=</span> f k <span class="kw">in</span> <span class="dt">S</span> a (sunfold f k&#39;)</span></code></pre></div>
<p>Because we want to implement a teylor serie we want to have a serie of factorials</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="ot">sfac ::</span> (<span class="dt">Enum</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb23-2"><a href="#cb23-2"></a>sfac <span class="ot">=</span> sscan (<span class="op">*</span>) <span class="dv">1</span> (fromList [<span class="dv">1</span><span class="op">..</span>]) </span></code></pre></div>
<p>And now 1/factorials</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="ot">sdfac ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb24-2"><a href="#cb24-2"></a>sdfac <span class="ot">=</span> <span class="fu">fmap</span> (\x <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="op">/</span> (<span class="fu">fromIntegral</span> x)) sfac</span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="ot">szipWith ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> b <span class="ot">-&gt;</span> <span class="dt">S</span> c</span>
<span id="cb25-2"><a href="#cb25-2"></a>szipWith f (<span class="dt">S</span> a x) (<span class="dt">S</span> b y) <span class="ot">=</span> <span class="dt">S</span> (f a b) (szipWith f x y)</span></code></pre></div>
<p>This is an actual building of the Taylor serie:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a><span class="ot">build ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb26-2"><a href="#cb26-2"></a>build t s <span class="ot">=</span> ssum <span class="op">$</span> spower t <span class="op">^*^</span> s</span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a><span class="ot">shead ::</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb27-2"><a href="#cb27-2"></a>shead (<span class="dt">S</span> a s) <span class="ot">=</span> a</span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a><span class="ot">stail ::</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb28-2"><a href="#cb28-2"></a>stail (<span class="dt">S</span> a s) <span class="ot">=</span> s</span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a><span class="ot">sdropWhile ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a</span>
<span id="cb29-2"><a href="#cb29-2"></a>sdropWhile p s<span class="op">@</span>(<span class="dt">S</span> a xs)</span>
<span id="cb29-3"><a href="#cb29-3"></a>  <span class="op">|</span> p a <span class="ot">=</span> sdropWhile p xs</span>
<span id="cb29-4"><a href="#cb29-4"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> s</span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="ot">eps ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb30-2"><a href="#cb30-2"></a>eps e s <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> shead <span class="op">.</span> sdropWhile (\(x,y) <span class="ot">-&gt;</span> <span class="fu">abs</span> (x <span class="op">-</span> y) <span class="op">&gt;=</span> e)</span>
<span id="cb30-3"><a href="#cb30-3"></a>        <span class="op">$</span> szipWith (,) s (stail s)</span></code></pre></div>
<p>## Taylor series for some analytic functions</p>
<p>Here we defined examples for the functions with analytically known series at 0.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a><span class="ot">texp ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb31-2"><a href="#cb31-2"></a>texp <span class="ot">=</span> <span class="dt">S</span> <span class="dv">1</span> sdfac</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="ot">tlog ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb32-2"><a href="#cb32-2"></a>tlog <span class="ot">=</span> <span class="kw">let</span> go n s <span class="ot">=</span> <span class="dt">S</span> (s <span class="op">/</span> n) (go (n <span class="op">+</span> <span class="dv">1</span>) (<span class="op">-</span>s))</span>
<span id="cb32-3"><a href="#cb32-3"></a>       <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span> <span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a><span class="ot">tsin ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb33-2"><a href="#cb33-2"></a>tsin <span class="ot">=</span> <span class="kw">let</span> s <span class="ot">=</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">.</span> <span class="dt">S</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">$</span> s</span>
<span id="cb33-3"><a href="#cb33-3"></a>       <span class="kw">in</span> s <span class="op">^*^</span> texp</span></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="ot">tcos ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb34-2"><a href="#cb34-2"></a>tcos <span class="ot">=</span> <span class="kw">let</span> s <span class="ot">=</span> <span class="dt">S</span> <span class="dv">1</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">.</span> <span class="dt">S</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> s</span>
<span id="cb34-3"><a href="#cb34-3"></a>       <span class="kw">in</span> s <span class="op">^*^</span> texp</span></code></pre></div>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a><span class="ot">tasin ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb35-2"><a href="#cb35-2"></a>tasin <span class="ot">=</span> <span class="kw">let</span> go n <span class="ot">=</span> <span class="dt">S</span> (<span class="dv">1</span> <span class="op">/</span> n) (<span class="fu">fmap</span> (<span class="op">*</span> (n <span class="op">/</span> (n <span class="op">+</span> <span class="dv">1</span>))) <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> go (n <span class="op">+</span> <span class="dv">2</span>))</span>
<span id="cb35-3"><a href="#cb35-3"></a>        <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a><span class="ot">tacos ::</span> (<span class="dt">Eq</span> a, <span class="dt">Floating</span> a) <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb36-2"><a href="#cb36-2"></a>tacos <span class="ot">=</span> <span class="fu">pi</span> <span class="op">/</span> <span class="dv">2</span> <span class="op">-</span> tasin</span></code></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a><span class="ot">tatan ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb37-2"><a href="#cb37-2"></a>tatan <span class="ot">=</span> <span class="kw">let</span> go s n <span class="ot">=</span> <span class="dt">S</span> (s <span class="op">/</span> n) <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> go (<span class="op">-</span>s) (n <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb37-3"><a href="#cb37-3"></a>        <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> go <span class="dv">1</span> <span class="dv">1</span></span></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a><span class="ot">tsinh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb38-2"><a href="#cb38-2"></a>tsinh <span class="ot">=</span> <span class="kw">let</span> s <span class="ot">=</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="op">$</span> s</span>
<span id="cb38-3"><a href="#cb38-3"></a>        <span class="kw">in</span> s <span class="op">^*^</span> texp</span></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="ot">tcosh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb39-2"><a href="#cb39-2"></a>tcosh <span class="ot">=</span> <span class="kw">let</span> s <span class="ot">=</span> <span class="dt">S</span> <span class="dv">1</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">1</span> <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> s</span>
<span id="cb39-3"><a href="#cb39-3"></a>        <span class="kw">in</span> s <span class="op">^*^</span> texp</span></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a><span class="ot">tasinh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb40-2"><a href="#cb40-2"></a>tasinh <span class="ot">=</span> <span class="kw">let</span> go s n <span class="ot">=</span> <span class="dt">S</span> (s <span class="op">/</span> n) (<span class="fu">fmap</span> (<span class="op">*</span> (n <span class="op">/</span> (n <span class="op">+</span> <span class="dv">1</span>))) <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> go (<span class="op">-</span>s) (n <span class="op">+</span> <span class="dv">2</span>))</span>
<span id="cb40-3"><a href="#cb40-3"></a>         <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span> <span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a><span class="ot">tacosh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb41-2"><a href="#cb41-2"></a>tacosh <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a><span class="ot">tatanh ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">S</span> a</span>
<span id="cb42-2"><a href="#cb42-2"></a>tatanh <span class="ot">=</span> <span class="kw">let</span> go n <span class="ot">=</span> <span class="dt">S</span> (<span class="fu">recip</span> n) <span class="op">.</span> <span class="dt">S</span> <span class="dv">0</span> <span class="op">$</span> go (n <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb42-3"><a href="#cb42-3"></a>         <span class="kw">in</span> <span class="dt">S</span> <span class="dv">0</span> (go <span class="dv">1</span>)</span></code></pre></div>
<p>## TODO</p>
<p>Some things were not covered in this file, taylor series were not statically protected agains calling actions on the series build at the different points, so we assume that every Taylor serie is built at <span class="math inline">\(0\)</span>.</p>
<p>Not all functions from the Floating instance were implemented.</p>
<p>It’s possible to generalize <span class="math inline">\(asin/sin\)</span> approach for a wider class of functions, but it was not done yet.</p>]]></summary>
</entry>

</feed>
